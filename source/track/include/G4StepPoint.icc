// This code implementation is the intellectual property of
// the GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: G4StepPoint.icc,v 1.1 2000-02-16 16:10:05 kurasige Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
//
   inline const G4ThreeVector& G4StepPoint::GetPosition() const
   { return fPosition; }
   inline void G4StepPoint::SetPosition(const G4ThreeVector& aValue)
   { fPosition = aValue; }
   inline void G4StepPoint::AddPosition(const G4ThreeVector& aValue)
   { fPosition += aValue; }
     // Position where the track locates
    
   inline G4double G4StepPoint::GetLocalTime() const
   { return fLocalTime; }
   inline void G4StepPoint::SetLocalTime(const G4double aValue)
   { fLocalTime = aValue; }
   inline void G4StepPoint::AddLocalTime(const G4double aValue)
   { fLocalTime += aValue; }
      // Time since the track is created.
     
   inline G4double G4StepPoint::GetGlobalTime() const
   { return fGlobalTime; }
   inline void G4StepPoint::SetGlobalTime(const G4double aValue)
   { fGlobalTime = aValue; }
   inline void G4StepPoint::AddGlobalTime(const G4double aValue)
   { fGlobalTime += aValue; }
      // Time since the event in which the track belongs is created.
     
   inline G4double G4StepPoint::GetProperTime() const
   { return fProperTime; }
   inline void G4StepPoint::SetProperTime(const G4double aValue)
   { fProperTime = aValue; }
   inline void G4StepPoint::AddProperTime(const G4double aValue)
   { fProperTime += aValue; }
      // Proper time of the particle.
     
   inline const G4ThreeVector& G4StepPoint::GetMomentumDirection() const
   { return fMomentumDirection; }
   inline void G4StepPoint::SetMomentumDirection(const G4ThreeVector& aValue)
   { fMomentumDirection = aValue;
   }
   inline void G4StepPoint::AddMomentumDirection(const G4ThreeVector& aValue)
   { fMomentumDirection += aValue;
   }
     // Direction of momentum  (should be an unit vector)
    
   inline G4ThreeVector G4StepPoint::GetMomentum() const
   { 
     G4double tMomentum = sqrt(fKineticEnergy*fKineticEnergy +
                               2*fKineticEnergy*fMass);
     return G4ThreeVector(fMomentumDirection.x()*tMomentum,
			  fMomentumDirection.y()*tMomentum,
			  fMomentumDirection.z()*tMomentum);
   }
     // Total momentum of the track

   inline G4double G4StepPoint::GetTotalEnergy() const
   { 
     return fKineticEnergy + fMass; 
   }
     // Total energy of the track

   inline G4double G4StepPoint::GetKineticEnergy() const
   { return fKineticEnergy; }
   inline void G4StepPoint::SetKineticEnergy(const G4double aValue)
   { fKineticEnergy = aValue; }
   inline void G4StepPoint::AddKineticEnergy(const G4double aValue)
   { fKineticEnergy += aValue; }
     // Kinetic Energy of the track

   inline G4double G4StepPoint::GetVelocity() const
   { 
     if(fMass==0.){
        return c_light;
     } 
     else{ 
        G4double tMomentum = sqrt(fKineticEnergy*fKineticEnergy +
                                  2.0*fKineticEnergy*fMass);
        G4double tTotalEnergy = fKineticEnergy + fMass; 
        return tMomentum/tTotalEnergy*c_light;
     }   
   }
   // This velocity is the velocity as if in vacuum.
   // (So it is not corrected for the refraction index
   //   in the case of photons - optical or X-rays.)
   // In order to get the velocity in the material, use
   //   GetVelocity of G4Track.
   //

  inline G4double G4StepPoint::GetBeta() const
   { return (fMass==0.) ? 
      1.0 : 
      sqrt(fKineticEnergy*fKineticEnergy + 2.0*fKineticEnergy*fMass)
      /(fKineticEnergy+fMass); }
    // Velocity of the track in unit of c(light velocity)

   inline G4double G4StepPoint::GetGamma() const
   { return (fMass==0.) ? DBL_MAX : (fKineticEnergy+fMass)/fMass; }
     // Gamma factor (1/sqrt[1-beta*beta]) of the track    

   inline const G4VPhysicalVolume* G4StepPoint::GetPhysicalVolume() const
   { return fpTouchable->GetVolume(); }

   inline const G4VTouchable* G4StepPoint::GetTouchable() const
   { return fpTouchable; }
   inline void G4StepPoint::SetTouchable(const G4VTouchable* apValue)
   { fpTouchable = apValue; }

   inline G4double G4StepPoint::GetSafety() const
   { return fSafety; }
   inline void G4StepPoint::SetSafety(const G4double aValue)
   { fSafety = aValue; }

   inline const G4ThreeVector& G4StepPoint::GetPolarization() const
   { return fPolarization; }
   inline void G4StepPoint::SetPolarization(const G4ThreeVector& aValue)
   { fPolarization = aValue; }
   inline void G4StepPoint::AddPolarization(const G4ThreeVector& aValue)
   { fPolarization += aValue; }

   inline G4StepStatus G4StepPoint::GetStepStatus() const
   { return fStepStatus; }
   inline void G4StepPoint::SetStepStatus(const G4StepStatus aValue)
   { fStepStatus = aValue; }

   inline const G4VProcess* G4StepPoint::GetProcessDefinedStep() const
   { return fpProcessDefinedStep; }
     // If the pointer is 0, this means the Step is defined
     // by the user defined limit in the current volume.
   inline void G4StepPoint::SetProcessDefinedStep(G4VProcess* aValue)
   { fpProcessDefinedStep = aValue; }

   inline G4double G4StepPoint::GetMass() const
   { return fMass; }
   inline void G4StepPoint::SetMass(G4double value)
   { fMass = value; }

   inline G4double G4StepPoint::GetCharge() const
   { return fCharge; }
   inline void G4StepPoint::SetCharge(G4double value)
   { fCharge = value; }

   inline G4Material* G4StepPoint::GetMaterial() const
   { return fpMaterial; }
   inline void G4StepPoint::SetMaterial(G4Material* material)
   {fpMaterial = material; }

   inline void G4StepPoint::SetWeight(G4double aValue)
   { fWeight = aValue; }
   inline G4double G4StepPoint::GetWeight() const
   { return fWeight; }
