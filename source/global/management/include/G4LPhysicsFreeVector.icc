// This code implementation is the intellectual property of
// the GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: G4LPhysicsFreeVector.icc,v 1.3 2001-01-09 01:18:48 kurasige Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
// 
// ------------------------------------------------------------------
//
// Class G4LPhysicsFreeVector -- source file
//
// Derived from base class G4PhysicsVector
// This is a free vector for Low Energy Physics cross section data.
// The class name includes an "L" to distinguish it from other groups
// who may wish to implement a free vector in a different way.
// A subdivision method is used to find the energy|momentum bin.
//
// F.W. Jones, TRIUMF, 04-JUN-96
//  11 Nov. 2000, H.Kurashige : use g4std/vector for dataVector and binVector
// --------------------------------------------------------------------------

// G4PhysicsVector has PutValue() but it is inconvenient.
// Want to simultaneously fill the bin and data vectors.

inline
void G4LPhysicsFreeVector::PutValues(size_t binNumber, G4double binValue, G4double dataValue)
{
   binVector[binNumber] = binValue;
   dataVector[binNumber] = dataValue;
}

// Note that theEnergy could be energy, momentum, or whatever.
// Note: GetValue() is no longer virtual in the parent class
// G4PhysicsVector, so at present the following function cannot
// be called through a base class pointer.

inline 
G4double G4LPhysicsFreeVector::GetValue(G4double theEnergy, G4bool& isOutRange)
{
   G4double returnValue;

   //   verboseLevel = 2;

   if (theEnergy < edgeMin) {
      isOutRange = true;

#ifdef G4VERBOSE
      if (verboseLevel > 1) G4cout << "G4LPhysicsFreeVector::GetValue " <<
         theEnergy << " " << dataVector[0] << " " << isOutRange << G4endl;
#endif
      returnValue = dataVector[0];
   } 
   else if (theEnergy > edgeMax) {
      isOutRange = true;

#ifdef G4VERBOSE
      if (verboseLevel > 1) G4cout << "G4LPhysicsFreeVector::GetValue " <<
         theEnergy << " " << dataVector[numberOfBin - 1] << " " << 
         isOutRange << G4endl;
#endif
      returnValue = dataVector[numberOfBin - 1];
   } 
   else {
     isOutRange = false;

     G4int n = FindBinLocation(theEnergy);

     G4double dsde = (dataVector[n + 1] - dataVector[n])/
                     (binVector[n + 1] - binVector[n]);
#ifdef G4VERBOSE
     if (verboseLevel > 1) G4cout << "G4LPhysicsFreeVector::GetValue " << 
        theEnergy << " " << dataVector[n] + (theEnergy - binVector[n])*dsde <<
        " " << isOutRange << G4endl;
#endif
     returnValue = dataVector[n] + (theEnergy - binVector[n])*dsde;
   }
   return returnValue;
}                                                                  

inline
void G4LPhysicsFreeVector::SetVerboseLevel(G4int value)
{
   verboseLevel = value;
}

inline
G4int G4LPhysicsFreeVector::GetVerboseLevel(G4int)
{
   return verboseLevel;
}

inline
G4double G4LPhysicsFreeVector::GetLastEnergy()
{
   return lastEnergy;
}

inline
size_t G4LPhysicsFreeVector::GetLastBin()
{
   return lastBin;
}

inline 
size_t G4LPhysicsFreeVector::FindBinLocation(G4double theEnergy) const
{
   G4int n1 = 0;
   G4int n2 = numberOfBin/2;
   G4int n3 = numberOfBin - 1;
   while (n1 != n3 - 1) {
      if (theEnergy > binVector[n2])
         n1 = n2;
      else
         n3 = n2;
      n2 = n1 + (n3 - n1 + 1)/2;
   }
#ifdef G4VERBOSE
   if (verboseLevel > 1) G4cout << 
      "G4LPhysicsFreeVector::FindBinLocation:  returning " << n1 << G4endl;
#endif
   return (size_t)n1;
}
