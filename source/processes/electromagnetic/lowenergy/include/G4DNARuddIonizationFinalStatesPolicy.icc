//
// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
//
// $Id: G4DNARuddIonizationFinalStatesPolicy.icc,v 2005/09/19 19:08:54 Ziad FRANCIS
// GEANT4 tag $Name: not supported by cvs2svn $
//

#ifdef   G4DNARuddIonizationFinalStatesPolicy_HH
 #include "Randomize.hh"


 template <typename EnergyLimitsPolicy, typename IncomingParticlePolicy>
 G4bool                                 G4DNARuddIonizationFinalStatesPolicy<EnergyLimitsPolicy, IncomingParticlePolicy> :: KillIncomingParticle(G4double energy) const
 {
 if(energy < EnergyLimitsPolicy::lowEnergyLimit) return(true);
 else return (false);
 }

 template <typename EnergyLimitsPolicy, typename IncomingParticlePolicy>
 void                               G4DNARuddIonizationFinalStatesPolicy<EnergyLimitsPolicy, IncomingParticlePolicy> ::BuildFinalStatesData(void) const
 {}

 template <typename EnergyLimitsPolicy, typename IncomingParticlePolicy>
 G4double                               G4DNARuddIonizationFinalStatesPolicy<EnergyLimitsPolicy, IncomingParticlePolicy> ::RandomizeEjectedElectronEnergy(G4double k, G4int shell) const
 {
 G4double maximumKineticEnergyTransfer = 4.* (electron_mass_c2 / proton_mass_c2) * k;
 G4double crossSectionMaximum=0.;
 for(G4double value=EnergyConstant(shell); value<=4.*EnergyConstant(shell) ; value+=0.1*eV){
                                                         G4double differentialCrossSection = DifferentialCrossSection(k, value, shell);
							 if(differentialCrossSection >= crossSectionMaximum) crossSectionMaximum = differentialCrossSection;
							 }
 G4double secElecKinetic=0.;
 do{
   secElecKinetic = G4UniformRand() * maximumKineticEnergyTransfer;
   }while(G4UniformRand()*crossSectionMaximum > DifferentialCrossSection(k,secElecKinetic+EnergyConstant(shell),shell));
 return(secElecKinetic);
 }

 template <typename EnergyLimitsPolicy, typename IncomingParticlePolicy>
 G4double                               G4DNARuddIonizationFinalStatesPolicy<EnergyLimitsPolicy, IncomingParticlePolicy> ::CorrectionFactor(G4double k) const
 {
 if(IncomingParticlePolicy::IncomingParticleDefinition()->GetParticleName() == "proton") return(1);
 else if(IncomingParticlePolicy::IncomingParticleDefinition()->GetParticleName() == "hydrogen") {
                                                                       G4double value = (std::log(k/eV)-4.2)/0.5;
                                                                       return((0.8/(1+std::exp(value))) + 0.9);
								       }
 else return(1.);
 }

 template <typename EnergyLimitsPolicy, typename IncomingParticlePolicy>
 void                               G4DNARuddIonizationFinalStatesPolicy<EnergyLimitsPolicy, IncomingParticlePolicy> ::RandomizeEjectedElectronDirection(G4double k, G4double secKinetic, G4double & cosTheta, G4double & phi ) const
 {
 G4double maxSecKinetic = 4.* (electron_mass_c2 / proton_mass_c2) * k;
 phi = twopi * G4UniformRand();
 cosTheta = std::sqrt(secKinetic / maxSecKinetic);
 }

 template <typename EnergyLimitsPolicy,typename IncomingParticlePolicy>
 G4double                               G4DNARuddIonizationFinalStatesPolicy<EnergyLimitsPolicy, IncomingParticlePolicy>::EnergyConstant(G4int ionizationLevel) const
 {
 const G4double bindingEnergy[]={10.79*eV, 13.39*eV, 16.05*eV, 32.30*eV, 539.0*eV};
 return(bindingEnergy[ionizationLevel]);
 }


 template <typename EnergyLimitsPolicy, typename IncomingParticlePolicy>
 G4double                               G4DNARuddIonizationFinalStatesPolicy<EnergyLimitsPolicy, IncomingParticlePolicy>::DifferentialCrossSection(G4double k, G4double energyTransfer, G4int ionizationLevelIndex) const
 {
  // Shells ids are 0 1 2 3 4 (4 is k shell)
  // !!Attention, "energyTransfer" here is the energy transfered to the electron which means
  //             that the secondary kinetic energy is w = energyTransfer - bindingEnergy
  //
  //   ds            S                F1(nu) + w * F2(nu)
  //  ---- = G(k) * ----     -------------------------------------------
  //   dw            Bj       (1+w)^3 * [1 + exp{alpha * (w - wc) / nu}]
  //
  // w is the secondary electron kinetic Energy in eV
  //
  // All the other parameters can be found in Rudd's Papers
  //
  // M.Eugene Rudd, 1988, User-Friendly model for the energy distribution of
  // electrons from protons or electron collisions. Nucl. Tracks Rad. Meas.Vol 16 N0 2/3 pp 219-218
  //

 const G4int j=ionizationLevelIndex;

 G4double A1 ; G4double B1 ; G4double C1 ; G4double D1 ; G4double E1 ;
 G4double A2 ; G4double B2 ; G4double C2 ; G4double D2 ; G4double Alpha ;

 if(j == 4) {//Data For Liquid Water K SHELL from Dingfelder (Protons in Water)
 A1 = 1.25; B1 = 0.5; C1 = 1.00; D1 = 1.00; E1 = 3.00; A2 = 1.10; B2 = 1.30;
 C2 = 1.00; D2 = 0.00; Alpha = 0.66;}
 else {//Data For Liquid Water from Dingfelder (Protons in Water)
 A1 = 1.02; B1 = 82.0; C1 = 0.45; D1 = -0.80; E1 = 0.38; A2 = 1.07; B2 = 14.6;
 C2 = 0.60; D2 = 0.04; Alpha = 0.64;}

 const G4double n = 2.;
 const G4double Gj[5] = {0.99, 1.11, 1.11, 0.52, 1.};

 //const G4double I[5]={12.61*eV, 14.73*eV, 18.55*eV, 32.2*eV, 539.7*eV}; // for water Vapor
 //const G4double energyConstant[]={10.79*eV, 13.39*eV, 16.05*eV, 32.30*eV, 539.*eV};

 G4double W = (energyTransfer - EnergyConstant(ionizationLevelIndex));
 G4double w = W / EnergyConstant(ionizationLevelIndex);
 G4double Ry = 13.6*eV;

 G4double tau = (electron_mass_c2/proton_mass_c2) * k ;

 G4double S = 4.*pi*Bohr_radius*Bohr_radius*n*std::pow((Ry/EnergyConstant(ionizationLevelIndex)),2);
 G4double v2 = tau / EnergyConstant(ionizationLevelIndex);
 G4double v = std::sqrt(v2);
 G4double wc = 4.*v2 - 2.*v - (Ry/(4.*EnergyConstant(ionizationLevelIndex)));

 G4double L1 = (C1* std::pow(v,(D1))) / (1.+ E1*std::pow(v, (D1+4.)));
 G4double L2 = C2*std::pow(v,(D2));
 G4double H1 = (A1*std::log(1.+v2)) / (v2+(B1/v2));
 G4double H2 = (A2/v2) + (B2/(v2*v2));

 G4double F1 = L1+H1;
 G4double F2 = (L2*H2)/(L2+H2);


 G4double sigma = CorrectionFactor(k/eV) * Gj[j] * (S/EnergyConstant(ionizationLevelIndex)) * ( (F1+w*F2) / ( std::pow((1.+w),3) * ( 1.+std::exp(Alpha*(w-wc)/v))) );
return(sigma);
}

#endif /* G4DNARuddIonizationTotalCrossSectionPolicy_HH */

