// ********************************************************************
// * License and Disclaimer                                           *
// *                                                                  *
// * The  Geant4 software  is  copyright of the Copyright Holders  of *
// * the Geant4 Collaboration.  It is provided  under  the terms  and *
// * conditions of the Geant4 Software License,  included in the file *
// * LICENSE and available at  http://cern.ch/geant4/license .  These *
// * include a list of copyright holders.                             *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.  Please see the license in the file  LICENSE  and URL above *
// * for the full disclaimer and the limitation of liability.         *
// *                                                                  *
// * This  code  implementation is the result of  the  scientific and *
// * technical work of the GEANT4 collaboration.                      *
// * By using,  copying,  modifying or  distributing the software (or *
// * any work based  on the software)  you  agree  to acknowledge its *
// * use  in  resulting  scientific  publications,  and indicate your *
// * acceptance of all terms of the Geant4 Software license.          *
// ********************************************************************
//
// -------------------------------------------------------------------
// $Id: G4DNAFinalStatesPolicyIonizationRudd.icc,v 1.1 2007-10-08 09:18:43 sincerti Exp $
// -------------------------------------------------------------------
//

#ifdef G4DNAFinalStatesPolicyIonizationRudd_HH

#include "Randomize.hh"
#include "G4DNAGenericIonsManager.hh"

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::RandomizeEjectedElectronEnergy
(const G4Track& track, G4double k, G4int shell) 
{
 G4double maximumKineticEnergyTransfer;
 
 G4ParticleDefinition* myParticleDefinition = track.GetDefinition();
  G4DNAGenericIonsManager *instance;
  instance = G4DNAGenericIonsManager::Instance();

 if (    myParticleDefinition == G4Proton::ProtonDefinition() 
      || myParticleDefinition == instance->GetIon("hydrogen")
     ) 
  { maximumKineticEnergyTransfer= 4.* (electron_mass_c2 / proton_mass_c2) * k;}

 if (    myParticleDefinition == instance->GetIon("helium") 
      || myParticleDefinition == instance->GetIon("alpha+")
      || myParticleDefinition == instance->GetIon("alpha++")
     ) 
  { maximumKineticEnergyTransfer= 4.* (0.511 / 3728) * k;}

 G4double crossSectionMaximum=0.;
 for(G4double value=EnergyConstant(shell); value<=4.*EnergyConstant(shell) ; value+=0.1*eV)
 {
    G4double differentialCrossSection = DifferentialCrossSection(track, k, value, shell);
    if(differentialCrossSection >= crossSectionMaximum) crossSectionMaximum = differentialCrossSection;
 }
 G4double secElecKinetic=0.;
 do{
      secElecKinetic = G4UniformRand() * maximumKineticEnergyTransfer;
      } while(G4UniformRand()*crossSectionMaximum > DifferentialCrossSection(track, k,secElecKinetic+EnergyConstant(shell),shell));
 return(secElecKinetic);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::CorrectionFactor
(G4ParticleDefinition * aParticleDefinition, G4double k) 
{
  G4DNAGenericIonsManager *instance;
  instance = G4DNAGenericIonsManager::Instance();

      if(aParticleDefinition == G4Proton::Proton()) return(1);
 else if(aParticleDefinition == instance->GetIon("hydrogen")) 
 	{ 
          G4double value = (log(k/eV)-4.2)/0.5;
          return((0.8/(1+exp(value))) + 0.9);
	}
 else return(1.);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

void G4DNAFinalStatesPolicyIonizationRudd
::RandomizeEjectedElectronDirection
(G4ParticleDefinition * aParticleDefinition, G4double k, G4double secKinetic, G4double & cosTheta, G4double & phi ) 
{

 G4DNAGenericIonsManager *instance;
 instance = G4DNAGenericIonsManager::Instance();

 G4double maxSecKinetic;
 
 if (    aParticleDefinition == G4Proton::ProtonDefinition() 
      || aParticleDefinition == instance->GetIon("hydrogen")
     ) 
  { maxSecKinetic = 4.* (electron_mass_c2 / proton_mass_c2) * k;}
  
 if (    aParticleDefinition == instance->GetIon("helium") 
      || aParticleDefinition == instance->GetIon("alpha+")
      || aParticleDefinition == instance->GetIon("alpha++")
     ) 
  { maxSecKinetic = 4.* (0.511 / 3728) * k;}

  
 phi = twopi * G4UniformRand();
 cosTheta = sqrt(secKinetic / maxSecKinetic);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::EnergyConstant
(G4int ionizationLevel) 
{
 const G4double bindingEnergy[]={10.79*eV, 13.39*eV, 16.05*eV, 32.30*eV, 539.0*eV};
 return(bindingEnergy[ionizationLevel]);
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::DifferentialCrossSection
(const G4Track& track, G4double k, G4double energyTransfer, G4int ionizationLevelIndex) 
 {
  // Shells ids are 0 1 2 3 4 (4 is k shell)
  // !!Attention, "energyTransfer" here is the energy transfered to the electron which means
  //             that the secondary kinetic energy is w = energyTransfer - bindingEnergy
  //
  //   ds            S                F1(nu) + w * F2(nu)
  //  ---- = G(k) * ----     -------------------------------------------
  //   dw            Bj       (1+w)^3 * [1 + exp{alpha * (w - wc) / nu}]
  //
  // w is the secondary electron kinetic Energy in eV
  //
  // All the other parameters can be found in Rudd's Papers
  //
  // M.Eugene Rudd, 1988, User-Friendly model for the energy distribution of
  // electrons from protons or electron collisions. Nucl. Tracks Rad. Meas.Vol 16 N0 2/3 pp 219-218
  //

 const G4int j=ionizationLevelIndex;

 G4double A1 ; G4double B1 ; G4double C1 ; G4double D1 ; G4double E1 ;
 G4double A2 ; G4double B2 ; G4double C2 ; G4double D2 ; G4double Alpha ;

 if(j == 4) {//Data For Liquid Water K SHELL from Dingfelder (Protons in Water)
 A1 = 1.25; B1 = 0.5; C1 = 1.00; D1 = 1.00; E1 = 3.00; A2 = 1.10; B2 = 1.30;
 C2 = 1.00; D2 = 0.00; Alpha = 0.66;}
 else {//Data For Liquid Water from Dingfelder (Protons in Water)
 A1 = 1.02; B1 = 82.0; C1 = 0.45; D1 = -0.80; E1 = 0.38; A2 = 1.07; B2 = 14.6;
 C2 = 0.60; D2 = 0.04; Alpha = 0.64;}

 const G4double n = 2.;
 const G4double Gj[5] = {0.99, 1.11, 1.11, 0.52, 1.};

 //const G4double I[5]={12.61*eV, 14.73*eV, 18.55*eV, 32.2*eV, 539.7*eV}; // for water Vapor
 //const G4double energyConstant[]={10.79*eV, 13.39*eV, 16.05*eV, 32.30*eV, 539.*eV};

 G4ParticleDefinition* myParticleDefinition = track.GetDefinition();
  G4DNAGenericIonsManager *instance;
  instance = G4DNAGenericIonsManager::Instance();

 G4double W = (energyTransfer - EnergyConstant(ionizationLevelIndex));
 G4double w = W / EnergyConstant(ionizationLevelIndex);
 G4double Ry = 13.6*eV;

 G4double tau;

 if (    myParticleDefinition == G4Proton::ProtonDefinition() 
      || myParticleDefinition == instance->GetIon("hydrogen")
     ) 
  {
   tau = (electron_mass_c2/proton_mass_c2) * k ;
  }
   
 if (    myParticleDefinition == instance->GetIon("helium") 
      || myParticleDefinition == instance->GetIon("alpha+")
      || myParticleDefinition == instance->GetIon("alpha++")
     ) 
  {
   tau = (0.511/3728) * k ;
  }
 
 G4double S = 4.*pi*Bohr_radius*Bohr_radius*n*pow((Ry/EnergyConstant(ionizationLevelIndex)),2);
 G4double v2 = tau / EnergyConstant(ionizationLevelIndex);
 G4double v = sqrt(v2);
 G4double wc = 4.*v2 - 2.*v - (Ry/(4.*EnergyConstant(ionizationLevelIndex)));

 G4double L1 = (C1* pow(v,(D1))) / (1.+ E1*pow(v, (D1+4.)));
 G4double L2 = C2*pow(v,(D2));
 G4double H1 = (A1*log(1.+v2)) / (v2+(B1/v2));
 G4double H2 = (A2/v2) + (B2/(v2*v2));

 G4double F1 = L1+H1;
 G4double F2 = (L2*H2)/(L2+H2);

 G4double sigma = CorrectionFactor(track.GetDefinition(), k/eV) 
    * Gj[j] * (S/EnergyConstant(ionizationLevelIndex)) * ( (F1+w*F2) / ( pow((1.+w),3) * ( 1.+exp(Alpha*(w-wc)/v))) );
    
 if (    myParticleDefinition == G4Proton::ProtonDefinition() 
      || myParticleDefinition == instance->GetIon("hydrogen")
     ) 
  {return(sigma);}

  // ------------
  
   if (myParticleDefinition == instance->GetIon("alpha++") ) 
  {
   slaterEffectiveCharge[0]=0.;
   slaterEffectiveCharge[1]=0.;
   slaterEffectiveCharge[2]=0.;
   sCoefficient[0]=0.;
   sCoefficient[1]=0.;
   sCoefficient[2]=0.;
  }

  if (myParticleDefinition == instance->GetIon("alpha+") ) 
  {
   slaterEffectiveCharge[0]=2.0;
   slaterEffectiveCharge[1]=1.15;
   slaterEffectiveCharge[2]=1.15;
   sCoefficient[0]=0.7;
   sCoefficient[1]=0.15;
   sCoefficient[2]=0.15;
  }

  if (myParticleDefinition == instance->GetIon("helium") ) 
  {
   slaterEffectiveCharge[0]=1.7;
   slaterEffectiveCharge[1]=1.15;
   slaterEffectiveCharge[2]=1.15;
   sCoefficient[0]=0.5;
   sCoefficient[1]=0.25;
   sCoefficient[2]=0.25;
  }
  
 if (    myParticleDefinition == instance->GetIon("helium") 
      || myParticleDefinition == instance->GetIon("alpha+")
      || myParticleDefinition == instance->GetIon("alpha++")
      ) 
  {
  sigma = Gj[j] * (S/EnergyConstant(ionizationLevelIndex)) * ( (F1+w*F2) / ( pow((1.+w),3) * ( 1.+exp(Alpha*(w-wc)/v))) );
    
  G4double zEff = myParticleDefinition->GetPDGCharge() / eplus + myParticleDefinition->GetLeptonNumber();
  
  zEff -= ( sCoefficient[0] * S_1s(k, energyTransfer, slaterEffectiveCharge[0], 1.) +
	    sCoefficient[1] * S_2s(k, energyTransfer, slaterEffectiveCharge[1], 2.) +
	    sCoefficient[2] * S_2p(k, energyTransfer, slaterEffectiveCharge[2], 2.) );
	   
  return zEff * zEff * sigma ;
  }  
  
  return 0;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::S_1s
(G4double t, G4double energyTransferred, G4double slaterEffectiveCharge, G4double shellNumber)
{
  // 1 - e^(-2r) * ( 1 + 2 r + 2 r^2)
  // Dingfelder, in Chattanooga 2005 proceedings, formula (7)
 
  G4double r = R(t, energyTransferred, slaterEffectiveCharge, shellNumber);
  G4double value = 1. - std::exp(-2 * r) * ( ( 2. * r + 2. ) * r + 1. );
  
  return value;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::S_2s
(G4double t,G4double energyTransferred, G4double slaterEffectiveCharge, G4double shellNumber)
{
  // 1 - e^(-2 r) * ( 1 + 2 r + 2 r^2 + 2 r^4)
  // Dingfelder, in Chattanooga 2005 proceedings, formula (8)

  G4double r = R(t, energyTransferred, slaterEffectiveCharge, shellNumber);
  G4double value =  1. - std::exp(-2 * r) * (((2. * r * r + 2.) * r + 2.) * r + 1.);

  return value;
 
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::S_2p
(G4double t, G4double energyTransferred,G4double slaterEffectiveCharge, G4double shellNumber)
{
  // 1 - e^(-2 r) * ( 1 + 2 r + 2 r^2 + 4/3 r^3 + 2/3 r^4)
  // Dingfelder, in Chattanooga 2005 proceedings, formula (9)

  G4double r = R(t, energyTransferred, slaterEffectiveCharge, shellNumber);
  G4double value =  1. - std::exp(-2 * r) * (((( 2./3. * r + 4./3.) * r + 2.) * r + 2.) * r  + 1.);

  return value;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

G4double G4DNAFinalStatesPolicyIonizationRudd
::R
(G4double t,G4double energyTransferred,G4double slaterEffectiveCharge,G4double shellNumber) 
{
  // tElectron = m_electron / m_alpha * t
  // Hardcoded in Riccardo's implementation; to be corrected
  // Dingfelder, in Chattanooga 2005 proceedings, p 4

  G4double tElectron = 0.511/3728. * t;
  G4double value = 2. * tElectron * slaterEffectiveCharge / (energyTransferred * shellNumber);
  
  return value;
}

//....oooOO0OOooo........oooOO0OOooo........oooOO0OOooo........oooOO0OOooo....

#endif 
