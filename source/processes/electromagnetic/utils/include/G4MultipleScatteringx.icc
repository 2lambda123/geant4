//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * The following disclaimer summarizes all the specific disclaimers *
// * of contributors to this software. The specific disclaimers,which *
// * govern, are listed with their locations in:                      *
// *   http://cern.ch/geant4/license                                  *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * This  code  implementation is the  intellectual property  of the *
// * GEANT4 collaboration.                                            *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//
// $Id: G4MultipleScatteringx.icc,v 1.4 2001-07-11 10:03:40 gunter Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
// $Id: 
// -------------------------------------------------------------
//    GEANT 4 class inlined methods file
//
//    History: based on object model of
//    2nd December 1995, G.Cosmo
//    ------- G4MultipleScatteringx physics process ------
//              by Laszlo Urban, March 2001
//---------------------------------------------------------------
//            New version of MSC model
//---------------------------------------------------------------
// Modified:
// 18/05/01 V.Ivanchenko Clean up againist Linux ANSI compilation 
//
//---------------------------------------------------------------


inline G4double G4MultipleScatteringx::AlongStepGetPhysicalInteractionLength(
                             const G4Track& track,
                             G4double previousStepSize,
                             G4double currentMinimumStep,
                             G4double& currentSafety,
                             G4GPILSelection* selection
                            )
{
  // get Step limit proposed by the process
  G4double steplength = 
     GetContinuousStepLimit(track,previousStepSize,currentMinimumStep, currentSafety);

  // set return value for G4GPILSelection
  *selection = valueGPILSelectionMSC;

  return  steplength ;
}


inline G4double G4MultipleScatteringx::GetContinuousStepLimit(
                                     const G4Track& track,                  
                                     G4double,
                                     G4double currentMinimumStep,
                                     G4double&)
{
  G4double zPathLength,tPathLength ;
  const G4DynamicParticle* aParticle ;
  G4Material* aMaterial ;
  G4double KineticEnergy,tau ;
  G4bool isOut ;

  static const G4double tlimmin = 1.e-6*mm ;
  G4double tlimit ;

  G4double etau,beta2,cc,ccc,u  ;

  // this process is not a candidate for selection by default !!!!!!!!
  valueGPILSelectionMSC = NotCandidateForSelection;

  tPathLength = currentMinimumStep ;

  aMaterial = track.GetMaterial() ;
  materialIndex = aMaterial->GetIndex() ;

  aParticle = track.GetDynamicParticle() ;
  KineticEnergy = aParticle->GetKineticEnergy() ;

  if((lastMaterial != aMaterial) || (lastKineticEnergy != KineticEnergy))
  {
    lastKineticEnergy = KineticEnergy ;
    materialIndex = aMaterial->GetIndex() ;

    fTransportMeanFreePath = (*theTransportMeanFreePathTable)
                             (materialIndex)->GetValue(KineticEnergy,isOut);

    lastMaterial = aMaterial;
  }

  //  special treatment near boundaries ?
  if(boundary)  
  {
    // step limitation at boundary ?
    if(track.GetCurrentStepNumber() > 1)
    {
      tlimit = G4std::max(fTransportMeanFreePath,tlimmin) ;

      if((track.GetStep()->GetPreStepPoint()->GetSafety() < tlimit)
              && (tPathLength > tlimit))
      {
        tPathLength = factlim*fTransportMeanFreePath ;
        valueGPILSelectionMSC = CandidateForSelection;
      }
    }   
  }

  //  do the true -> geom transformation
  tau = tPathLength/fTransportMeanFreePath ;

  if( tau < tausmall)
  {
    zPathLength = tPathLength ;
  }
  else if(tau < taulim)
  {
     zPathLength = tPathLength*(1.-0.5*tau)  ;
  }
  else
  {
    // sample zPathLength
    etau = exp(-tau) ;
    cc=0.5/scatteringparameter1-1.5 ;
    ccc=2.*scatteringparameter1*exp(cc) ;

    beta2 = 0.5*(1.+scatteringparameter1)*(1.-etau)/(tau-1+etau) ;
    do {
         u = -log(1.-G4UniformRand())/beta2 ;
        } while (G4UniformRand() > (1.-scatteringparameter1+
                2.*scatteringparameter1*beta2*u)*exp(-beta2*u)/ccc ) ;
    zPathLength = tPathLength/(1.+u) ;
  }

  tLast = tPathLength ;
  zLast = zPathLength ; 

  return zPathLength ;
}

inline G4double G4MultipleScatteringx::GetMeanFreePath(
                                            const G4Track& track,
                                            G4double,
                                            G4ForceCondition* condition)

 //  it does not limit the Step size , but it sets condition to
 //   Forced , because the PostStepDoIt always has to be called

  {
    *condition = Forced ;

    return DBL_MAX ;
  }

inline G4VParticleChange* G4MultipleScatteringx::AlongStepDoIt(
                                       const G4Track& track,const G4Step& Step)          
 //   only a geom path->true path transformation is performed
{
  static const G4double tfacmx = 10. ;
  G4double tau,geomPathLength, truePathLength ;

  G4double ltau,cc,ccc,beta2,u ;

  fParticleChange.Initialize(track);

  geomPathLength = track.GetStepLength() ;

  if(geomPathLength == zLast)
  { 
    truePathLength = tLast ;
  }
  else
  {
    tau = geomPathLength/fTransportMeanFreePath ;

    if( tau < tausmall)
    {
      truePathLength = geomPathLength ;  
    }
    else if(tau < taulim)
    {
      truePathLength = geomPathLength*(1.+0.5*tau) ;
    }
    else if(tau < 1.)
    {
      // sample tPathLength
      ltau = -log(1.-tau) ;
      cc=0.5/scatteringparameter1-1.5 ;
      ccc=2.*scatteringparameter1*exp(cc) ;
       
      beta2 = (1.+scatteringparameter1)*tau/(2.*(ltau-tau)) ;
      do {
           u = -log(1.-G4UniformRand())/beta2 ;
         } while (G4UniformRand() > (1.-scatteringparameter1+
                      2.*scatteringparameter1*beta2*u)*exp(-beta2*u)/ccc ) ;
      truePathLength = geomPathLength*(1.+u) ;
    }
    else
      truePathLength = tfacmx*fTransportMeanFreePath ;
  }

  fParticleChange.SetTrueStepLength(truePathLength) ;

  return &fParticleChange ;
  
}


inline G4bool G4MultipleScatteringx::IsApplicable(
                                    const G4ParticleDefinition& particle)
  {
   return(particle.GetPDGCharge() != 0.);
  }

inline G4double G4MultipleScatteringx::GetLambda(
                              G4double KineticEnergy,
                              G4Material* material)
{
  G4bool isOut;
  
  G4double lambda = (*theTransportMeanFreePathTable)
                    (material->GetIndex())->
                    GetValue(KineticEnergy,isOut);
  return lambda;
}
