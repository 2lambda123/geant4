
 Last update: 02-Dec-2009
 ========================

 This directory contains a configurable calorimeter setup to be used
 as statistical acceptance suite of Geant4, that is to validate a
 new release with respect the previous one (regression test).

 The setup Bash script, exerciseSetup.sh, is meant for the Grid,
 under the assumption that all the needed software is installed
 in the directory  $VO_GEANT4_SW_DIR/dirInstallations 
 (the environmental variable VO_GEANT4_SW_DIR is automatically
  defined when you run on the Grid).

 To add flexibility to this tool, it is possible to send to a
 Grid site, together with the job, also a Geant4 release and this 
 application directory (StatAccepTest/). If such Geant4 release is 
 found in the parent directory of the application directory 
 (i.e. in ../StatAccepTest/), then this release is used; if not, 
 then it will be taken from $VO_GEANT4_SW_DIR/dirInstallations .
 However, recently (2009) we have found more convenient (and
 indeed needed on OSG sites) to ship directly the binaries
 (see below for more details).

 If you want to run on your computer, then you need to modify
 the setup script: look at  exerciseSetup.sh  and  build.py .

 If you want to run a simulation with a Geant4 version before 9.2,
 then you need to specify the Physics List inside the main
 program, mainStatAccepTest.cc  (see "***LOOKHERE***").
 Starting with Geant4 version 9.2, you can build only a single 
 executable (for a given platform), and then you can select the 
 Physics List at run time, by setting the environmental variable
 PHYSLIST . For instance:
                               export PHYSLIST=FTFP
 sets the FTFP Physics List.
 If $PHYSLIST is undefined, then by default the Physics List 
 QGSP_BERT will be automatically selected. 

 If you run on the Grid, for each platform (e.g. SLC4 32-bits, 
 SLC4 64-bits, SLC5 64-bits, etc.) you need a different 
 installation tar-ball; however, for the application tar-ball,
 you do not need a separate tar-ball: you can have in a single
 tar-ball the following 3 platforms:
   SLC4 32-bits : slc4-i386
   SLC4 64-bits : slc4-x86_64
   SLC5 64-bits : slc5-x86_64
 The shell script  identify_release.sh  defined an environmental
 variable, $RELEASENAME, whose value is 'slc4' or 'slc5'.
 So you can prepare a single tar-ball containing the 
 following 6 executables:
   1) 32-bits REF1 : e.g.  mainStatAccepTest-9.2.p01-slc4-i386 
   2) 32-bits REF2 : e.g.  mainStatAccepTest-9.2.cand01-slc4-i386 
   3) 64-bits REF1 : e.g.  mainStatAccepTest-9.2.p01-slc4-x86_64
   4) 64-bits REF2 : e.g.  mainStatAccepTest-9.2.cand01-slc4-x86_64
   5) 64-bits REF1 : e.g.  mainStatAccepTest-9.2.p01-slc5-x86_64
   6) 64-bits REF2 : e.g.  mainStatAccepTest-9.2.cand01-slc5-x86_64
 Notice that you can get "i386" or "x86_64" with the command
 `uname -i`, and "slc4" or "slc5" from $RELEASENAME (produced
 by the script identify_release.sh).
 In the case of SLC5, because the native compiler is g++ 4.1,
 but we are interested in g++ 4.3, the following directories
 should be copied in  lib_slc5_x86_64/ :
    gcc43/  gmp/  mpfr/
 which are copied from, respectively:
    /afs/cern.ch/sw/lcg/contrib/gcc/4.3/x86_64-slc5-gcc34-opt/lib64
    /afs/cern.ch/sw/lcg/contrib/gmp/4.2.2/x86_64-slc5-gcc34-opt/lib
    /afs/cern.ch/sw/lcg/contrib/mpfr/2.3.1/x86_64-slc5-gcc34-opt/lib
 and then the LD_LIBRARY_PATH should be set, at the end, as:
   export LD_LIBRARY_PATH=$basedir/gcc43:$basedir/gmp:$basedir/mpfr:$LD_LIBRARY_PATH
 where  basedir=$G4WORKDIR/lib_${RELEASENAME}_`uname -i` .

 Furthermore, in order to let ROOT to find the library
 libG4TypesDict.so , which is automatically created when you
 build the binaries in:
    $G4WORKDIR/tmp/$G4SYSTEM/mainStatAccepTest/
 you need to create by hand the subdirectories:
    a)  $G4WORKDIR/lib_slc4_i386/Linux-g++/  
    b)  $G4WORKDIR/lib_slc4_x86_64/Linux-g++/
    c)  $G4WORKDIR/lib_slc5_x86_64/Linux-g++/
 and then copy (by hand) such library:
   cp $G4WORKDIR/tmp/$G4SYSTEM/mainStatAccepTest/libG4TypesDict.so \
      $G4WORKDIR/lib_${RELEASENAME}_`uname -i`/Linux-g++/
 and finally setting the library path:
 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:$G4WORKDIR/tmp/$G4SYSTEM/mainStatAccepTest/
 After that, you can delete the directory $G4WORKDIR/tmp .
 Notice that it does not matter which version of Geant4
 you use: in practice, you can use the reference version. 

 If you want to build a fully static executable (this can be
 convenient if you want to avoid to build it on the remote
 Grid site, and not depending on the compiler installed there),
 you need to define the environmental variable
       export FULLY_STATIC_EXECUTABLE=1
 before building the executable.
 Notice that at run time the variable $FULLY_STATIC_EXECUTABLE
 is not used at all.
 With this variable you can avoid to use the shared libraries
 of Geant4, but in general you won't get a fully static
 executable.

 If you want to activate the Stacking Action, in order to run
 in biasing mode, then you need to define the environmental
 variable IS_BIASING_ACTIVE, e.g.
       export IS_BIASING_ACTIVE=1
 Furthermore, look at the biasing parameters in the file
  src/StatAccepTestStackingAction.cc
 (search for the string "***LOOKHERE***").

 If you want to produce (many) extra histograms, besides the
 ntuple (and few other basic histograms), you need to define
 the environmental variable HISTOGRAMS_ON, e.g.
       export HISTOGRAMS_ON=1
 before compiling.

 In the macro command file  * exercise.g4 *  you can choose: 
   -  the production range cut;
   -  the beam particle type;
   -  the beam energy;
   -  the number of events;
   -  the calorimeter type;
   -  the eventual transverse magnetic field. 
 See the command file to look at the various options available.

 The calorimeter is a cylinder, with the axis (length of the 
 cylinder) along the beam direction, which is along the Z-axis.
 This radius of the calorimeter, and the total thickness
 of the absorber, can be specified either in unit of lambdas 
 of the absorber material, or in normal length in [mm]. 
 The user has to specified also the thickness (in [mm]) of a
 single layer of active material, and the number of layers.
 Also the number of readout layers can be specified, in the
 case it is different than the number of active layers: if the
 number of readout layers is not explicitly set, then it is 
 assumed to be the same as the number of active layers; if it 
 is set explicitly, then it must be a divisor of the number of
 active layers, otherwise it is forced to be equal to it.
 (Notice that the concept of "readout layer" appears only at
  the level of analysis, not at the level of detector 
  construction.)
 In the case of an homogeneous calorimeter, for instance PbWO4,
 the number of layers indicate essentially the number of sampling
 we can have for the longitudinal shower profile.
 Finally, the number of bins for the lateral shower profile should
 also be specified, and the width (radius) of the first bin in unit
 of lambda (of the absorber) or in [mm]. The bins have incresing
 size as the radius grows, in such a way to keep enough statistics
 in spite of the rapid decrease of the shower with the radius.   
 
 In the case of Scintillator as active material, it is possible
 to switch on the quenching effect as described by the Birks' law.
 By the default it is not active; to switch it on, and to have 
 more details, look at the string "***LOOKHERE***" in the file: 
 StatAccepTestSensitiveCalorimeter.cc .

 In the case you want to run the simulation only to get the 
 information printed out (in the screen) at the end of execution,
 without the ntuple and the histograms, then it is enough to
 not define the environmental variable  G4ANALYSIS_USEROOT . 
 In this case, you do not need ROOT.

 If the environmental variable G4ANALYSIS_USEROOT is defined 
 (and you have somewhere a ROOT installation, specified in
  the environmental variable ROOTSYS), then the output of the 
 program is a ROOT tree  * ntuple.tree *  which contains some 
 physics variables, like the total energy deposit in the active layers,
 the total deposit in the whole calorimeter, the energy deposit in 
 each active layer, and the transverse energy deposition sum over all
 the active layers, in a certain number of radial bins.

 In the same ROOT file, also a number of histograms can be
 produced, describing the following information:
    -  step energy vs. step length (2D histograms)
    -  kinetic energy spectra of some particles, entering
       some active layers.
 (Please look for ***LOOKHERE*** in src/StatAccepTestAnalysis.cc
  to switch on/off these histograms, which can also be steered
  from the main program. By default, the 2D histograms (step
  energy vs. length) are switched off, whereas the others are
  active.)

 If you run twice the same program, or once by linking against
 a given version of Geant4, and another by linking against a
 different version of Geant4, then you have two trees:
     ntuple_a.root  and  ntuple_b.root .
 You can make a statistical tests of the various observables
 contained in the two trees by calling the ROOT macro:
       mainRootScript.C
 (which, in turn, makes use of  extraRootFunctions.C ).
 For a given observable, if the p-value of the statistical test
 is below a certain threshold, currently fixed at 1%, then
 a PostScript file is automatically produced showing the two
 distributions.
 Notice that the fact that the p-value is below the threshold
 does not mean necessarily that the two distributions are 
 statistically incompatible with each other, because, 
 by definition, 1% of the pairs of distributions coming from 
 the same parent distribution have a p-value below 1%.
 However, it is worth to take a look by eye to those distributions
 to see if there are really so different as could be in the
 presence of a bug or by a change in the hadronic models.
 Due to current limitations of ROOT, we are using only the
 Kolmogorov unbinned statistical tests (and not any longer the
 other two tests, Cramer-von Mises and Anderson-Darling, that
 were available with the Statistical Toolkit. 
 The old directory:  dirStat/
 where the Statistical Toolkit where used with AIDA, is not
 needed anymore, but it is left there for reference.)
 Colours convention used in the plots: the first Geant4 version,
 i.e. "REF1" in the main script mainScript.py, is plotted in RED; 
 the second Geant4 version, i.e. "REF2" in mainScript.py, is 
 plotted in BLUE. 

 The program is also printing, at the end, some useful information
 (with statistical errors):
   o  max total energy deposited in the whole calorimeter; 
   o  average energy deposited in all active layers;
   o  average energy deposited in the whole calorimeter;
   o  average energy deposited in each layer (longitudinal profile);
   o  fractions of visible energy deposited in the four quarters;
   o  average energy deposited in each ring (transverse profile);
   o  fractions of visible energy deposited in the three thirds of
      the rings;
   o  energy resolution;
   o  sampling fraction;
   o  average number of steps and tracks per event;
   o  average track length for some particles;
   o  average step length and number of steps for some particles;
   o  information about the kinetic energy of exiting particles.

 Some scripts/macros (shell, Python, and ROOT) are provided to allow
 a full automatization of this Statistical Acceptance suite.
 Here is the structure of these scripts:

    1)  mainScript.py 
         ---> 2)  simuDriver.sh  
                  ---> 3a)  build.py
                  ---> 3b)  execute mainAcceptanceTest
                  ---> 3c)  drivePlot.py
                            ---> 4)  execute  mainRootScript.C

 only the first one, mainScript.py , needs to be modified by the user.
 ( TO-DO: 
   Possible future improvements:
     a)  Use PyROOT instead of ROOT directly;
     b)  Replace the shell scripts with Python scripts;
     c)  Add other statistical tests 
         (like (unbinned) Cramer-von Mises and Anderson-Darling).
 ) 

 After the whole simulation is completed, a post-processing phase
 must be performed in order to produce plots of various observables.
 This phase requires that all the output files of the simulation
 are collected in the same directory tree (eventual with a 
 subdirectory structure), whereas the ROOT files (ntuples) are
 not needed. 
 The subdirectory  dirObservables/  contains a Python script,
 observables.py , and some kumacs that are invoked by the script
 to produce the plots. The user is required simply to set some
 parameters in the  observables.py  script, and then run it.
 Please read the comments at the top of the file  observables.py
 for more information.

 Other scripts have been added in the same subdirectory  
 ( dirObservables/ ) :
   o  unpack.py
   o  createListPlots.py
   o  pvalues.py
   o  compare2.py
   o  compareAll.py
   o  addInfoInTable.py
   o  printInfoLogfile.py
   o  reproducibility.py
   o  reproducibilityAll.py
 The first three are useful immediately after you get the results 
 from the Grid jobs.
 compare2.py is useful to have detailed information  on the 
 difference between two cases.
 compareAll.py is useful to have the detailed information of 
 all cases, and the averages (overall, by calorimeter
 type, by beam particle, and by beam energy).
 addInfoInTable.py, which uses printInfoLogFile.py, is useful
 to summarize the main results in a table. 
 reproducibility.py is useful to test the reproducibility for
 a single case (beam particle, beam energy, calorimeter type).
 reproducibilityAll.py is useful to test the reproducibility
 for several combinations of (beam particle, beam energy,
 calorimeter type): only the Physics List is fixed.
 Please read the comments at the top of these files for more
 information.

 The files that end with  "-m32"  have been added to allow
 to build/run in 32-bit compatibility mode in 64-bit architectures.
 For 32-bit architectures, whether you use these files, or the
 corresponding "normal" ones (i.e. without the  "-m32"  extension),
 nothing will change: you always build/run in 32-bit mode.
 For 64-bit architectures, if you use the corresponding "normal"
 files (i.e. without the  "-m32"  extension), then you build/run
 in native 64-bit mode.


 Other subdirectories :
 
 The subdirectory  dirPower/  is dedicated to the study of the
 statistical power of the Acceptance Suite. You can find more
 information in the README file in that subdirectory.

 The subdirectory  dirUseCases/  contains a set of Geant4 macro
 files to configure the calorimeter as closely as possible to
 the LHC electromagnetic and hadronic calorimeters.

 The subdirectory  dirCPUbench/  is dedicated to some CPU performance
 benchmarks of Geant4 (see the README file in that directory).

 The subdirectory  dirEnergyScan/  is dedicated to the study of
 calorimeter observables (in particular, visible energy and
 energy resolution) as a function of the beam energy, scanning
 the interval 1 - 30 GeV and few extra higher energies
 (usually 50 GeV, 100 GeV, 200 GeV).
 (See the README file in that directory.)

 The subdirectory  dirFluka/  is dedicated to the study of
 the same set of simplified calorimeters used for Geant4
 in the case of Fluka simulation program.

