// This code implementation is the intellectual property of
// the GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: G4QHadron.cc,v 1.2 1999-12-15 14:52:10 gunter Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
// -----------------------------------------------------------------
//      GEANT 4 class implementation file
//
//      For information related to this code contact:
//      CERN, CN Division, ASD group
//      ---------------- G4QHadron ----------------
//             by Mikhail Kossov, Sept 1999.
//      class for Quasmon initiated Hadrons generated by CHIPS Model
// ------------------------------------------------------------------
#include "G4QHadron.hh"

G4QHadron::G4QHadron() :
PDGencoding(0),theDefinition(NULL),theMomentum(0.,0.,0.,0.),valQ(0,0,0,0,0,0)
{};

G4QHadron::G4QHadron(G4int PDGcode) :
PDGencoding(PDGcode),theMomentum(0.,0.,0.,0.)
{
  SetDefinition(G4ParticleTable::GetParticleTable()->FindParticle(PDGencoding));
  G4double theMass  = theDefinition->GetPDGMass();
  theMomentum.setE(theMass);
  //theMomentum.setE(theDefinition->GetPDGMass());
  valQ.SetU (theDefinition->GetQuarkContent(2));
  valQ.SetD (theDefinition->GetQuarkContent(1));
  valQ.SetS (theDefinition->GetQuarkContent(3));
  valQ.SetAU(theDefinition->GetAntiQuarkContent(2));
  valQ.SetAD(theDefinition->GetAntiQuarkContent(1));
  valQ.SetAS(theDefinition->GetAntiQuarkContent(3));
}

G4QHadron::G4QHadron(G4int PDGcode, G4double maxM) :
PDGencoding(PDGcode),theMomentum(0.,0.,0.,0.)
{
#ifdef debug
  cout<<"G4QHadron is called with PDG="<<PDGcode<<", maxM="<<maxM<<G4endl;
#endif
  SetDefinition(G4ParticleTable::GetParticleTable()->FindParticle(PDGcode));
  G4double meanM = theDefinition->GetPDGMass();
  G4double width = theDefinition->GetPDGWidth()/2.;
#ifdef debug
  cout<<"G4QHadron: meanM="<<meanM<<", halfWidth="<<width<<G4endl;
#endif
  if(width<=0.)
  {
	G4cerr<<"***G4QHadron: width="<<width<<" <= 0, PDG="<<PDGcode<<G4endl;
	G4Exception("G4QHadron: width of the Hadron <= 0");
  }
  G4int absPDG = abs(PDGcode);
  G4double minM=0.;
  if      (absPDG==223) minM=135.;   // (omega)=>PI0
  else if (absPDG==113) minM=279.12; // (rho0) =>2*mPI+
  else if (absPDG==333) minM=414.12; // (phi)  =>3PI
  else if (absPDG==213) minM=274.55; // (rho+) =>mPI0+mPI+
  else if (absPDG==313) minM=632.66; // (K0*)  =>K0+PI0
  else if (absPDG==323) minM=628.66; // (K+*)  =>PI0+K+
  else
  {
	G4cerr<<"***G4QHadron: unknown Hadron PDG="<<PDGcode<<G4endl;
	G4Exception("G4QHadron: unknown Hadron");
  }
  //Now calculate the Breit-Wigner distribution with two cuts
  G4double v1=atan((minM-meanM)/width);
  G4double v2=atan((maxM-meanM)/width);
  G4double dv=v2-v1;
#ifdef debug
  cout<<"G4QHadron: minM="<<minM<<", vMin="<<v1<<", vMax="<<v2<<", dv="<<dv<<G4endl;
#endif
  G4double theMass  = meanM+width*tan(v1+dv*G4UniformRand());

  theMomentum.setE(theMass);
  //theMomentum.setE(theDefinition->GetPDGMass());
  valQ.SetU (theDefinition->GetQuarkContent(2));
  valQ.SetD (theDefinition->GetQuarkContent(1));
  valQ.SetS (theDefinition->GetQuarkContent(3));
  valQ.SetAU(theDefinition->GetAntiQuarkContent(2));
  valQ.SetAD(theDefinition->GetAntiQuarkContent(1));
  valQ.SetAS(theDefinition->GetAntiQuarkContent(3));
}

G4QHadron::G4QHadron(const G4QHadron &right)
{
  theMomentum         = right.theMomentum;
  PDGencoding         = right.PDGencoding;
  theDefinition       = right.theDefinition;
  valQ                = right.valQ;
}

const G4QHadron& G4QHadron::operator=(const G4QHadron &right)
{
  theMomentum         = right.theMomentum;
  PDGencoding         = right.PDGencoding;
  theDefinition       = right.theDefinition;
  valQ                = right.valQ;

  return *this;
}

G4double G4QHadron::CalculateMass(G4double maxM, G4int PDG)
{
  G4double theMass = theDefinition->GetPDGMass();
  if (theMass>maxM)
  {
	G4cerr << "***G4QHadron CalculateMass="<<theMass<<" > maxM="<<maxM << G4endl;
	G4Exception("G4QHadron::CalculateMass(): Ask for a Hadron with mass above limit");
  }
  return theMass;
}

void G4QHadron::SetDefinition(G4ParticleDefinition* newDef)
{
  theDefinition=newDef;
  if (theDefinition == NULL)
  {
	G4cerr << "***G4QHadron Encoding = " << PDGencoding << G4endl;
	G4Exception("G4QHadron::GetDefinition(): Encoding not in particle table");
  }
}

G4QHadron::~G4QHadron() {}






