// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file tools.license for terms.

#ifndef tools_wroot_buffer
#define tools_wroot_buffer

// class used for serializing objects.

#include "wbuf"
#include "ibo"

#include "../realloc"
#include "../mnmx"
#ifdef TOOLS_MEM
#include "../mem"
#endif

#include <string>
#include <vector>
#include <ostream>

namespace tools {
namespace wroot {

class buffer {
  inline static const std::string& s_class() {
    static const std::string s_v("tools::wroot::buffer");
    return s_v;
  }
public:
  inline buffer(std::ostream& a_out,
                bool a_byte_swap,
                uint32 a_size) // we expect a not zero value.
  :m_out(a_out)
  ,m_byte_swap(a_byte_swap)
  ,m_size(0)
  ,m_buffer(0)
  ,m_max(0)
  ,m_pos(0)
  ,m_wb(a_out,a_byte_swap,0,m_pos) //it holds a ref on m_pos.
  {
#ifdef TOOLS_MEM
    mem::increment(s_class().c_str());
#endif
    m_size = a_size;
    m_buffer = new char[m_size];
    //if(!m_buffer) {}
    m_max = m_buffer+m_size;
    m_pos = m_buffer;
    m_wb.set_eob(m_max);
  }

  inline virtual ~buffer(){
    delete [] m_buffer;
#ifdef TOOLS_MEM
    mem::decrement(s_class().c_str());
#endif
  }
protected:
  inline buffer(const buffer& a_from)
  :m_out(a_from.m_out)
  ,m_byte_swap(a_from.m_byte_swap)
  ,m_wb(a_from.m_out,a_from.m_byte_swap,0,m_pos)
  {
#ifdef TOOLS_MEM
    mem::increment(s_class().c_str());
#endif
  }
  inline buffer& operator=(const buffer&){return *this;}
public:
  inline std::ostream& out() const {return m_out;}

  //inline void set_offset(unsigned int a_off) {m_pos = m_buffer+a_off;}

  inline char* buf() {return m_buffer;}
  inline const char* buf() const {return m_buffer;}
  inline uint32 length() const {return m_pos-m_buffer;}
  inline uint32 size() const {return m_size;}

  inline char*& pos() {return m_pos;}          //used in basket.
  inline char* max_pos() const {return m_max;} //used in basket.

public:
  template <class T>
  inline bool write(T x){
    if(m_pos+sizeof(T)>m_max) {
      if(!expand(m_size+sizeof(T))) return false;
    }
    return m_wb.write(x);
  }

  inline bool write(bool x){ 
    return write<unsigned char>(x?1:0);
  }

  inline bool write(const std::string& x) {
    uint32 sz = (uint32)(x.size() + sizeof(int) + 1);
    if((m_pos+sz)>m_max) {
      if(!expand(m_size+sz)) return false;
    }
    return m_wb.write(x);
  }

  inline bool write_fast_array(const char* a_a,uint32 a_n) {
    if(!a_n) return true;
    uint32 l = a_n * sizeof(char);
    if((m_pos+l)>m_max) {
      if(!expand(m_size+l)) return false;
    }
    ::memcpy(m_pos,a_a,l);
    m_pos += l;
    return true;
  }

  inline bool write_cstring(const char* a_s) {
    return write_fast_array(a_s,(::strlen(a_s)+1)*sizeof(char));
  }

  template <class T>
  inline bool write_fast_array(const T* a_a,uint32 a_n) {
    if(!a_n) return true;
    uint32 l = a_n * sizeof(T);
    if((m_pos+l)>m_max) {
      if(!expand(m_size+l)) return false;
    }
    return m_wb.write<T>(a_a,a_n);
  }

  template <class T>
  inline bool write_array(const T* a_a,uint32 a_n) {
    if(!write(a_n)) return false;
    return write_fast_array(a_a,a_n);
  }

public:
  inline bool write_version(short a_version){
    if(a_version>kMaxVersion) {
      m_out << "tools::wroot::buffer::write_version :"
            << " version number " << a_version
            << " cannot be larger than " << kMaxVersion << "."
            << std::endl;
      return false;
    }
    return write(a_version);
  }
  inline bool write_version(short a_version,uint32& a_pos){
    // reserve space for leading byte count
    a_pos = (uint32)(m_pos-m_buffer);

    //NOTE : the below test is lacking in CERN-ROOT !
    if((m_pos+sizeof(unsigned int))>m_max) {
      if(!expand(m_size+sizeof(unsigned int))) return false;
    }
    m_pos += sizeof(unsigned int);

    if(a_version>kMaxVersion) {
      m_out << "tools::wroot::buffer::write_version :"
            << " version number " << a_version
            << " cannot be larger than " << kMaxVersion << "."
            << std::endl;
      return false;
    }
    return write(a_version);
  }

  inline bool set_byte_count(uint32 a_pos){
    uint32 cnt = (uint32)(m_pos-m_buffer) - a_pos - sizeof(unsigned int);
    if(cnt>=kMaxMapCount) {
      m_out << "tools::wroot::buffer::set_byte_count :"
            << " bytecount too large (more than "
            << kMaxMapCount << ")."
            << std::endl;
      return false;
    }

    union {
      uint32 cnt;
      short vers[2];
    } v;
    v.cnt = cnt;

    char* opos = m_pos;
    m_pos = (char*)(m_buffer+a_pos);
    if(m_byte_swap) {
      if(!m_wb.write(short(v.vers[1]|kByteCountVMask))) 
        {m_pos = opos;return false;}
      if(!m_wb.write(v.vers[0])) {m_pos = opos;return false;}
    } else {
      if(!m_wb.write(short(v.vers[0]|kByteCountVMask)))
        {m_pos = opos;return false;}
      if(!m_wb.write(v.vers[1])) {m_pos = opos;return false;}
    }
    m_pos = opos;

    return true;
  }

  inline bool write_object(const ibo& a_obj){
    //GB : if adding a write map logic, think to have a displace_mapped()
    //     in basket::write_on_file().

    //const void* ptr = a_obj;
    //unsigned long idx;
    //if ((idx = (unsigned long)
    //          fWriteMap->findValue(hash(&ptr,sizeof(void*)),(long)aObject)
    //          ) != 0) {
    //
    //  // truncation is OK the value we did put in the map is an 30-bit offset
    //  // and not a pointer
    //  unsigned int objIdx = (unsigned int)idx;
    //
    //  unsigned int offset = (unsigned int)(m_pos-m_buffer); //GB
    //
    //  // save index of already stored object
    //  if(!write(objIdx)) return false;
    //    
    //  f_obj_mapped.push_back(std::pair<bufpos,bufpos>(offset,objIdx));

    //} else {

      // reserve space for leading byte count
      uint32 cntpos = (unsigned int)(m_pos-m_buffer);

      //NOTE : the below test is lacking in CERN-ROOT !
      if((m_pos+sizeof(unsigned int))>m_max) {
        if(!expand(m_size+sizeof(unsigned int))) return false;
      }
      m_pos += sizeof(unsigned int);
    
      // write class of object first
      if(!write_class(a_obj.store_cls())) return false;
    
      // add to map before writing rest of object (to handle self reference)
      // (+Rio_kMapOffset so it's != kNullTag)
      //FIXME if(!mapObject(aObject, cntpos + Rio_kMapOffset)) return false;
    
      // let the object write itself :
      if(!a_obj.stream(*this)) return false;
    
      // write byte count
      if(!set_byte_count_obj(cntpos)) return false;
  
    //}
    return true;
  }

 
  inline bool expand(uint32 a_new_size) {
    unsigned long len = m_pos-m_buffer;
    if(!realloc<char>(m_buffer,a_new_size,m_size)) {
      m_out << "tools::wroot::buffer::expand :"
            << " can't realloc " << a_new_size << " bytes."
            << std::endl;
      m_size = 0;
      m_max = 0;
      m_pos = 0;
      m_wb.set_eob(m_max);
      return false;
    }
    m_size = a_new_size;
    m_max = m_buffer + m_size;
    m_pos = m_buffer + len;
    m_wb.set_eob(m_max);
    return true;
  }

protected:
  static const short kMaxVersion = 0x3FFF;
  static const uint32 kMaxMapCount = 0x3FFFFFFE;  
  static const short kByteCountVMask = 0x4000;
  static const uint32 kNewClassTag = 0xFFFFFFFF;

  inline bool write_class(const std::string& a_cls){
    //const void* ptr = &aClass;
    //unsigned long idx;
    //if ((idx = (unsigned long)
    //          fWriteMap->findValue(hash(&ptr,sizeof(void*)),(long)&aClass)
    //          ) != 0) {
    //
    //  // truncation is OK the value we did put in the map is an 30-bit offset
    //  // and not a pointer
    //  unsigned int clIdx = (unsigned int)idx;
    //
    //  unsigned int offset = (unsigned int)(fBufCur-fBuffer); //GB
    //
    //  // save index of already stored class
    //  if(!write((clIdx | Rio_kClassMask))) return false;

    //  f_cls_mapped.push_back(std::pair<bufpos,bufpos>(offset,clIdx));

    //} else {

      //unsigned int offset = (unsigned int)(m_pos-m_buffer);
      if(!write(kNewClassTag)) return false;
      if(!write_cstring(a_cls.c_str())) return false;
      //if(!mapObject(&aClass, offset + Rio_kMapOffset)) return false;

    //}
    return true;
  }

  static const uint32 kByteCountMask = 0x40000000; 

  inline bool set_byte_count_obj(uint32 a_pos){
    uint32 cnt = (uint32)(m_pos-m_buffer) - a_pos - sizeof(unsigned int);
    if(cnt>=kMaxMapCount) {
      m_out << "tools::wroot::buffer::set_byte_count_obj :"
            << " bytecount too large (more than "
            << kMaxMapCount << ")."
            << std::endl;
      return false;
    }
    char* opos = m_pos;
    m_pos = (char*)(m_buffer+a_pos);
    if(!m_wb.write(cnt|kByteCountMask)) {m_pos = opos;return false;}
    m_pos = opos;
    return true;
  }

  inline static std::string sout(const std::string& a_string) {
    return std::string("\"")+a_string+"\"";
  }
protected:
  std::ostream& m_out;
  bool m_byte_swap;
  uint32 m_size;
  char* m_buffer;
  char* m_max;
  char* m_pos;
  wbuf m_wb;
};

}}

#endif
