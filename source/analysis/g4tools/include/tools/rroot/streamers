// Copyright (C) 2010, Guy Barrand. All rights reserved.
// See the file tools.license for terms.

#ifndef tools_rroot_streamers
#define tools_rroot_streamers

#include "named"
#include "date"
#include "directory"
#include "graph"
#include "clss"

#include "../sout"
#include "../vmanip"

//#include "../histo/histo_data"
#include "../histo/profile_data"

#include "../histo/h1d"
#include "../histo/h2d"
//#include "../histo/h3d"
#include "../histo/p1d"
//#include "../histo/p2d"

#include <list>
#include <cmath> //::log10, ::fabs.
#include <cstdlib> //::rand

namespace tools {
namespace rroot {

typedef tools::histo::histo_data<double,unsigned int,double> hd_data;
typedef tools::histo::profile_data<double,unsigned int,double,double> pd_data;

inline bool AttAxis_stream(buffer& a_buffer){
    int fNdivisions = 510;       //Number of divisions(10000*n3 + 100*n2 + n1)
    short fAxisColor = 1;        //color of the line axis
    short fLabelColor = 1;       //color of labels
    short fLabelFont = 62;       //font for labels
    float fLabelOffset = 0.005F; //offset of labels
    float fLabelSize = 0.04F;    //size of labels
    float fTickLength = 0.03F;   //length of tick marks
    float fTitleOffset = 1;      //offset of axis title
    float fTitleSize = 0.04F;    //size of axis title
    short fTitleColor = 1;       //color of axis title
    short fTitleFont = 62;       //font for axis title

    // Version 4 streaming (ROOT/v3-00-6).
    short v;
    unsigned int s, c;
    if(!a_buffer.read_version(v,s,c)) return false;

    if(!a_buffer.read(fNdivisions)) return false;
    if(!a_buffer.read(fAxisColor)) return false;
    if(!a_buffer.read(fLabelColor)) return false;
    if(!a_buffer.read(fLabelFont)) return false;
    if(!a_buffer.read(fLabelOffset)) return false;
    if(!a_buffer.read(fLabelSize)) return false;
    if(!a_buffer.read(fTickLength)) return false;
    if(!a_buffer.read(fTitleOffset)) return false;
    if(!a_buffer.read(fTitleSize)) return false;
    if(!a_buffer.read(fTitleColor)) return false;
    if(!a_buffer.read(fTitleFont)) return false;

    if(!a_buffer.check_byte_count(s, c,"TAttAxis")) return false;
    return true;
}

class dummy_fac : public virtual ifac {
public: //ifac
  virtual iro* create(const std::string& a_class,const args&) {
    if(a_class=="TGraph") { //for TH_read_1D/List.
      return new graph();
    } else {
      m_out << "tools::rroot::dummy_fac::create :"
            << " dummy. Can't create object of class " << sout(a_class) << "."
            << std::endl;
    }
    return 0;
  }
  virtual void destroy(iro*& a_obj) {delete a_obj;a_obj = 0;}
public:
  dummy_fac(std::ostream& a_out):m_out(a_out){}
  virtual ~dummy_fac(){}
protected:
  dummy_fac(const dummy_fac& a_from): ifac(a_from),m_out(a_from.m_out){}
  dummy_fac& operator=(const dummy_fac&){return *this;}
protected:
  std::ostream& m_out;
};

inline bool Axis_stream(buffer& a_buffer,tools::histo::axis<double>& a_fAxis){
    // Version 6 streaming (ROOT/v3-00-6).
    short v;
    unsigned int s, c;
    if(!a_buffer.read_version(v,s,c)) return false;

    std::string name;
    std::string title;  
    if(!Named_stream(a_buffer,name,title)) return false;

    if(!AttAxis_stream(a_buffer)) return false;

    int number;
    if(!a_buffer.read(number)) return false;
    double min;
    if(!a_buffer.read(min)) return false;
    double max;
    if(!a_buffer.read(max)) return false;
    //printf("debug : BatchLab::RioTH::streamTAxis : %d %g %g\n",
    //  number,min,max);

    std::vector<double> edges;
    if(!Array_stream<double>(a_buffer,edges)) return false; //fXbins TArrayD

    int edgen = edges.size();
    if(edgen<=0) {
      a_fAxis.configure(number,min,max);
    } else {
      std::vector<double> vedges;
      for(int index=0;index<edgen;index++) {
        vedges.push_back(edges[index]);
      }
      a_fAxis.configure(vedges);
    }

    int First;
    if(!a_buffer.read(First)) return false;
    int Last;
    if(!a_buffer.read(Last)) return false;

    if(v>=8) { //fBits2.
      unsigned short dummy;
      if(!a_buffer.read(dummy)) return false;
    }

    //Bool_t
    unsigned char TimeDisplay;
    if(!a_buffer.read(TimeDisplay)) return false;

    //TString
    std::string TimeFormat;
    if(!a_buffer.read(TimeFormat)) return false;

    if(v>=7) {
      //THashList*
      dummy_fac fac(a_buffer.out());
      if(!dummy_TXxx_pointer_stream(a_buffer,fac)) return false;
    }

    if(!a_buffer.check_byte_count(s,c,"TAxis")) return false;
    return true;
}

inline bool null_epsil(double a_1,double a_2,double a_prec = -5) {
  return (::log10(::fabs(a_1-a_2))<a_prec?true:false);
}

inline bool TH_read_1D(buffer& a_buffer,hd_data& a_data,
                       double& a_fEntries,double& a_fSw){
    a_fEntries = 0;
    a_fSw = 0;

    unsigned int s, c;
    short vers;
    if(!a_buffer.read_version(vers,s,c)) return false;

    //printf("debug : BatchLab::Rio::TH::streamTH1 : version %d\n",vers);

    // Version 3 streaming (ROOT/v3-00-6).

    std::string name;
    std::string title;  
    if(!Named_stream(a_buffer,name,title)) return false;

    a_data.m_title = title;

   {short color,style,width;
    if(!AttLine_stream(a_buffer,color,style,width)) return false;}
   {short color,style;
    if(!AttFill_stream(a_buffer,color,style)) return false;}
    if(!AttMarker_stream(a_buffer)) return false;

    int Ncells;
    if(!a_buffer.read(Ncells)) return false;

    //fXAxis
    if(!Axis_stream(a_buffer,a_data.m_axes[0])) return false;
    a_data.m_axes[0].m_offset = 1;

    if(a_data.m_dimension==2) {
      if(!Axis_stream(a_buffer,a_data.m_axes[1])) return false; //fYAxis
      a_data.m_axes[1].m_offset = 
        a_data.m_axes[0].m_offset * (a_data.m_axes[0].bins()+2);

      tools::histo::axis<double> dummy;
      if(!Axis_stream(a_buffer,dummy)) return false; //fZAxis
    } else {
      tools::histo::axis<double> dummy;
      if(!Axis_stream(a_buffer,dummy)) return false; //fYAxis
      if(!Axis_stream(a_buffer,dummy)) return false; //fZAxis
    }

    short barOffset;
    if(!a_buffer.read(barOffset)) return false;

    short barWidth;
    if(!a_buffer.read(barWidth)) return false;

    if(!a_buffer.read(a_fEntries)) return false;

    if(!a_buffer.read(a_fSw)) return false; //fTsumw
    //printf("debug : BatchLab::Rio::TH::streamTH1 : \"%s\" %g %g\n",
      //a_data.m_title.c_str(),fEntries,fSw);

    double sw2;
    if(!a_buffer.read(sw2)) return false;

    double xSxw;
    if(!a_buffer.read(xSxw)) return false;

    double xSx2w;
    if(!a_buffer.read(xSx2w)) return false;

    double max;
    if(!a_buffer.read(max)) return false;

    double min;
    if(!a_buffer.read(min)) return false;

    double NormFactor;
    if(!a_buffer.read(NormFactor)) return false;

   {std::vector<double> v;
    if(!Array_stream<double>(a_buffer,v)) return false;} //fContour TArrayD

    std::vector<double> sumw2; //fSumw2 TArrayD
    if(!Array_stream<double>(a_buffer,sumw2)) return false;
    
   {std::string opt;
    if(!a_buffer.read(opt)) return false; //TString fOption
    //look if it is an "annotation trick" :
    //if(opt.size()&&(opt[0]==0)) {
    //  fAnnotation = opt.substr(1,opt.size()-1);
    //}
    }

   {dummy_fac fac(a_buffer.out());
    List dummy(fac,true);
    if(!dummy.stream(a_buffer)) {
      a_buffer.out() << "tools::rroot::TH_read_1D :"
                     << " List stream failed."
                     << std::endl;
      return false;
    }} //Functions

    if(vers>=4) {
      int BufferSize;
      if(!a_buffer.read(BufferSize)) return false;
      
      //Double_t* Buffer; //[fBufferSize]
      if(!dummy_array_stream<double>(a_buffer,BufferSize)) return false;
    }

    // Add two for outflows.
    if(a_data.m_dimension==1) {
      a_data.m_bin_number = a_data.m_axes[0].m_number_of_bins + 2;
    } else if(a_data.m_dimension==2) {
      a_data.m_bin_number = 
        (a_data.m_axes[0].m_number_of_bins + 2) * 
	(a_data.m_axes[1].m_number_of_bins + 2);
    }

    unsigned int binn = a_data.m_bin_number;
    a_data.m_bin_Sw2.resize(binn,0);
    if(binn==sumw2.size()) {
      for(unsigned int index=0;index<binn;index++){
        a_data.m_bin_Sw2[index] = sumw2[index];
      }
    }

    if(!a_buffer.check_byte_count(s,c,"TH")) return false;

    return true;
}


inline bool TH_read_2D(buffer& a_buffer,hd_data& a_data,
                       double& a_fEntries,double& a_fSw){
    unsigned int s, c;
    short v;
    if(!a_buffer.read_version(v,s,c)) return false;

    //printf("debug : BatchLab::Rio::TH::streamTH2 : version %d\n",v);
 
    // Version 3 streaming (ROOT/v3-00-6).

    if(!TH_read_1D(a_buffer,a_data,a_fEntries,a_fSw)) return false;

    double ScaleFactor;
    if(!a_buffer.read(ScaleFactor)) return false;
    double Tsumwy;
    if(!a_buffer.read(Tsumwy)) return false;
    double Tsumwy2;
    if(!a_buffer.read(Tsumwy2)) return false;
    double Tsumwxy;
    if(!a_buffer.read(Tsumwxy)) return false;
  
    if(!a_buffer.check_byte_count(s,c,"TH2")) return false;
  
    return true;
}

inline tools::histo::h1d* TH1F_stream(buffer& a_buffer,bool a_profile = false){
    unsigned int s, c;
    short v;
    if(!a_buffer.read_version(v,s,c)) return 0;

    //printf("debug : BatchLab::Rio::TH1F::stream : version %d\n",v);

    // Version 1 streaming (ROOT/v3-00-6).

    // Now we have to reconstruct a valid Histogram from a_buffer :
    hd_data data;

    data.m_dimension = 1;
    //data.m_coords.resize(data.m_dimension,0);
    //data.m_ints.resize(data.m_dimension,0);
    data.m_axes.resize(1);

    double fEntries;
    double fSw;
    if(!TH_read_1D(a_buffer,data,fEntries,fSw)) return 0;

    std::vector<float> bins; //fArray TArrayF
    if(!Array_stream<float>(a_buffer,bins)) return 0; 

    unsigned int binn = data.m_bin_number;
    //printf("debug : BatchLab::Rio::TH1F::stream : histo bins %d\n",binn);
    data.m_bin_Sw.resize(binn,0);
    double asw = 0;
   {for(unsigned int index=0;index<binn;index++){
      double h = double(bins[index]);
      data.m_bin_Sw[index] = h;
      asw += h;
     }}
    if(!a_profile) {
      double sw = data.get_Sw();
      if(!null_epsil(sw,fSw)) {
        a_buffer.out() << "tools::rroot::TH1F::stream : "
            << " WARNING : inconsistent total weight" 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fSw is " << fSw  
            << " whilst sum of in-range bins weight is " << sw
            << " (diff is " << (sw-fSw) << ")."
            << std::endl;
      }
    }

    // Fill Sxw and Sx2w by using in range bins :
    std::vector<double> empty;
    empty.resize(1,0);
    data.m_bin_Sxw.resize(binn,empty);
    data.m_bin_Sx2w.resize(binn,empty);    
    std::vector<int> is(data.m_dimension);
   {for(unsigned int index=0;index<binn;index++){
      if(!data.is_out(index)) {
        float height = bins[index];
        data.get_indices(index,is);
        for(unsigned int iaxis=0;iaxis<data.m_dimension;iaxis++) {
          double x = data.m_axes[iaxis].bin_center(is[iaxis]); 
          data.m_bin_Sxw[index][iaxis] = x * height;
          data.m_bin_Sx2w[index][iaxis] = x * x * height;
        }
      }
    }}

    //ROOT does not store the number of entries per bin.
    // We have the global number of entries and weight ; with that
    // we do our best....
    data.m_bin_entries.resize(binn,0);
    if(!a_profile && asw) {
      for(unsigned int index=0;index<binn;index++){
        float height = bins[index];
        int number = (int)((fEntries * height) / asw);
        if(number<0) {
        } else {
          data.m_bin_entries[index] = number;
        }
      }
      int allEntries = data.get_all_entries();
      if(allEntries<int(fEntries)) { //FIXME
        //Correct some bins randomly (beurk, do you have a better idea ?) :
        int diff = int(fEntries)-allEntries;
        unsigned int nx = data.m_axes[0].m_number_of_bins;
        for(int i=0;i<diff;i++) {
          int ri = ::rand();
          // ibin in [1,nx-1]
          int ibin =  int((nx-1) * ((double)ri/(double)RAND_MAX)) + 1;
          int offset = ibin;
          data.m_bin_entries[offset]++;
        }
      } else if(allEntries>int(fEntries)) { //FIXME
        a_buffer.out() << "tools::rroot::TH1F::stream : "
            << " WARNING : can't reemulate number of entries per bin " 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fEntries (a double) is " << fEntries  
            << " whilst corrected bin entries is " << allEntries
            << " (diff is " << (allEntries-int(fEntries)) << ")."
            << std::endl;
      } else {
      }
    }

    if(!a_buffer.check_byte_count(s,c,"TH1F")) return 0;

    tools::histo::h1d* h = new tools::histo::h1d("",10,0,1);
    h->copy_from_data(data);
    h->update_fast_getters();
    // We have now a valid HCL histogram.
    return h; //give ownership to caller.
}

inline tools::histo::h1d* TH1D_stream(buffer& a_buffer,bool a_profile = false){
    unsigned int s, c;
    short v;
    if(!a_buffer.read_version(v,s,c)) return 0;

    //printf("debug : BatchLab::Rio::TH1D::stream : version %d\n",v);

    // Version 1 streaming (ROOT/v3-00-6).

    // Now we have to reconstruct a valid Histogram from a_buffer :
    hd_data data;

    data.m_dimension = 1;
    //data.m_coords.resize(data.m_dimension,0);
    //data.m_ints.resize(data.m_dimension,0);
    data.m_axes.resize(1);

    double fEntries;
    double fSw;
    if(!TH_read_1D(a_buffer,data,fEntries,fSw)) return 0;

    std::vector<double> bins; //fArray TArrayD
    if(!Array_stream<double>(a_buffer,bins)) return 0; 

    unsigned int binn = data.m_bin_number;
    //printf("debug : BatchLab::Rio::TH1D::stream : histo bins %d\n",binn);
    data.m_bin_Sw.resize(binn,0);
    double asw = 0;
   {for(unsigned int index=0;index<binn;index++){
      double h = bins[index];
      data.m_bin_Sw[index] = h;
      asw += h;
    }}
    if(!a_profile) {
      double sw = data.get_Sw();
      if(!null_epsil(sw,fSw)) {
        a_buffer.out() << "tools::rroot::TH1D::stream : "
            << " WARNING : inconsistent total weight" 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fSw is " << fSw  
            << " whilst sum of in-range bins weight is " << sw
            << " (diff is " << (sw-fSw) << ")."
            << std::endl;
      }
    }

    // Fill Sxw and Sx2w by using in range bins :
    std::vector<double> empty;
    empty.resize(1,0);
    data.m_bin_Sxw.resize(binn,empty);
    data.m_bin_Sx2w.resize(binn,empty);
    std::vector<int> is(data.m_dimension);
    for(unsigned int index=0;index<binn;index++){
      if(!data.is_out(index)) {
        double height = bins[index];
        data.get_indices(index,is);
        for(unsigned int iaxis=0;iaxis<data.m_dimension;iaxis++) {
          double x = data.m_axes[iaxis].bin_center(is[iaxis]); 
          data.m_bin_Sxw[index][iaxis] = x * height;
          data.m_bin_Sx2w[index][iaxis] = x * x * height;
        }
      }
    }

    //ROOT does not store the number of entries per bin.
    // We have the global number of entries and weight ; with that
    // we do our best....
    data.m_bin_entries.resize(binn,0);
    if(!a_profile && asw) {
      for(unsigned int index=0;index<binn;index++){
        double height = bins[index];
        int number = (int)((fEntries * height) / asw);        
        if(number<0) {
        } else {
          data.m_bin_entries[index] = number;
        }
      }
      int allEntries = data.get_all_entries();
      if(allEntries<int(fEntries)) { //FIXME
        //Correct some bins randomly (beurk, do you have a better idea ?) :
        int diff = int(fEntries)-allEntries;
        unsigned int nx = data.m_axes[0].m_number_of_bins;
        for(int i=0;i<diff;i++) {
          int ri = ::rand();
          int ibin =  int((nx-1) * ((double)ri/(double)RAND_MAX)) + 1;
          int offset = ibin;
          data.m_bin_entries[offset]++;
        }
      } else if(allEntries>int(fEntries)) { //FIXME
        a_buffer.out() << "tools::rroot::TH1D::stream : "
            << " WARNING : can't reemulate number of entries per bin " 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fEntries (a double) is " << fEntries  
            << " whilst corrected bin entries is " << allEntries
            << " (diff is " << (allEntries-int(fEntries)) << ")."
            << std::endl;
      } else {
      }
    }

    if(!a_buffer.check_byte_count(s,c,"TH1D")) return 0;

    tools::histo::h1d* h = new tools::histo::h1d("",10,0,1);
    h->copy_from_data(data);
    h->update_fast_getters();
    // We have now a valid HCL histogram.

    return h;
}

inline tools::histo::h2d* TH2F_stream(buffer& a_buffer,bool a_profile = false){
    unsigned int s, c;
    short v;
    if(!a_buffer.read_version(v,s,c)) return 0;

    //printf("debug : BatchLab::Rio::TH2F::stream : version %d\n",v);

    // Version 3 streaming (ROOT/v3-00-6).

    // Now we have to reconstruct a valid Histogram from a_buffer :
    hd_data data;

    data.m_dimension = 2;
    //data.m_coords.resize(data.m_dimension,0);
    //data.m_ints.resize(data.m_dimension,0);
    data.m_axes.resize(2);

    double fEntries;
    double fSw;
    if(!TH_read_2D(a_buffer,data,fEntries,fSw)) return 0;

    std::vector<float> bins; //fArray TArrayF
    if(!Array_stream<float>(a_buffer,bins)) return 0; 

    //printf("debug : BatchLab::Rio::TH2F::stream : histo bins %d\n",n);
    unsigned int binn = data.m_bin_number;
    data.m_bin_Sw.resize(binn,0);
    double asw = 0;
   {for(unsigned int index=0;index<binn;index++){
      double h = double(bins[index]);
      data.m_bin_Sw[index] = h;
      asw += h;
    }}
    if(!a_profile) {
      double sw = data.get_Sw();
      if(!null_epsil(sw,fSw)) {
        a_buffer.out() << "tools::rroot::TH2F::stream : "
            << " WARNING : inconsistent total weight" 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fSw is " << fSw  
            << " whilst sum of in-range bins weight is " << sw
            << " (diff is " << (sw-fSw) << ")."
            << std::endl;
      }
    }

    // Fill Sxw and Sx2w by using in range bins :
    std::vector<double> empty;
    empty.resize(2,0);
    data.m_bin_Sxw.resize(binn,empty);
    data.m_bin_Sx2w.resize(binn,empty);
    std::vector<int> is(data.m_dimension);
    for(unsigned int index=0;index<binn;index++){
      if(!data.is_out(index)) {
        float height = bins[index];
        data.get_indices(index,is);
        for(unsigned int iaxis=0;iaxis<data.m_dimension;iaxis++) {
          double x = data.m_axes[iaxis].bin_center(is[iaxis]); 
          data.m_bin_Sxw[index][iaxis] = x * height;
          data.m_bin_Sx2w[index][iaxis] = x * x * height;
        }
      }
    }

    //ROOT does not store the number of entries per bin.
    // We have the global number of entries and weight ; with that
    // we do our best....
    data.m_bin_entries.resize(binn,0);
    if(!a_profile && asw) {
      for(unsigned int index=0;index<binn;index++){
        float height = bins[index];
        int number = (int)((fEntries * height) / asw);
        if(number<0) {
        } else {
          data.m_bin_entries[index] = number;
        } 
      }
      int allEntries = data.get_all_entries();
      if(allEntries<(int)fEntries) { //FIXME
        //Correct some bins randomly (beurk, do you have a better idea ?) :
        int diff = int(fEntries-allEntries);
        unsigned int nx = data.m_axes[0].m_number_of_bins;
        unsigned int ny = data.m_axes[1].m_number_of_bins;
        for(int i=0;i<diff;i++) {
          int ri = ::rand();
          int ibin =  int((nx-1) * ((double)ri/(double)RAND_MAX)) + 1;
          int rj = ::rand();
          int jbin =  int((ny-1) * ((double)rj/(double)RAND_MAX)) + 1;
          int offset = ibin + jbin * data.m_axes[1].m_offset;
          data.m_bin_entries[offset]++;
        }
      } else if(allEntries>int(fEntries)) { //FIXME
        a_buffer.out() << "tools::rroot::TH2F::stream : "
            << " WARNING : can't reemulate number of entries per bin " 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fEntries (a double) is " << fEntries  
            << " whilst corrected bin entries is " << allEntries
            << " (diff is " << (allEntries-int(fEntries)) << ")."
            << std::endl;
      } else {
      }
    }
    
    if(!a_buffer.check_byte_count(s,c,"TH2F")) return 0;

    tools::histo::h2d* h = new tools::histo::h2d("",10,0,1,10,0,1);
    h->copy_from_data(data);
    h->update_fast_getters();
    // We have now a valid HCL histogram.

    return h;
}

inline tools::histo::h2d* TH2D_stream(buffer& a_buffer,bool a_profile = false){
    unsigned int s, c;
    short v;
    if(!a_buffer.read_version(v,s,c)) return 0;

    //printf("debug : BatchLab::Rio::TH2D::stream : version %d\n",v);

    // Version 3 streaming (ROOT/v3-00-6).

    // Now we have to reconstruct a valid Histogram from a_buffer :
    hd_data data;

    data.m_dimension = 2;
    //data.m_coords.resize(data.m_dimension,0);
    //data.m_ints.resize(data.m_dimension,0);
    data.m_axes.resize(2);

    double fEntries;
    double fSw;
    if(!TH_read_2D(a_buffer,data,fEntries,fSw)) return 0;

    std::vector<double> bins; //fArray TArrayD
    if(!Array_stream<double>(a_buffer,bins)) return 0; 

    //printf("debug : BatchLab::Rio::TH2D::stream : histo bins %d\n",n);
    unsigned int binn = data.m_bin_number;
    data.m_bin_Sw.resize(binn,0);
    double asw = 0;
   {for(unsigned int index=0;index<binn;index++){
      double h = bins[index];
      data.m_bin_Sw[index] = h;
      asw += h;
     }}
    if(!a_profile) {
      double sw = data.get_Sw();
      if(!null_epsil(sw,fSw)) {
        a_buffer.out() << "tools::rroot::TH2D::stream : "
            << " WARNING : inconsistent total weight" 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fSw is " << fSw  
            << " whilst sum of in-range bins weight is " << sw
            << " (diff is " << (sw-fSw) << ")."
            << std::endl;
      }
    }

    // Fill Sxw and Sx2w by using in range bins :
    std::vector<double> empty;
    empty.resize(2,0);
    data.m_bin_Sxw.resize(binn,empty);
    data.m_bin_Sx2w.resize(binn,empty);
    std::vector<int> is(data.m_dimension);
    for(unsigned int index=0;index<binn;index++){
      if(!data.is_out(index)) {
        double height = bins[index];
        data.get_indices(index,is);
        for(unsigned int iaxis=0;iaxis<data.m_dimension;iaxis++) {
          double x = data.m_axes[iaxis].bin_center(is[iaxis]); 
          data.m_bin_Sxw[index][iaxis] = x * height;
          data.m_bin_Sx2w[index][iaxis] = x * x * height;
        }
      }
    }

    //ROOT does not store the number of entries per bin.
    // We have the global number of entries and weight ; with that
    // we do our best....
    data.m_bin_entries.resize(binn,0);
    if(!a_profile && asw) {
      for(unsigned int index=0;index<binn;index++){
        double height = bins[index];
        int number = (int)((fEntries * height) / asw);
        if(number<0) {
        } else {
          data.m_bin_entries[index] = number;
        } 
      }
      int allEntries = data.get_all_entries();
      if(allEntries<(int)fEntries) { //FIXME
        //Correct some bins randomly (beurk, do you have a better idea ?) :
        int diff = int(fEntries-allEntries);
        unsigned int nx = data.m_axes[0].m_number_of_bins;
        unsigned int ny = data.m_axes[1].m_number_of_bins;
        for(int i=0;i<diff;i++) {
          int ri = ::rand();
          int ibin =  int((nx-1) * ((double)ri/(double)RAND_MAX)) + 1;
          int rj = ::rand();
          int jbin =  int((ny-1) * ((double)rj/(double)RAND_MAX)) + 1;
          int offset = ibin + jbin * data.m_axes[1].m_offset;
          data.m_bin_entries[offset]++;
        }
      } else if(allEntries>int(fEntries)) { //FIXME
        a_buffer.out() << "tools::rroot::TH2D::stream : "
            << " WARNING : can't reemulate number of entries per bin " 
            << " for histo with title " << sout(data.m_title) << " :"
            << std::endl
            << " read fEntries (a double) is " << fEntries  
            << " whilst corrected bin entries is " << allEntries
            << " (diff is " << (allEntries-int(fEntries)) << ")."
            << std::endl;
      } else {
      }
    }
    
    if(!a_buffer.check_byte_count(s,c,"TH2D")) return 0;

    tools::histo::h2d* h = new tools::histo::h2d("",10,0,1,10,0,1);
    h->copy_from_data(data);
    h->update_fast_getters();
    // We have now a valid HCL histogram.

    return h;
}

inline tools::histo::p1d* TProfile_stream(buffer& a_buffer){
    unsigned int s, c;
    short v;
    if(!a_buffer.read_version(v,s,c)) return 0;

    // Version 3 streaming (ROOT/v3-00-6).

    //WARNING : the mapping tools::histo::p1d / TProfile is not obvious.
    //HCL::m_bin_Svw  <---> TProfile::fArray
    //HCL::m_bin_Sv2w <---> TProfile::fSumw2
    //HCL::m_bin_Sw   <---> TProfile::fBinEntries


    tools::histo::h1d* h = TH1D_stream(a_buffer,true);
    if(!h) return 0;

    //NOTE : histo.m_bin_Sw <---> TH1D::TArrayD::fArray

    //WARNING : should have a valid Rio::TH1D::fHistogram
    //          being a tools::histo::h1d.
    //          But the tools::histo::p1d does not inherit tools::histo::h1d.

    pd_data data(h->get_histo_data());
    delete h;

    std::vector<double> bins; //fBinEntries TArrayD
    if(!Array_stream<double>(a_buffer,bins)) return 0; 
    int errorMode;
    if(!a_buffer.read(errorMode)) return 0;
    double ymin;
    if(!a_buffer.read(ymin)) return 0;
    double ymax;
    if(!a_buffer.read(ymax)) return 0;

    if(v>=4) {
      double  sumwy;
      if(!a_buffer.read(sumwy)) return 0;
      double   sumwy2;
      if(!a_buffer.read(sumwy2)) return 0;
      std::vector<double> bins_sumw2; //fBinSumw2 TArrayD
      if(!Array_stream<double>(a_buffer,bins_sumw2)) return 0;
    }

    data.m_is_profile = true;
    data.m_cut_v = true;
    data.m_min_v = ymin;
    data.m_max_v = ymax;

    unsigned int binn = data.m_bin_number;
    data.m_bin_Svw.resize(binn,0);
    data.m_bin_Sv2w.resize(binn,0);

    for(unsigned int index=0;index<binn;index++){
      double svw = data.m_bin_Sw[index];
      double sw = bins[index];
      data.m_bin_entries[index] = (int)sw; //FIXME : ok for w = 1 only !
      data.m_bin_Sw[index] = (double)sw;
      //FIXME : data.m_bin_Sxw
      //FIXME : data.m_bin_Sx2w
      data.m_bin_Svw[index] = svw;
      data.m_bin_Sv2w[index] = 0; //FIXME
    }

    if(!a_buffer.check_byte_count(s,c,"TProfile")) return 0;

    tools::histo::p1d* p = new tools::histo::p1d("",10,0,1);
    p->copy_from_data(data);
    p->update_fast_getters();
    // We have now a valid tools::histo::p1d.
    return p;
}

class TDirectory : public tools::rroot::directory {
//public:
//  static const std::string& store_class() {return TDirectory_cls();}
public:
  TDirectory(ifile& a_file)
  :tools::rroot::directory(a_file)
  {}
  virtual ~TDirectory(){}
protected:
  TDirectory(const TDirectory& a_from)
  : tools::rroot::directory(a_from)
  {}
  TDirectory& operator=(const TDirectory&){return *this;}
public:
  bool stream(buffer& a_buffer){
    initialize();
    short version;
    if(!a_buffer.read_version(version)) return false;
    unsigned int _date;
    if(!a_buffer.read(_date)) return false;
    //m_date_C.setDate(_date);
    if(!a_buffer.read(_date)) return false;
    //m_date_M.setDate(_date);
    if(!a_buffer.read(m_nbytes_keys)) return false;
    if(!a_buffer.read(m_nbytes_name)) return false;
    if(version>1000) {
      if(!a_buffer.read(m_seek_directory)) return false;
      if(!a_buffer.read(m_seek_parent)) return false;
      if(!a_buffer.read(m_seek_keys)) return false;
    } else {
     {seek32 i;
      if(!a_buffer.read(i)) return false;
      m_seek_directory = i;}

     {seek32 i;
      if(!a_buffer.read(i)) return false;
      m_seek_parent = i;}

     {seek32 i;
      if(!a_buffer.read(i)) return false;
      m_seek_keys = i;}
    }
    //short v = version%1000;

    if (m_seek_keys) {
      uint32 n;
      if(!read_keys(n)) {
        a_buffer.out() << "tools::rroot::TDirectory::stream :"
                       << " cannot read keys."
                       << std::endl;
        return false;
      }
    }

    return true;
  }
protected:
  void initialize(){
    // Initialise directory to defaults :
    // If directory is created via default ctor (when dir is read from file)
    // don't add it here to the directory since its name is not yet known.
    // It will be added to the directory in TKey::ReadObj().
    m_date_C = 0;//m_date_C.set();
    m_date_M = 0;//m_date_M.set();
    m_nbytes_keys = 0;
    m_seek_directory = 0;
    m_seek_parent = 0;
    m_seek_keys = 0;
  }
};


inline void dump(std::ostream& a_out,
                 tools::rroot::ifile& a_file,
                 const std::vector<tools::rroot::key*>& a_keys,
                 bool a_recursive,
                 unsigned int a_spaces = 0) {

  // dump non directory objects :
 {std::vector<tools::rroot::key*>::const_iterator it;
  for(it=a_keys.begin();it!=a_keys.end();++it) {
    tools::rroot::key& k = *(*it);
    if(k.object_class()==tools::rroot::TDirectory_cls()) continue;
   {for(unsigned int index=0;index<a_spaces;index++) a_out << " ";}
    k.dump(a_out);
  }}

  // dump directories :
 {std::vector<tools::rroot::key*>::const_iterator it;
  for(it=a_keys.begin();it!=a_keys.end();++it) {
    tools::rroot::key& k = *(*it);
    if(k.object_class()!=tools::rroot::TDirectory_cls()) continue;

    std::string label = k.object_name();
   {for(unsigned int index=0;index<a_spaces;index++) a_out << " ";}
    a_out << "directory : " << label << std::endl;

    if(!a_recursive) continue;

    uint32 sz;    
    char* buf = k.get_object_buffer(sz); 
    //we don't have ownership of buf.
    if(!buf) {
      a_out  << "tools::rroot::dump :"
             << " can't get directory data buffer."
             << std::endl;
    } else {
      tools::rroot::buffer b(a_out,a_file.byte_swap(),
                             sz,buf,k.key_length(),false);
      tools::rroot::TDirectory tdir(a_file);
      if(!tdir.stream(b)) {
        a_out  << "tools::rroot::dump :"
              << " can't stream TDirectory."
              << std::endl;
      } else {
        const std::vector<tools::rroot::key*>& keys = tdir.keys();
        dump(a_out,a_file,keys,a_recursive,a_spaces+1);
      }
    }
  }}
}

}}

#endif
