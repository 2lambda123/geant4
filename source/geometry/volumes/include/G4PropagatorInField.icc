//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * The following disclaimer summarizes all the specific disclaimers *
// * of contributors to this software. The specific disclaimers,which *
// * govern, are listed with their locations in:                      *
// *   http://cern.ch/geant4/license                                  *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * This  code  implementation is the  intellectual property  of the *
// * GEANT4 collaboration.                                            *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//
// $Id: G4PropagatorInField.icc,v 1.21 2001-10-22 14:49:01 japost Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
// 
// ------------------------------------------------------------------------
//	GEANT 4  include file implementation
//
// ------------------------------------------------------------------------
// 
// 25.10.96 John Apostolakis, design and implementation 
// 25.03.97 John Apostolakis, adaptation for G4Transportation and cleanup
//
//  To create an object, must have 
//      an object that calculates the Curved paths 
//      the navigator to find (linear) intersections
//     and ?? also must know the value of the maximum displacement allowed
//

inline
G4PropagatorInField::G4PropagatorInField(G4Navigator    *theNavigator, 
		                         G4FieldManager *detectorFieldMgr)
  : fDetectorFieldMgr(detectorFieldMgr), 
    fCurrentFieldMgr(detectorFieldMgr), 
    fNavigator(theNavigator),
    End_PointAndTangent(G4ThreeVector(0.,0.,0.),
			G4ThreeVector(0.,0.,0.),0.0,0.0,0.0,0.0,0.0),
    fVerboseLevel(0),
    fmax_loop_count(10000),
    fEpsilonMin(fEpsilonMinDefault),
    fEpsilonMax(fEpsilonMaxDefault)
{
     // this->fChordFinder = new G4ChordFinder( (G4MagneticField*)0, 1e-6 );

     fNoZeroStep=0;                
     fThresholdNo_ZeroSteps= 2; 
     // fMidPoint_CurveLen_of_LastAttempt= -1;
     fFull_CurveLen_of_LastAttempt= -1; 
     fLast_ProposedStepLength= -1; 
}

inline
G4ChordFinder* G4PropagatorInField::GetChordFinder()
{
      // Now only the "Chord Finder" of the global Field Mgr is used
      //  ... 
      return fCurrentFieldMgr->GetChordFinder(); 
}

inline
void G4PropagatorInField::SetChargeMomentumMass( 
			G4double Charge,            // in e+ units
		        G4double Momentum,          // in GeV/c 
		        G4double Mass)              // in ? units
{
   GetChordFinder()->SetChargeMomentumMass(Charge, Momentum, Mass); 
}

//  Obtain the final space-point and velocity (normal) at the end of the Step
//
inline
G4ThreeVector  G4PropagatorInField::EndPosition() const
{
      return   End_PointAndTangent.GetPosition(); 
}

inline
G4ThreeVector  G4PropagatorInField::EndMomentumDir() const
{
      return   End_PointAndTangent.GetMomentumDir(); 
}

inline
G4double G4PropagatorInField::GetEpsilonStep() const
{ 
      return fEpsilonStep; 
}

inline
void     G4PropagatorInField::SetEpsilonStep(G4double newEps)
{
      fEpsilonStep=newEps;
}

inline
G4bool   G4PropagatorInField::IsParticleLooping() const
{
      return fParticleIsLooping;
}

inline
G4int    G4PropagatorInField::GetMaxLoopCount() const
{
      return fmax_loop_count;
}

inline
void     G4PropagatorInField::SetMaxLoopCount(G4int new_max) 
{
      fmax_loop_count= new_max;
}

inline
G4double G4PropagatorInField::GetDeltaIntersection() const
{
      return fCurrentFieldMgr->GetDeltaIntersection();
} 

inline
G4double G4PropagatorInField::GetDeltaOneStep() const
{
      return fCurrentFieldMgr->GetDeltaOneStep();
}

inline
void
G4PropagatorInField::SetAccuraciesWithDeltaOneStep(G4double valDeltaOneStep)
{ 
   fDetectorFieldMgr->SetAccuraciesWithDeltaOneStep(valDeltaOneStep);
   //  this->SetDeltaOneStep(valDeltaOneStep);
   // this->SetDeltaIntersection( 0.4 * fDelta_One_Step_Value);
}

inline
void G4PropagatorInField::SetDeltaOneStep(G4double valDeltaOneStep)
{ 
   fDetectorFieldMgr->SetDeltaOneStep( valDeltaOneStep); 
   // fCurrentFieldMgr->SetDeltaOneStep( valDeltaOneStep);  
}

inline
void G4PropagatorInField::SetDeltaIntersection(G4double valDeltaIntersection)
{
  fDetectorFieldMgr->SetDeltaIntersection(valDeltaIntersection);
   // fCurrentFieldMgr->SetDeltaOneStep( valDeltaOneStep); 
}

inline
G4int G4PropagatorInField::SetVerboseLevel( G4int Verbose )
{
  return fVerboseLevel=Verbose;
}

inline
G4int G4PropagatorInField::Verbose() const
{
  return fVerboseLevel;
}

inline
G4FieldTrack G4PropagatorInField::GetEndState() const
{
  return End_PointAndTangent;
}

// Minimum for Relative accuracy of any Step 
inline 
G4double  G4PropagatorInField::GetMinimumEpsilonStep() const
{
  return fEpsilonMin; 
}

inline 
void      G4PropagatorInField::SetMinimumEpsilonStep(G4double newEpsMin)
{
  if( (newEpsMin > 0.0) && (fabs(1.0+newEpsMin)>1.0) )
    fEpsilonMin= newEpsMin;
}
