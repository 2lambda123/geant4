// This code implementation is the intellectual property of
// the RD44 GEANT4 collaboration.
//
// By copying, distributing or modifying the Program (or any work
// based on the Program) you indicate your acceptance of this statement,
// and all its terms.
//
// $Id: SdaiCONFIG_CONTROL_DESIGN.cc,v 1.1 1999-01-07 16:08:15 gunter Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
#ifndef  SDAICONFIG_CONTROL_DESIGN_CC
#define  SDAICONFIG_CONTROL_DESIGN_CC
// This file was generated by fedex_plus.  You probably don't want to edit
// it since your modifications will be lost if fedex_plus is used to
// regenerate it.
/*   */ 
#ifndef  SCHEMA_H 
#include <schema.h> 
#endif 

#undef NULL
#define NULL 0
/*	**************  TYPES  	*/
SelectTypeDescriptor 	*config_control_designt_characterized_definition;
TypeDescriptor 	*config_control_designt_parameter_value;
TypeDescriptor 	*config_control_designt_plane_angle_measure;
SelectTypeDescriptor 	*config_control_designt_change_request_item;
TypeDescriptor 	*config_control_designt_text;
TypeDescriptor 	*config_control_designt_year_number;
SelectTypeDescriptor 	*config_control_designt_characterized_product_definition;
SelectTypeDescriptor 	*config_control_designt_reversible_topology_item;
SelectTypeDescriptor 	*config_control_designt_axis2_placement;
SetTypeDescriptor 	*config_control_designt_set_of_reversible_topology_item;
STEPaggregate *
create_SdaiSet_of_reversible_topology_item () {  return create_SdaiReversible_topology_items();  }
TypeDescriptor 	*config_control_designt_week_in_year_number;
EnumTypeDescriptor 	*config_control_designt_knot_type;

//////////  ENUMERATION TYPE knot_type
const char * 
SdaiKnot_type::element_at (int n) const  {
  switch (n)  {
  case knot_type_UNIFORM_KNOTS :  return "UNIFORM_KNOTS";
  case knot_type_QUASI_UNIFORM_KNOTS :  return "QUASI_UNIFORM_KNOTS";
  case knot_type_PIECEWISE_BEZIER_KNOTS :  return "PIECEWISE_BEZIER_KNOTS";
  case knot_type_UNSPECIFIED :  return "UNSPECIFIED";
  default:  return "";
  }
}
SdaiKnot_type::SdaiKnot_type (const char * n )  {
  set_value (n);
}
SdaiKnot_type::operator sdaiKnot_type () const {
  switch (v) {
	case knot_type_UNIFORM_KNOTS :  return knot_type_UNIFORM_KNOTS;
	case knot_type_QUASI_UNIFORM_KNOTS :  return knot_type_QUASI_UNIFORM_KNOTS;
	case knot_type_PIECEWISE_BEZIER_KNOTS :  return knot_type_PIECEWISE_BEZIER_KNOTS;
	case knot_type_UNSPECIFIED :  
	default :  return knot_type_UNSPECIFIED;
  }
}

//////////  END ENUMERATION knot_type
SelectTypeDescriptor 	*config_control_designt_specified_item;
TypeDescriptor 	*config_control_designt_minute_in_hour;
EnumTypeDescriptor 	*config_control_designt_transition_code;

//////////  ENUMERATION TYPE transition_code
const char * 
SdaiTransition_code::element_at (int n) const  {
  switch (n)  {
  case transition_code_DISCONTINUOUS :  return "DISCONTINUOUS";
  case transition_code_CONT_SAME_GRADIENT_SAME_CURVATURE :  return "CONT_SAME_GRADIENT_SAME_CURVATURE";
  case transition_code_CONT_SAME_GRADIENT :  return "CONT_SAME_GRADIENT";
  case transition_code_CONTINUOUS :  return "CONTINUOUS";
  default:  return "";
  }
}
SdaiTransition_code::SdaiTransition_code (const char * n )  {
  set_value (n);
}
SdaiTransition_code::operator sdaiTransition_code () const {
  switch (v) {
	case transition_code_DISCONTINUOUS :  return transition_code_DISCONTINUOUS;
	case transition_code_CONT_SAME_GRADIENT_SAME_CURVATURE :  return transition_code_CONT_SAME_GRADIENT_SAME_CURVATURE;
	case transition_code_CONT_SAME_GRADIENT :  return transition_code_CONT_SAME_GRADIENT;
	case transition_code_CONTINUOUS :  
	default :  return transition_code_CONTINUOUS;
  }
}

//////////  END ENUMERATION transition_code
TypeDescriptor 	*config_control_designt_identifier;
SelectTypeDescriptor 	*config_control_designt_measure_value;
SelectTypeDescriptor 	*config_control_designt_person_organization_select;
EnumTypeDescriptor 	*config_control_designt_preferred_surface_curve_representation;

//////////  ENUMERATION TYPE preferred_surface_curve_representation
const char * 
SdaiPreferred_surface_curve_representation::element_at (int n) const  {
  switch (n)  {
  case preferred_surface_curve_representation_PCURVE_S2 :  return "PCURVE_S2";
  case preferred_surface_curve_representation_PCURVE_S1 :  return "PCURVE_S1";
  case preferred_surface_curve_representation_CURVE_3D :  return "CURVE_3D";
  default:  return "";
  }
}
SdaiPreferred_surface_curve_representation::SdaiPreferred_surface_curve_representation (const char * n )  {
  set_value (n);
}
SdaiPreferred_surface_curve_representation::operator sdaiPreferred_surface_curve_representation () const {
  switch (v) {
	case preferred_surface_curve_representation_PCURVE_S2 :  return preferred_surface_curve_representation_PCURVE_S2;
	case preferred_surface_curve_representation_PCURVE_S1 :  return preferred_surface_curve_representation_PCURVE_S1;
	case preferred_surface_curve_representation_CURVE_3D :  
	default :  return preferred_surface_curve_representation_CURVE_3D;
  }
}

//////////  END ENUMERATION preferred_surface_curve_representation
TypeDescriptor 	*config_control_designt_dimension_count;
SelectTypeDescriptor 	*config_control_designt_pcurve_or_surface;
TypeDescriptor 	*config_control_designt_positive_length_measure;
EnumTypeDescriptor 	*config_control_designt_b_spline_curve_form;

//////////  ENUMERATION TYPE b_spline_curve_form
const char * 
SdaiB_spline_curve_form::element_at (int n) const  {
  switch (n)  {
  case b_spline_curve_form_ELLIPTIC_ARC :  return "ELLIPTIC_ARC";
  case b_spline_curve_form_POLYLINE_FORM :  return "POLYLINE_FORM";
  case b_spline_curve_form_PARABOLIC_ARC :  return "PARABOLIC_ARC";
  case b_spline_curve_form_CIRCULAR_ARC :  return "CIRCULAR_ARC";
  case b_spline_curve_form_UNSPECIFIED :  return "UNSPECIFIED";
  case b_spline_curve_form_HYPERBOLIC_ARC :  return "HYPERBOLIC_ARC";
  default:  return "";
  }
}
SdaiB_spline_curve_form::SdaiB_spline_curve_form (const char * n )  {
  set_value (n);
}
SdaiB_spline_curve_form::operator sdaiB_spline_curve_form () const {
  switch (v) {
	case b_spline_curve_form_ELLIPTIC_ARC :  return b_spline_curve_form_ELLIPTIC_ARC;
	case b_spline_curve_form_POLYLINE_FORM :  return b_spline_curve_form_POLYLINE_FORM;
	case b_spline_curve_form_PARABOLIC_ARC :  return b_spline_curve_form_PARABOLIC_ARC;
	case b_spline_curve_form_CIRCULAR_ARC :  return b_spline_curve_form_CIRCULAR_ARC;
	case b_spline_curve_form_UNSPECIFIED :  return b_spline_curve_form_UNSPECIFIED;
	case b_spline_curve_form_HYPERBOLIC_ARC :  
	default :  return b_spline_curve_form_HYPERBOLIC_ARC;
  }
}

//////////  END ENUMERATION b_spline_curve_form
TypeDescriptor 	*config_control_designt_hour_in_day;
SelectTypeDescriptor 	*config_control_designt_classified_item;
EnumTypeDescriptor 	*config_control_designt_si_unit_name;

//////////  ENUMERATION TYPE si_unit_name
const char * 
SdaiSi_unit_name::element_at (int n) const  {
  switch (n)  {
  case si_unit_name_HERTZ :  return "HERTZ";
  case si_unit_name_DEGREE_CELSIUS :  return "DEGREE_CELSIUS";
  case si_unit_name_SIEMENS :  return "SIEMENS";
  case si_unit_name_SIEVERT :  return "SIEVERT";
  case si_unit_name_LUX :  return "LUX";
  case si_unit_name_WATT :  return "WATT";
  case si_unit_name_OHM :  return "OHM";
  case si_unit_name_SECOND :  return "SECOND";
  case si_unit_name_BECQUEREL :  return "BECQUEREL";
  case si_unit_name_PASCAL :  return "PASCAL";
  case si_unit_name_HENRY :  return "HENRY";
  case si_unit_name_TESLA :  return "TESLA";
  case si_unit_name_VOLT :  return "VOLT";
  case si_unit_name_JOULE :  return "JOULE";
  case si_unit_name_KELVIN :  return "KELVIN";
  case si_unit_name_AMPERE :  return "AMPERE";
  case si_unit_name_GRAM :  return "GRAM";
  case si_unit_name_STERADIAN :  return "STERADIAN";
  case si_unit_name_MOLE :  return "MOLE";
  case si_unit_name_LUMEN :  return "LUMEN";
  case si_unit_name_GRAY :  return "GRAY";
  case si_unit_name_CANDELA :  return "CANDELA";
  case si_unit_name_FARAD :  return "FARAD";
  case si_unit_name_RADIAN :  return "RADIAN";
  case si_unit_name_NEWTON :  return "NEWTON";
  case si_unit_name_METRE :  return "METRE";
  case si_unit_name_WEBER :  return "WEBER";
  case si_unit_name_COULOMB :  return "COULOMB";
  default:  return "";
  }
}
SdaiSi_unit_name::SdaiSi_unit_name (const char * n )  {
  set_value (n);
}
SdaiSi_unit_name::operator sdaiSi_unit_name () const {
  switch (v) {
	case si_unit_name_HERTZ :  return si_unit_name_HERTZ;
	case si_unit_name_DEGREE_CELSIUS :  return si_unit_name_DEGREE_CELSIUS;
	case si_unit_name_SIEMENS :  return si_unit_name_SIEMENS;
	case si_unit_name_SIEVERT :  return si_unit_name_SIEVERT;
	case si_unit_name_LUX :  return si_unit_name_LUX;
	case si_unit_name_WATT :  return si_unit_name_WATT;
	case si_unit_name_OHM :  return si_unit_name_OHM;
	case si_unit_name_SECOND :  return si_unit_name_SECOND;
	case si_unit_name_BECQUEREL :  return si_unit_name_BECQUEREL;
	case si_unit_name_PASCAL :  return si_unit_name_PASCAL;
	case si_unit_name_HENRY :  return si_unit_name_HENRY;
	case si_unit_name_TESLA :  return si_unit_name_TESLA;
	case si_unit_name_VOLT :  return si_unit_name_VOLT;
	case si_unit_name_JOULE :  return si_unit_name_JOULE;
	case si_unit_name_KELVIN :  return si_unit_name_KELVIN;
	case si_unit_name_AMPERE :  return si_unit_name_AMPERE;
	case si_unit_name_GRAM :  return si_unit_name_GRAM;
	case si_unit_name_STERADIAN :  return si_unit_name_STERADIAN;
	case si_unit_name_MOLE :  return si_unit_name_MOLE;
	case si_unit_name_LUMEN :  return si_unit_name_LUMEN;
	case si_unit_name_GRAY :  return si_unit_name_GRAY;
	case si_unit_name_CANDELA :  return si_unit_name_CANDELA;
	case si_unit_name_FARAD :  return si_unit_name_FARAD;
	case si_unit_name_RADIAN :  return si_unit_name_RADIAN;
	case si_unit_name_NEWTON :  return si_unit_name_NEWTON;
	case si_unit_name_METRE :  return si_unit_name_METRE;
	case si_unit_name_WEBER :  return si_unit_name_WEBER;
	case si_unit_name_COULOMB :  
	default :  return si_unit_name_COULOMB;
  }
}

//////////  END ENUMERATION si_unit_name
TypeDescriptor 	*config_control_designt_day_in_month_number;
EnumTypeDescriptor 	*config_control_designt_trimming_preference;

//////////  ENUMERATION TYPE trimming_preference
const char * 
SdaiTrimming_preference::element_at (int n) const  {
  switch (n)  {
  case trimming_preference_PARAMETER :  return "PARAMETER";
  case trimming_preference_UNSPECIFIED :  return "UNSPECIFIED";
  case trimming_preference_CARTESIAN :  return "CARTESIAN";
  default:  return "";
  }
}
SdaiTrimming_preference::SdaiTrimming_preference (const char * n )  {
  set_value (n);
}
SdaiTrimming_preference::operator sdaiTrimming_preference () const {
  switch (v) {
	case trimming_preference_PARAMETER :  return trimming_preference_PARAMETER;
	case trimming_preference_UNSPECIFIED :  return trimming_preference_UNSPECIFIED;
	case trimming_preference_CARTESIAN :  
	default :  return trimming_preference_CARTESIAN;
  }
}

//////////  END ENUMERATION trimming_preference
SelectTypeDescriptor 	*config_control_designt_vector_or_direction;
SelectTypeDescriptor 	*config_control_designt_wireframe_model;
TypeDescriptor 	*config_control_designt_volume_measure;
SelectTypeDescriptor 	*config_control_designt_geometric_set_select;
TypeDescriptor 	*config_control_designt_positive_plane_angle_measure;
SelectTypeDescriptor 	*config_control_designt_start_request_item;
EnumTypeDescriptor 	*config_control_designt_b_spline_surface_form;

//////////  ENUMERATION TYPE b_spline_surface_form
const char * 
SdaiB_spline_surface_form::element_at (int n) const  {
  switch (n)  {
  case b_spline_surface_form_SURF_OF_LINEAR_EXTRUSION :  return "SURF_OF_LINEAR_EXTRUSION";
  case b_spline_surface_form_PLANE_SURF :  return "PLANE_SURF";
  case b_spline_surface_form_GENERALISED_CONE :  return "GENERALISED_CONE";
  case b_spline_surface_form_TOROIDAL_SURF :  return "TOROIDAL_SURF";
  case b_spline_surface_form_CONICAL_SURF :  return "CONICAL_SURF";
  case b_spline_surface_form_SPHERICAL_SURF :  return "SPHERICAL_SURF";
  case b_spline_surface_form_UNSPECIFIED :  return "UNSPECIFIED";
  case b_spline_surface_form_RULED_SURF :  return "RULED_SURF";
  case b_spline_surface_form_SURF_OF_REVOLUTION :  return "SURF_OF_REVOLUTION";
  case b_spline_surface_form_CYLINDRICAL_SURF :  return "CYLINDRICAL_SURF";
  case b_spline_surface_form_QUADRIC_SURF :  return "QUADRIC_SURF";
  default:  return "";
  }
}
SdaiB_spline_surface_form::SdaiB_spline_surface_form (const char * n )  {
  set_value (n);
}
SdaiB_spline_surface_form::operator sdaiB_spline_surface_form () const {
  switch (v) {
	case b_spline_surface_form_SURF_OF_LINEAR_EXTRUSION :  return b_spline_surface_form_SURF_OF_LINEAR_EXTRUSION;
	case b_spline_surface_form_PLANE_SURF :  return b_spline_surface_form_PLANE_SURF;
	case b_spline_surface_form_GENERALISED_CONE :  return b_spline_surface_form_GENERALISED_CONE;
	case b_spline_surface_form_TOROIDAL_SURF :  return b_spline_surface_form_TOROIDAL_SURF;
	case b_spline_surface_form_CONICAL_SURF :  return b_spline_surface_form_CONICAL_SURF;
	case b_spline_surface_form_SPHERICAL_SURF :  return b_spline_surface_form_SPHERICAL_SURF;
	case b_spline_surface_form_UNSPECIFIED :  return b_spline_surface_form_UNSPECIFIED;
	case b_spline_surface_form_RULED_SURF :  return b_spline_surface_form_RULED_SURF;
	case b_spline_surface_form_SURF_OF_REVOLUTION :  return b_spline_surface_form_SURF_OF_REVOLUTION;
	case b_spline_surface_form_CYLINDRICAL_SURF :  return b_spline_surface_form_CYLINDRICAL_SURF;
	case b_spline_surface_form_QUADRIC_SURF :  
	default :  return b_spline_surface_form_QUADRIC_SURF;
  }
}

//////////  END ENUMERATION b_spline_surface_form
SelectTypeDescriptor 	*config_control_designt_person_organization_item;
SelectTypeDescriptor 	*config_control_designt_date_time_item;
SelectTypeDescriptor 	*config_control_designt_shell;
SelectTypeDescriptor 	*config_control_designt_transformation;
TypeDescriptor 	*config_control_designt_day_in_week_number;
SelectTypeDescriptor 	*config_control_designt_boolean_operand;
SelectTypeDescriptor 	*config_control_designt_certified_item;
SelectTypeDescriptor 	*config_control_designt_date_time_select;
TypeDescriptor 	*config_control_designt_solid_angle_measure;
SelectTypeDescriptor 	*config_control_designt_curve_on_surface;
SelectTypeDescriptor 	*config_control_designt_trimming_select;
EnumTypeDescriptor 	*config_control_designt_ahead_or_behind;

//////////  ENUMERATION TYPE ahead_or_behind
const char * 
SdaiAhead_or_behind::element_at (int n) const  {
  switch (n)  {
  case ahead_or_behind_AHEAD :  return "AHEAD";
  case ahead_or_behind_BEHIND :  return "BEHIND";
  default:  return "";
  }
}
SdaiAhead_or_behind::SdaiAhead_or_behind (const char * n )  {
  set_value (n);
}
SdaiAhead_or_behind::operator sdaiAhead_or_behind () const {
  switch (v) {
	case ahead_or_behind_AHEAD :  return ahead_or_behind_AHEAD;
	case ahead_or_behind_BEHIND :  
	default :  return ahead_or_behind_BEHIND;
  }
}

//////////  END ENUMERATION ahead_or_behind
SelectTypeDescriptor 	*config_control_designt_contracted_item;
TypeDescriptor 	*config_control_designt_day_in_year_number;
TypeDescriptor 	*config_control_designt_mass_measure;
TypeDescriptor 	*config_control_designt_descriptive_measure;
TypeDescriptor 	*config_control_designt_area_measure;
TypeDescriptor 	*config_control_designt_month_in_year_number;
EnumTypeDescriptor 	*config_control_designt_source;

//////////  ENUMERATION TYPE source
const char * 
SdaiSource::element_at (int n) const  {
  switch (n)  {
  case source_BOUGHT :  return "BOUGHT";
  case source_NOT_KNOWN :  return "NOT_KNOWN";
  case source_MADE :  return "MADE";
  default:  return "";
  }
}
SdaiSource::SdaiSource (const char * n )  {
  set_value (n);
}
SdaiSource::operator sdaiSource () const {
  switch (v) {
	case source_BOUGHT :  return source_BOUGHT;
	case source_NOT_KNOWN :  return source_NOT_KNOWN;
	case source_MADE :  
	default :  return source_MADE;
  }
}

//////////  END ENUMERATION source
SelectTypeDescriptor 	*config_control_designt_unit;
SelectTypeDescriptor 	*config_control_designt_reversible_topology;
SelectTypeDescriptor 	*config_control_designt_work_item;
SelectTypeDescriptor 	*config_control_designt_shape_definition;
TypeDescriptor 	*config_control_designt_second_in_minute;
TypeDescriptor 	*config_control_designt_label;
TypeDescriptor 	*config_control_designt_context_dependent_measure;
SelectTypeDescriptor 	*config_control_designt_supported_item;
EnumTypeDescriptor 	*config_control_designt_si_prefix;

//////////  ENUMERATION TYPE si_prefix
const char * 
SdaiSi_prefix::element_at (int n) const  {
  switch (n)  {
  case si_prefix_EXA :  return "EXA";
  case si_prefix_PICO :  return "PICO";
  case si_prefix_MEGA :  return "MEGA";
  case si_prefix_FEMTO :  return "FEMTO";
  case si_prefix_ATTO :  return "ATTO";
  case si_prefix_CENTI :  return "CENTI";
  case si_prefix_NANO :  return "NANO";
  case si_prefix_HECTO :  return "HECTO";
  case si_prefix_MICRO :  return "MICRO";
  case si_prefix_TERA :  return "TERA";
  case si_prefix_GIGA :  return "GIGA";
  case si_prefix_MILLI :  return "MILLI";
  case si_prefix_PETA :  return "PETA";
  case si_prefix_DECI :  return "DECI";
  case si_prefix_KILO :  return "KILO";
  case si_prefix_DECA :  return "DECA";
  default:  return "";
  }
}
SdaiSi_prefix::SdaiSi_prefix (const char * n )  {
  set_value (n);
}
SdaiSi_prefix::operator sdaiSi_prefix () const {
  switch (v) {
	case si_prefix_EXA :  return si_prefix_EXA;
	case si_prefix_PICO :  return si_prefix_PICO;
	case si_prefix_MEGA :  return si_prefix_MEGA;
	case si_prefix_FEMTO :  return si_prefix_FEMTO;
	case si_prefix_ATTO :  return si_prefix_ATTO;
	case si_prefix_CENTI :  return si_prefix_CENTI;
	case si_prefix_NANO :  return si_prefix_NANO;
	case si_prefix_HECTO :  return si_prefix_HECTO;
	case si_prefix_MICRO :  return si_prefix_MICRO;
	case si_prefix_TERA :  return si_prefix_TERA;
	case si_prefix_GIGA :  return si_prefix_GIGA;
	case si_prefix_MILLI :  return si_prefix_MILLI;
	case si_prefix_PETA :  return si_prefix_PETA;
	case si_prefix_DECI :  return si_prefix_DECI;
	case si_prefix_KILO :  return si_prefix_KILO;
	case si_prefix_DECA :  
	default :  return si_prefix_DECA;
  }
}

//////////  END ENUMERATION si_prefix
TypeDescriptor 	*config_control_designt_length_measure;
SelectTypeDescriptor 	*config_control_designt_approved_item;
TypeDescriptor 	*config_control_designt_count_measure;
SelectTypeDescriptor 	*config_control_designt_surface_model;
ListTypeDescriptor 	*config_control_designt_list_of_reversible_topology_item;
STEPaggregate *
create_SdaiList_of_reversible_topology_item () {  return create_SdaiReversible_topology_items();  }

//////////  SELECT TYPE characterized_product_definition

const TypeDescriptor * 
SdaiCharacterized_product_definition::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION
  if (se -> eDesc -> IsA (config_control_designe_product_definition))
  {  
	_stepentityh = (SdaiProduct_definitionH) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  PRODUCT_DEFINITION_RELATIONSHIP
  if (se -> eDesc -> IsA (config_control_designe_product_definition_relationship))
  {  
	_stepentityh = (SdaiProduct_definition_relationshipH) se;
	return SetUnderlyingType (config_control_designe_product_definition_relationship);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiCharacterized_product_definition::NewSelect ()
{
  SdaiCharacterized_product_definition * tmp = new SdaiCharacterized_product_definition ();
  return tmp;
}
// STEP Part 21

void
SdaiCharacterized_product_definition::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_product_definition_relationship)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCharacterized_product_definition::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_product_definition_relationship)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCharacterized_product_definition::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiCharacterized_product_definition::SdaiCharacterized_product_definition()
  : SdaiSelect (config_control_designt_characterized_product_definition)
{
   nullify();
}

	//  part 1
SdaiCharacterized_product_definition::SdaiCharacterized_product_definition( const SdaiProduct_definitionH& o )
  : SdaiSelect (config_control_designt_characterized_product_definition, config_control_designe_product_definition )
{
   _stepentityh = o;
}

SdaiCharacterized_product_definition::SdaiCharacterized_product_definition( const SdaiProduct_definition_relationshipH& o )
  : SdaiSelect (config_control_designt_characterized_product_definition, config_control_designe_product_definition_relationship )
{
   _stepentityh = o;
}

SdaiCharacterized_product_definition::~SdaiCharacterized_product_definition()
{
}


	//  part 2
SdaiCharacterized_product_definition::operator SdaiProduct_definitionH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definitionH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiCharacterized_product_definition::operator SdaiProduct_definition_relationshipH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
      return ((SdaiProduct_definition_relationshipH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiProduct_definitionH 
SdaiCharacterized_product_definition::Related_product_definition() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationshipH) _stepentityh) ->Related_product_definition();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCharacterized_product_definition::Related_product_definition (SdaiProduct_definitionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationshipH) _stepentityh) ->Related_product_definition( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definitionH 
SdaiCharacterized_product_definition::Relating_product_definition() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationshipH) _stepentityh) ->Relating_product_definition();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCharacterized_product_definition::Relating_product_definition (SdaiProduct_definitionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationshipH) _stepentityh) ->Relating_product_definition( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiCharacterized_product_definition::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationshipH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCharacterized_product_definition::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationshipH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_contextH 
SdaiCharacterized_product_definition::Frame_of_reference() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCharacterized_product_definition::Frame_of_reference (SdaiProduct_definition_contextH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_formationH 
SdaiCharacterized_product_definition::Formation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Formation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCharacterized_product_definition::Formation (SdaiProduct_definition_formationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Formation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiCharacterized_product_definition::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationshipH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCharacterized_product_definition::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationshipH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiCharacterized_product_definition::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	return ((SdaiProduct_definition_relationshipH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCharacterized_product_definition::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship ) 
	//  PRODUCT_DEFINITION_RELATIONSHIP
	{  ((SdaiProduct_definition_relationshipH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiCharacterized_product_definition& SdaiCharacterized_product_definition::operator =( const SdaiProduct_definitionH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiCharacterized_product_definition& SdaiCharacterized_product_definition::operator =( const SdaiProduct_definition_relationshipH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_relationship);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiCharacterized_product_definition& SdaiCharacterized_product_definition::operator =( const SdaiCharacterized_product_definitionH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiCharacterized_product_definition::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh = ((SdaiCharacterized_product_definition&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
	_stepentityh = ((SdaiCharacterized_product_definition&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiCharacterized_product_definition::IsProduct_definition() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiCharacterized_product_definition::IsProduct_definition_relationship() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_relationship )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiCharacterized_product_definition


//////////  SELECT TYPE shape_definition

const TypeDescriptor * 
SdaiShape_definition::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION_SHAPE
  if (se -> eDesc -> IsA (config_control_designe_product_definition_shape))
  {  
	_stepentityh = (SdaiProduct_definition_shapeH) se;
	return SetUnderlyingType (config_control_designe_product_definition_shape);
  }
  //  SHAPE_ASPECT
  if (se -> eDesc -> IsA (config_control_designe_shape_aspect))
  {  
	_stepentityh = (SdaiShape_aspectH) se;
	return SetUnderlyingType (config_control_designe_shape_aspect);
  }
  //  SHAPE_ASPECT_RELATIONSHIP
  if (se -> eDesc -> IsA (config_control_designe_shape_aspect_relationship))
  {  
	_stepentityh = (SdaiShape_aspect_relationshipH) se;
	return SetUnderlyingType (config_control_designe_shape_aspect_relationship);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiShape_definition::NewSelect ()
{
  SdaiShape_definition * tmp = new SdaiShape_definition ();
  return tmp;
}
// STEP Part 21

void
SdaiShape_definition::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_shape)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_shape_aspect)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiShape_definition::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition_shape)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_shape_aspect)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiShape_definition::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiShape_definition::SdaiShape_definition()
  : SdaiSelect (config_control_designt_shape_definition)
{
   nullify();
}

	//  part 1
SdaiShape_definition::SdaiShape_definition( const SdaiProduct_definition_shapeH& o )
  : SdaiSelect (config_control_designt_shape_definition, config_control_designe_product_definition_shape )
{
   _stepentityh = o;
}

SdaiShape_definition::SdaiShape_definition( const SdaiShape_aspectH& o )
  : SdaiSelect (config_control_designt_shape_definition, config_control_designe_shape_aspect )
{
   _stepentityh = o;
}

SdaiShape_definition::SdaiShape_definition( const SdaiShape_aspect_relationshipH& o )
  : SdaiSelect (config_control_designt_shape_definition, config_control_designe_shape_aspect_relationship )
{
   _stepentityh = o;
}

SdaiShape_definition::~SdaiShape_definition()
{
}


	//  part 2
SdaiShape_definition::operator SdaiProduct_definition_shapeH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
      return ((SdaiProduct_definition_shapeH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShape_definition::operator SdaiShape_aspectH()
{
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return ((SdaiShape_aspectH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShape_definition::operator SdaiShape_aspect_relationshipH()
{
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
      return ((SdaiShape_aspect_relationshipH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiShape_aspectH 
SdaiShape_definition::Related_shape_aspect() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationshipH) _stepentityh) ->Related_shape_aspect();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShape_definition::Related_shape_aspect (SdaiShape_aspectH x)
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationshipH) _stepentityh) ->Related_shape_aspect( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiShape_aspectH 
SdaiShape_definition::Relating_shape_aspect() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationshipH) _stepentityh) ->Relating_shape_aspect();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShape_definition::Relating_shape_aspect (SdaiShape_aspectH x)
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationshipH) _stepentityh) ->Relating_shape_aspect( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const LOGICAL 
SdaiShape_definition::Product_definitional() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Product_definitional();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return (LOGICAL) NULL;
}


void 
SdaiShape_definition::Product_definitional (LOGICAL x)
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Product_definitional( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_shapeH 
SdaiShape_definition::Of_shape() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Of_shape();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShape_definition::Of_shape (SdaiProduct_definition_shapeH x)
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Of_shape( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiCharacterized_definitionH 
SdaiShape_definition::Definition() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape ) 
	//  PRODUCT_DEFINITION_SHAPE
	return ((SdaiProduct_definition_shapeH) _stepentityh) ->Definition();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShape_definition::Definition (SdaiCharacterized_definitionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape ) 
	//  PRODUCT_DEFINITION_SHAPE
	{  ((SdaiProduct_definition_shapeH) _stepentityh) ->Definition( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiShape_definition::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape ) 
	//  PRODUCT_DEFINITION_SHAPE
	return ((SdaiProduct_definition_shapeH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationshipH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShape_definition::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape ) 
	//  PRODUCT_DEFINITION_SHAPE
	{  ((SdaiProduct_definition_shapeH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationshipH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiShape_definition::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape ) 
	//  PRODUCT_DEFINITION_SHAPE
	return ((SdaiProduct_definition_shapeH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	return ((SdaiShape_aspect_relationshipH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShape_definition::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_shape ) 
	//  PRODUCT_DEFINITION_SHAPE
	{  ((SdaiProduct_definition_shapeH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship ) 
	//  SHAPE_ASPECT_RELATIONSHIP
	{  ((SdaiShape_aspect_relationshipH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiShape_definition& SdaiShape_definition::operator =( const SdaiProduct_definition_shapeH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_shape);
   return *this;
}

SdaiShape_definition& SdaiShape_definition::operator =( const SdaiShape_aspectH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_shape_aspect);
   return *this;
}

SdaiShape_definition& SdaiShape_definition::operator =( const SdaiShape_aspect_relationshipH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_shape_aspect_relationship);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiShape_definition& SdaiShape_definition::operator =( const SdaiShape_definitionH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiShape_definition::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_shape )
	_stepentityh = ((SdaiShape_definition&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_stepentityh = ((SdaiShape_definition&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
	_stepentityh = ((SdaiShape_definition&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiShape_definition::IsProduct_definition_shape() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_shape )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiShape_definition::IsShape_aspect() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiShape_definition::IsShape_aspect_relationship() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect_relationship )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiShape_definition


//////////  SELECT TYPE characterized_definition

const TypeDescriptor * 
SdaiCharacterized_definition::AssignEntity (STEPentity * se)
{
  //  CHARACTERIZED_PRODUCT_DEFINITION
  if (config_control_designt_characterized_product_definition -> CanBe (se -> eDesc))
  {  
	_sdaicharacterized_product_definition.AssignEntity (se);
	return SetUnderlyingType (config_control_designt_characterized_product_definition);
  }
  //  SHAPE_DEFINITION
  if (config_control_designt_shape_definition -> CanBe (se -> eDesc))
  {  
	_sdaishape_definition.AssignEntity (se);
	return SetUnderlyingType (config_control_designt_shape_definition);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiCharacterized_definition::NewSelect ()
{
  SdaiCharacterized_definition * tmp = new SdaiCharacterized_definition ();
  return tmp;
}
// STEP Part 21

void
SdaiCharacterized_definition::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designt_characterized_product_definition)
	_sdaicharacterized_product_definition.STEPwrite (out);
  else    if (CurrentUnderlyingType () == config_control_designt_shape_definition)
	_sdaishape_definition.STEPwrite (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCharacterized_definition::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designt_characterized_product_definition)   {
	_sdaicharacterized_product_definition.STEPread (in, &_error, instances, addFileId);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_shape_definition)   {
	_sdaishape_definition.STEPread (in, &_error, instances, addFileId);
	return severity ();
  }
  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCharacterized_definition::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiCharacterized_definition::SdaiCharacterized_definition()
  : SdaiSelect (config_control_designt_characterized_definition)
{
   nullify();
}

	//  part 1
SdaiCharacterized_definition::SdaiCharacterized_definition( const SdaiCharacterized_product_definitionH& o )
  : SdaiSelect (config_control_designt_characterized_definition, config_control_designt_characterized_product_definition )
{
   _sdaicharacterized_product_definition = o;
}

SdaiCharacterized_definition::SdaiCharacterized_definition( const SdaiShape_definitionH& o )
  : SdaiSelect (config_control_designt_characterized_definition, config_control_designt_shape_definition )
{
   _sdaishape_definition = o;
}

SdaiCharacterized_definition::~SdaiCharacterized_definition()
{
}


	//  part 2
SdaiCharacterized_definition::operator SdaiCharacterized_product_definitionH()
{
   if( CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
      return & _sdaicharacterized_product_definition;

  severity( SEVERITY_WARNING );
  Error( "Underlying type is not SdaiCharacterized_product_definitionH" );

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiCharacterized_definition::operator SdaiShape_definitionH()
{
   if( CurrentUnderlyingType () == config_control_designt_shape_definition )
      return & _sdaishape_definition;

  severity( SEVERITY_WARNING );
  Error( "Underlying type is not SdaiShape_definitionH" );

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

	//  part 4
SdaiCharacterized_definition& SdaiCharacterized_definition::operator =( const SdaiCharacterized_product_definitionH& o )
{
  nullify ();
   _sdaicharacterized_product_definition = o;
   SetUnderlyingType (config_control_designt_characterized_product_definition);
   return *this;
}

SdaiCharacterized_definition& SdaiCharacterized_definition::operator =( const SdaiShape_definitionH& o )
{
  nullify ();
   _sdaishape_definition = o;
   SetUnderlyingType (config_control_designt_shape_definition);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiCharacterized_definition& SdaiCharacterized_definition::operator =( const SdaiCharacterized_definitionH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
	_sdaicharacterized_product_definition =  o -> _sdaicharacterized_product_definition;
   if( o -> CurrentUnderlyingType () == config_control_designt_shape_definition )
	_sdaishape_definition =  o -> _sdaishape_definition;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiCharacterized_definition::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
	_sdaicharacterized_product_definition = ((SdaiCharacterized_definition&) o)._sdaicharacterized_product_definition;
   if( o.CurrentUnderlyingType () == config_control_designt_shape_definition )
	_sdaishape_definition = ((SdaiCharacterized_definition&) o)._sdaishape_definition;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiCharacterized_definition::IsCharacterized_product_definition() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_characterized_product_definition )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiCharacterized_definition::IsShape_definition() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_shape_definition )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiCharacterized_definition


//////////  SELECT TYPE change_request_item

const TypeDescriptor * 
SdaiChange_request_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> eDesc -> IsA (config_control_designe_product_definition_formation))
  {  
	_stepentityh = (SdaiProduct_definition_formationH) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiChange_request_item::NewSelect ()
{
  SdaiChange_request_item * tmp = new SdaiChange_request_item ();
  return tmp;
}
// STEP Part 21

void
SdaiChange_request_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiChange_request_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiChange_request_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiChange_request_item::SdaiChange_request_item()
  : SdaiSelect (config_control_designt_change_request_item)
{
   nullify();
}

	//  part 1
SdaiChange_request_item::SdaiChange_request_item( const SdaiProduct_definition_formationH& o )
  : SdaiSelect (config_control_designt_change_request_item, config_control_designe_product_definition_formation )
{
   _stepentityh = o;
}

SdaiChange_request_item::~SdaiChange_request_item()
{
}


	//  part 2
SdaiChange_request_item::operator SdaiProduct_definition_formationH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiProductH 
SdaiChange_request_item::Of_product() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiChange_request_item::Of_product (SdaiProductH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiChange_request_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiChange_request_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiChange_request_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiChange_request_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiChange_request_item& SdaiChange_request_item::operator =( const SdaiProduct_definition_formationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiChange_request_item& SdaiChange_request_item::operator =( const SdaiChange_request_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiChange_request_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh = ((SdaiChange_request_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiChange_request_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiChange_request_item


//////////  SELECT TYPE reversible_topology_item

const TypeDescriptor * 
SdaiReversible_topology_item::AssignEntity (STEPentity * se)
{
  //  EDGE
  if (se -> eDesc -> IsA (config_control_designe_edge))
  {  
	_stepentityh = (SdaiEdgeH) se;
	return SetUnderlyingType (config_control_designe_edge);
  }
  //  PATH
  if (se -> eDesc -> IsA (config_control_designe_path))
  {  
	_stepentityh = (SdaiPathH) se;
	return SetUnderlyingType (config_control_designe_path);
  }
  //  FACE
  if (se -> eDesc -> IsA (config_control_designe_face))
  {  
	_stepentityh = (SdaiFaceH) se;
	return SetUnderlyingType (config_control_designe_face);
  }
  //  FACE_BOUND
  if (se -> eDesc -> IsA (config_control_designe_face_bound))
  {  
	_stepentityh = (SdaiFace_boundH) se;
	return SetUnderlyingType (config_control_designe_face_bound);
  }
  //  CLOSED_SHELL
  if (se -> eDesc -> IsA (config_control_designe_closed_shell))
  {  
	_stepentityh = (SdaiClosed_shellH) se;
	return SetUnderlyingType (config_control_designe_closed_shell);
  }
  //  OPEN_SHELL
  if (se -> eDesc -> IsA (config_control_designe_open_shell))
  {  
	_stepentityh = (SdaiOpen_shellH) se;
	return SetUnderlyingType (config_control_designe_open_shell);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiReversible_topology_item::NewSelect ()
{
  SdaiReversible_topology_item * tmp = new SdaiReversible_topology_item ();
  return tmp;
}
// STEP Part 21

void
SdaiReversible_topology_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_edge)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_path)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_face)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_face_bound)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_closed_shell)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_open_shell)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiReversible_topology_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_edge)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_path)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_face)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_face_bound)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_closed_shell)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_open_shell)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiReversible_topology_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiReversible_topology_item::SdaiReversible_topology_item()
  : SdaiSelect (config_control_designt_reversible_topology_item)
{
   nullify();
}

	//  part 1
SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiEdgeH& o )
  : SdaiSelect (config_control_designt_reversible_topology_item, config_control_designe_edge )
{
   _stepentityh = o;
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiPathH& o )
  : SdaiSelect (config_control_designt_reversible_topology_item, config_control_designe_path )
{
   _stepentityh = o;
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiFaceH& o )
  : SdaiSelect (config_control_designt_reversible_topology_item, config_control_designe_face )
{
   _stepentityh = o;
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiFace_boundH& o )
  : SdaiSelect (config_control_designt_reversible_topology_item, config_control_designe_face_bound )
{
   _stepentityh = o;
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiClosed_shellH& o )
  : SdaiSelect (config_control_designt_reversible_topology_item, config_control_designe_closed_shell )
{
   _stepentityh = o;
}

SdaiReversible_topology_item::SdaiReversible_topology_item( const SdaiOpen_shellH& o )
  : SdaiSelect (config_control_designt_reversible_topology_item, config_control_designe_open_shell )
{
   _stepentityh = o;
}

SdaiReversible_topology_item::~SdaiReversible_topology_item()
{
}


	//  part 2
SdaiReversible_topology_item::operator SdaiEdgeH()
{
   if( CurrentUnderlyingType () == config_control_designe_edge )
      return ((SdaiEdgeH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiPathH()
{
   if( CurrentUnderlyingType () == config_control_designe_path )
      return ((SdaiPathH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiFaceH()
{
   if( CurrentUnderlyingType () == config_control_designe_face )
      return ((SdaiFaceH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiFace_boundH()
{
   if( CurrentUnderlyingType () == config_control_designe_face_bound )
      return ((SdaiFace_boundH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiClosed_shellH()
{
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return ((SdaiClosed_shellH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology_item::operator SdaiOpen_shellH()
{
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return ((SdaiOpen_shellH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const EntityAggregateH 
SdaiReversible_topology_item::Cfs_faces() const 
{
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	return ((SdaiClosed_shellH) _stepentityh) ->Cfs_faces();
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	return ((SdaiOpen_shellH) _stepentityh) ->Cfs_faces();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiReversible_topology_item::Cfs_faces (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	{  ((SdaiClosed_shellH) _stepentityh) ->Cfs_faces( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	{  ((SdaiOpen_shellH) _stepentityh) ->Cfs_faces( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const BOOLEAN 
SdaiReversible_topology_item::Orientation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_face_bound ) 
	//  FACE_BOUND
	return ((SdaiFace_boundH) _stepentityh) ->Orientation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return (BOOLEAN) NULL;
}


void 
SdaiReversible_topology_item::Orientation (BOOLEAN x)
{
  if( CurrentUnderlyingType () == config_control_designe_face_bound ) 
	//  FACE_BOUND
	{  ((SdaiFace_boundH) _stepentityh) ->Orientation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiLoopH 
SdaiReversible_topology_item::Bound() const 
{
  if( CurrentUnderlyingType () == config_control_designe_face_bound ) 
	//  FACE_BOUND
	return ((SdaiFace_boundH) _stepentityh) ->Bound();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiReversible_topology_item::Bound (SdaiLoopH x)
{
  if( CurrentUnderlyingType () == config_control_designe_face_bound ) 
	//  FACE_BOUND
	{  ((SdaiFace_boundH) _stepentityh) ->Bound( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const EntityAggregateH 
SdaiReversible_topology_item::Bounds() const 
{
  if( CurrentUnderlyingType () == config_control_designe_face ) 
	//  FACE
	return ((SdaiFaceH) _stepentityh) ->Bounds();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiReversible_topology_item::Bounds (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_face ) 
	//  FACE
	{  ((SdaiFaceH) _stepentityh) ->Bounds( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const EntityAggregateH 
SdaiReversible_topology_item::Edge_list() const 
{
  if( CurrentUnderlyingType () == config_control_designe_path ) 
	//  PATH
	return ((SdaiPathH) _stepentityh) ->Edge_list();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiReversible_topology_item::Edge_list (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_path ) 
	//  PATH
	{  ((SdaiPathH) _stepentityh) ->Edge_list( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiVertexH 
SdaiReversible_topology_item::Edge_end() const 
{
  if( CurrentUnderlyingType () == config_control_designe_edge ) 
	//  EDGE
	return ((SdaiEdgeH) _stepentityh) ->Edge_end();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiReversible_topology_item::Edge_end (SdaiVertexH x)
{
  if( CurrentUnderlyingType () == config_control_designe_edge ) 
	//  EDGE
	{  ((SdaiEdgeH) _stepentityh) ->Edge_end( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiVertexH 
SdaiReversible_topology_item::Edge_start() const 
{
  if( CurrentUnderlyingType () == config_control_designe_edge ) 
	//  EDGE
	return ((SdaiEdgeH) _stepentityh) ->Edge_start();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiReversible_topology_item::Edge_start (SdaiVertexH x)
{
  if( CurrentUnderlyingType () == config_control_designe_edge ) 
	//  EDGE
	{  ((SdaiEdgeH) _stepentityh) ->Edge_start( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiReversible_topology_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_edge ) 
	//  EDGE
	return ((SdaiEdgeH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_path ) 
	//  PATH
	return ((SdaiPathH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_face ) 
	//  FACE
	return ((SdaiFaceH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_face_bound ) 
	//  FACE_BOUND
	return ((SdaiFace_boundH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	return ((SdaiClosed_shellH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	return ((SdaiOpen_shellH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiReversible_topology_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_edge ) 
	//  EDGE
	{  ((SdaiEdgeH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_path ) 
	//  PATH
	{  ((SdaiPathH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_face ) 
	//  FACE
	{  ((SdaiFaceH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_face_bound ) 
	//  FACE_BOUND
	{  ((SdaiFace_boundH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	{  ((SdaiClosed_shellH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	{  ((SdaiOpen_shellH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiEdgeH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_edge);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiPathH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_path);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiFaceH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_face);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiFace_boundH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_face_bound);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiClosed_shellH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_closed_shell);
   return *this;
}

SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiOpen_shellH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_open_shell);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiReversible_topology_item& SdaiReversible_topology_item::operator =( const SdaiReversible_topology_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_edge )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_path )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_face )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_face_bound )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_closed_shell )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_open_shell )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiReversible_topology_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_edge )
	_stepentityh = ((SdaiReversible_topology_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_path )
	_stepentityh = ((SdaiReversible_topology_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_face )
	_stepentityh = ((SdaiReversible_topology_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_face_bound )
	_stepentityh = ((SdaiReversible_topology_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_closed_shell )
	_stepentityh = ((SdaiReversible_topology_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_open_shell )
	_stepentityh = ((SdaiReversible_topology_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiReversible_topology_item::IsEdge() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_edge )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiReversible_topology_item::IsPath() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_path )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiReversible_topology_item::IsFace() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_face )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiReversible_topology_item::IsFace_bound() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_face_bound )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiReversible_topology_item::IsClosed_shell() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiReversible_topology_item::IsOpen_shell() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiReversible_topology_item


//////////  SELECT TYPE axis2_placement

const TypeDescriptor * 
SdaiAxis2_placement::AssignEntity (STEPentity * se)
{
  //  AXIS2_PLACEMENT_2D
  if (se -> eDesc -> IsA (config_control_designe_axis2_placement_2d))
  {  
	_stepentityh = (SdaiAxis2_placement_2dH) se;
	return SetUnderlyingType (config_control_designe_axis2_placement_2d);
  }
  //  AXIS2_PLACEMENT_3D
  if (se -> eDesc -> IsA (config_control_designe_axis2_placement_3d))
  {  
	_stepentityh = (SdaiAxis2_placement_3dH) se;
	return SetUnderlyingType (config_control_designe_axis2_placement_3d);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiAxis2_placement::NewSelect ()
{
  SdaiAxis2_placement * tmp = new SdaiAxis2_placement ();
  return tmp;
}
// STEP Part 21

void
SdaiAxis2_placement::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_axis2_placement_2d)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_axis2_placement_3d)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiAxis2_placement::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_axis2_placement_2d)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_axis2_placement_3d)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiAxis2_placement::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiAxis2_placement::SdaiAxis2_placement()
  : SdaiSelect (config_control_designt_axis2_placement)
{
   nullify();
}

	//  part 1
SdaiAxis2_placement::SdaiAxis2_placement( const SdaiAxis2_placement_2dH& o )
  : SdaiSelect (config_control_designt_axis2_placement, config_control_designe_axis2_placement_2d )
{
   _stepentityh = o;
}

SdaiAxis2_placement::SdaiAxis2_placement( const SdaiAxis2_placement_3dH& o )
  : SdaiSelect (config_control_designt_axis2_placement, config_control_designe_axis2_placement_3d )
{
   _stepentityh = o;
}

SdaiAxis2_placement::~SdaiAxis2_placement()
{
}


	//  part 2
SdaiAxis2_placement::operator SdaiAxis2_placement_2dH()
{
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
      return ((SdaiAxis2_placement_2dH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiAxis2_placement::operator SdaiAxis2_placement_3dH()
{
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
      return ((SdaiAxis2_placement_3dH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiDirectionH 
SdaiAxis2_placement::Axis() const 
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3dH) _stepentityh) ->Axis();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiAxis2_placement::Axis (SdaiDirectionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3dH) _stepentityh) ->Axis( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiDirectionH 
SdaiAxis2_placement::Ref_direction() const 
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d ) 
	//  AXIS2_PLACEMENT_2D
	return ((SdaiAxis2_placement_2dH) _stepentityh) ->Ref_direction();
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3dH) _stepentityh) ->Ref_direction();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiAxis2_placement::Ref_direction (SdaiDirectionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d ) 
	//  AXIS2_PLACEMENT_2D
	{  ((SdaiAxis2_placement_2dH) _stepentityh) ->Ref_direction( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3dH) _stepentityh) ->Ref_direction( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiCartesian_pointH 
SdaiAxis2_placement::Location() const 
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d ) 
	//  AXIS2_PLACEMENT_2D
	return ((SdaiAxis2_placement_2dH) _stepentityh) ->Location();
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3dH) _stepentityh) ->Location();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiAxis2_placement::Location (SdaiCartesian_pointH x)
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d ) 
	//  AXIS2_PLACEMENT_2D
	{  ((SdaiAxis2_placement_2dH) _stepentityh) ->Location( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3dH) _stepentityh) ->Location( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiAxis2_placement::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d ) 
	//  AXIS2_PLACEMENT_2D
	return ((SdaiAxis2_placement_2dH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	return ((SdaiAxis2_placement_3dH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiAxis2_placement::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d ) 
	//  AXIS2_PLACEMENT_2D
	{  ((SdaiAxis2_placement_2dH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d ) 
	//  AXIS2_PLACEMENT_3D
	{  ((SdaiAxis2_placement_3dH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiAxis2_placement& SdaiAxis2_placement::operator =( const SdaiAxis2_placement_2dH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_axis2_placement_2d);
   return *this;
}

SdaiAxis2_placement& SdaiAxis2_placement::operator =( const SdaiAxis2_placement_3dH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_axis2_placement_3d);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiAxis2_placement& SdaiAxis2_placement::operator =( const SdaiAxis2_placementH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiAxis2_placement::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
	_stepentityh = ((SdaiAxis2_placement&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
	_stepentityh = ((SdaiAxis2_placement&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiAxis2_placement::IsAxis2_placement_2d() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_2d )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiAxis2_placement::IsAxis2_placement_3d() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_axis2_placement_3d )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiAxis2_placement


//////////  SELECT TYPE specified_item

const TypeDescriptor * 
SdaiSpecified_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION
  if (se -> eDesc -> IsA (config_control_designe_product_definition))
  {  
	_stepentityh = (SdaiProduct_definitionH) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  SHAPE_ASPECT
  if (se -> eDesc -> IsA (config_control_designe_shape_aspect))
  {  
	_stepentityh = (SdaiShape_aspectH) se;
	return SetUnderlyingType (config_control_designe_shape_aspect);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiSpecified_item::NewSelect ()
{
  SdaiSpecified_item * tmp = new SdaiSpecified_item ();
  return tmp;
}
// STEP Part 21

void
SdaiSpecified_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_shape_aspect)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiSpecified_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_shape_aspect)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiSpecified_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiSpecified_item::SdaiSpecified_item()
  : SdaiSelect (config_control_designt_specified_item)
{
   nullify();
}

	//  part 1
SdaiSpecified_item::SdaiSpecified_item( const SdaiProduct_definitionH& o )
  : SdaiSelect (config_control_designt_specified_item, config_control_designe_product_definition )
{
   _stepentityh = o;
}

SdaiSpecified_item::SdaiSpecified_item( const SdaiShape_aspectH& o )
  : SdaiSelect (config_control_designt_specified_item, config_control_designe_shape_aspect )
{
   _stepentityh = o;
}

SdaiSpecified_item::~SdaiSpecified_item()
{
}


	//  part 2
SdaiSpecified_item::operator SdaiProduct_definitionH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definitionH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiSpecified_item::operator SdaiShape_aspectH()
{
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return ((SdaiShape_aspectH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const LOGICAL 
SdaiSpecified_item::Product_definitional() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Product_definitional();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return (LOGICAL) NULL;
}


void 
SdaiSpecified_item::Product_definitional (LOGICAL x)
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Product_definitional( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_shapeH 
SdaiSpecified_item::Of_shape() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Of_shape();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSpecified_item::Of_shape (SdaiProduct_definition_shapeH x)
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Of_shape( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiSpecified_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSpecified_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_contextH 
SdaiSpecified_item::Frame_of_reference() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSpecified_item::Frame_of_reference (SdaiProduct_definition_contextH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_formationH 
SdaiSpecified_item::Formation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Formation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSpecified_item::Formation (SdaiProduct_definition_formationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Formation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiSpecified_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	return ((SdaiShape_aspectH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSpecified_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_shape_aspect ) 
	//  SHAPE_ASPECT
	{  ((SdaiShape_aspectH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiSpecified_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSpecified_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiSpecified_item& SdaiSpecified_item::operator =( const SdaiProduct_definitionH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiSpecified_item& SdaiSpecified_item::operator =( const SdaiShape_aspectH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_shape_aspect);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiSpecified_item& SdaiSpecified_item::operator =( const SdaiSpecified_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiSpecified_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh = ((SdaiSpecified_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_shape_aspect )
	_stepentityh = ((SdaiSpecified_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiSpecified_item::IsProduct_definition() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiSpecified_item::IsShape_aspect() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_shape_aspect )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiSpecified_item


//////////  SELECT TYPE measure_value

const TypeDescriptor * 
SdaiMeasure_value::AssignEntity (STEPentity * se)
{
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiMeasure_value::NewSelect ()
{
  SdaiMeasure_value * tmp = new SdaiMeasure_value ();
  return tmp;
}
// STEP Part 21

void
SdaiMeasure_value::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designt_area_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_context_dependent_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_count_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_descriptive_measure)
	_sdaistring.STEPwrite (out);
  else    if (CurrentUnderlyingType () == config_control_designt_length_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_mass_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_plane_angle_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_parameter_value)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_positive_length_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_solid_angle_measure)
	out <<  _sdaireal;
  else    if (CurrentUnderlyingType () == config_control_designt_volume_measure)
	out <<  _sdaireal;
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiMeasure_value::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designt_area_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_context_dependent_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_count_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_descriptive_measure)   {
	_sdaistring.STEPread (in, &_error);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_length_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_mass_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_plane_angle_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_parameter_value)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_positive_length_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_solid_angle_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  if (CurrentUnderlyingType () == config_control_designt_volume_measure)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiMeasure_value::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  case STRING_TYPE :  
	return _sdaistring.StrToVal (str);
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiMeasure_value::SdaiMeasure_value()
  : SdaiSelect (config_control_designt_measure_value)
{
   nullify();
}

	//  part 1
SdaiMeasure_value::SdaiMeasure_value( const SdaiDescriptive_measure& o )
  : SdaiSelect (config_control_designt_measure_value, config_control_designt_descriptive_measure )
{
   _sdaistring = o;
}

SdaiMeasure_value::SdaiMeasure_value( const SdaiReal& o )
  : SdaiSelect (config_control_designt_measure_value, config_control_designt_context_dependent_measure )
{
   _sdaireal = o;
//  NOTE:  Underlying type defaults to config_control_designt_context_dependent_measure instead of NULL
}

SdaiMeasure_value::~SdaiMeasure_value()
{
}


	//  part 2
SdaiMeasure_value::operator SdaiDescriptive_measure()
{
   if( CurrentUnderlyingType () == config_control_designt_descriptive_measure )
      return  _sdaistring;

  severity( SEVERITY_WARNING );
  Error( "Underlying type is not SdaiDescriptive_measure" );

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiMeasure_value::operator SdaiReal()
{
   if( CurrentUnderlyingType () == config_control_designt_area_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_count_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_length_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_mass_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_positive_length_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
      return  _sdaireal;
   if( CurrentUnderlyingType () == config_control_designt_volume_measure )
      return  _sdaireal;

  severity( SEVERITY_WARNING );
  Error( "Underlying type is not SdaiReal" );

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

	//  part 4
SdaiMeasure_value& SdaiMeasure_value::operator =( const SdaiDescriptive_measure& o )
{
  nullify ();
   _sdaistring = o;
   SetUnderlyingType (config_control_designt_descriptive_measure);
   return *this;
}

SdaiMeasure_value& SdaiMeasure_value::operator =( const SdaiReal& o )
{
   _sdaireal = o;
  underlying_type = 0; // MUST BE SET BY USER 
//	discriminator = UNSET
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiMeasure_value& SdaiMeasure_value::operator =( const SdaiMeasure_valueH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designt_area_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_count_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_descriptive_measure )
	_sdaistring =  o -> _sdaistring;
   if( o -> CurrentUnderlyingType () == config_control_designt_length_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_mass_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_parameter_value )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_positive_length_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
      _sdaireal = o -> _sdaireal;
   if( o -> CurrentUnderlyingType () == config_control_designt_volume_measure )
      _sdaireal = o -> _sdaireal;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiMeasure_value::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designt_area_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_count_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_descriptive_measure )
	_sdaistring = ((SdaiMeasure_value&) o)._sdaistring;
   if( o.CurrentUnderlyingType () == config_control_designt_length_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_mass_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_parameter_value )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_positive_length_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   if( o.CurrentUnderlyingType () == config_control_designt_volume_measure )
	_sdaireal = ((SdaiMeasure_value&) o)._sdaireal;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiMeasure_value::IsArea_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_area_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsContext_dependent_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_context_dependent_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsCount_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_count_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsDescriptive_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_descriptive_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsLength_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_length_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsMass_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_mass_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsPlane_angle_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_plane_angle_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsParameter_value() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsPositive_length_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_positive_length_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsPositive_plane_angle_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_positive_plane_angle_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsSolid_angle_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_solid_angle_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiMeasure_value::IsVolume_measure() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_volume_measure )
      return sdaiTRUE;
   return sdaiFALSE;
}


	//  part 7
const TypeDescriptor * 
SdaiMeasure_value::SetUnderlyingType (const TypeDescriptor * td)
{
  return SdaiSelect::SetUnderlyingType (td);
}
//////////  END SELECT TYPE SdaiMeasure_value


//////////  SELECT TYPE person_organization_select

const TypeDescriptor * 
SdaiPerson_organization_select::AssignEntity (STEPentity * se)
{
  //  PERSON_AND_ORGANIZATION
  if (se -> eDesc -> IsA (config_control_designe_person_and_organization))
  {  
	_stepentityh = (SdaiPerson_and_organizationH) se;
	return SetUnderlyingType (config_control_designe_person_and_organization);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiPerson_organization_select::NewSelect ()
{
  SdaiPerson_organization_select * tmp = new SdaiPerson_organization_select ();
  return tmp;
}
// STEP Part 21

void
SdaiPerson_organization_select::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_person_and_organization)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiPerson_organization_select::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_person_and_organization)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiPerson_organization_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiPerson_organization_select::SdaiPerson_organization_select()
  : SdaiSelect (config_control_designt_person_organization_select)
{
   nullify();
}

	//  part 1
SdaiPerson_organization_select::SdaiPerson_organization_select( const SdaiPerson_and_organizationH& o )
  : SdaiSelect (config_control_designt_person_organization_select, config_control_designe_person_and_organization )
{
   _stepentityh = o;
}

SdaiPerson_organization_select::~SdaiPerson_organization_select()
{
}


	//  part 2
SdaiPerson_organization_select::operator SdaiPerson_and_organizationH()
{
   if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
      return ((SdaiPerson_and_organizationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiOrganizationH 
SdaiPerson_organization_select::The_organization() const 
{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization ) 
	//  PERSON_AND_ORGANIZATION
	return ((SdaiPerson_and_organizationH) _stepentityh) ->The_organization();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_select::The_organization (SdaiOrganizationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization ) 
	//  PERSON_AND_ORGANIZATION
	{  ((SdaiPerson_and_organizationH) _stepentityh) ->The_organization( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiPersonH 
SdaiPerson_organization_select::The_person() const 
{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization ) 
	//  PERSON_AND_ORGANIZATION
	return ((SdaiPerson_and_organizationH) _stepentityh) ->The_person();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_select::The_person (SdaiPersonH x)
{
  if( CurrentUnderlyingType () == config_control_designe_person_and_organization ) 
	//  PERSON_AND_ORGANIZATION
	{  ((SdaiPerson_and_organizationH) _stepentityh) ->The_person( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiPerson_organization_select& SdaiPerson_organization_select::operator =( const SdaiPerson_and_organizationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_person_and_organization);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiPerson_organization_select& SdaiPerson_organization_select::operator =( const SdaiPerson_organization_selectH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_person_and_organization )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiPerson_organization_select::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_person_and_organization )
	_stepentityh = ((SdaiPerson_organization_select&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiPerson_organization_select::IsPerson_and_organization() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_person_and_organization )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiPerson_organization_select


//////////  SELECT TYPE pcurve_or_surface

const TypeDescriptor * 
SdaiPcurve_or_surface::AssignEntity (STEPentity * se)
{
  //  PCURVE
  if (se -> eDesc -> IsA (config_control_designe_pcurve))
  {  
	_stepentityh = (SdaiPcurveH) se;
	return SetUnderlyingType (config_control_designe_pcurve);
  }
  //  SURFACE
  if (se -> eDesc -> IsA (config_control_designe_surface))
  {  
	_stepentityh = (SdaiSurfaceH) se;
	return SetUnderlyingType (config_control_designe_surface);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiPcurve_or_surface::NewSelect ()
{
  SdaiPcurve_or_surface * tmp = new SdaiPcurve_or_surface ();
  return tmp;
}
// STEP Part 21

void
SdaiPcurve_or_surface::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_pcurve)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_surface)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiPcurve_or_surface::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_pcurve)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_surface)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiPcurve_or_surface::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiPcurve_or_surface::SdaiPcurve_or_surface()
  : SdaiSelect (config_control_designt_pcurve_or_surface)
{
   nullify();
}

	//  part 1
SdaiPcurve_or_surface::SdaiPcurve_or_surface( const SdaiPcurveH& o )
  : SdaiSelect (config_control_designt_pcurve_or_surface, config_control_designe_pcurve )
{
   _stepentityh = o;
}

SdaiPcurve_or_surface::SdaiPcurve_or_surface( const SdaiSurfaceH& o )
  : SdaiSelect (config_control_designt_pcurve_or_surface, config_control_designe_surface )
{
   _stepentityh = o;
}

SdaiPcurve_or_surface::~SdaiPcurve_or_surface()
{
}


	//  part 2
SdaiPcurve_or_surface::operator SdaiPcurveH()
{
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return ((SdaiPcurveH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPcurve_or_surface::operator SdaiSurfaceH()
{
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return ((SdaiSurfaceH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiDefinitional_representationH 
SdaiPcurve_or_surface::Reference_to_curve() const 
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	return ((SdaiPcurveH) _stepentityh) ->Reference_to_curve();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPcurve_or_surface::Reference_to_curve (SdaiDefinitional_representationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	{  ((SdaiPcurveH) _stepentityh) ->Reference_to_curve( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiSurfaceH 
SdaiPcurve_or_surface::Basis_surface() const 
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	return ((SdaiPcurveH) _stepentityh) ->Basis_surface();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPcurve_or_surface::Basis_surface (SdaiSurfaceH x)
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	{  ((SdaiPcurveH) _stepentityh) ->Basis_surface( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiPcurve_or_surface::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	return ((SdaiPcurveH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_surface ) 
	//  SURFACE
	return ((SdaiSurfaceH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPcurve_or_surface::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	{  ((SdaiPcurveH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_surface ) 
	//  SURFACE
	{  ((SdaiSurfaceH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiPcurve_or_surface& SdaiPcurve_or_surface::operator =( const SdaiPcurveH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_pcurve);
   return *this;
}

SdaiPcurve_or_surface& SdaiPcurve_or_surface::operator =( const SdaiSurfaceH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_surface);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiPcurve_or_surface& SdaiPcurve_or_surface::operator =( const SdaiPcurve_or_surfaceH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_pcurve )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_surface )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiPcurve_or_surface::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_pcurve )
	_stepentityh = ((SdaiPcurve_or_surface&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_surface )
	_stepentityh = ((SdaiPcurve_or_surface&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiPcurve_or_surface::IsPcurve() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPcurve_or_surface::IsSurface() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiPcurve_or_surface


//////////  SELECT TYPE classified_item

const TypeDescriptor * 
SdaiClassified_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> eDesc -> IsA (config_control_designe_product_definition_formation))
  {  
	_stepentityh = (SdaiProduct_definition_formationH) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  //  ASSEMBLY_COMPONENT_USAGE
  if (se -> eDesc -> IsA (config_control_designe_assembly_component_usage))
  {  
	_stepentityh = (SdaiAssembly_component_usageH) se;
	return SetUnderlyingType (config_control_designe_assembly_component_usage);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiClassified_item::NewSelect ()
{
  SdaiClassified_item * tmp = new SdaiClassified_item ();
  return tmp;
}
// STEP Part 21

void
SdaiClassified_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_assembly_component_usage)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiClassified_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_assembly_component_usage)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiClassified_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiClassified_item::SdaiClassified_item()
  : SdaiSelect (config_control_designt_classified_item)
{
   nullify();
}

	//  part 1
SdaiClassified_item::SdaiClassified_item( const SdaiProduct_definition_formationH& o )
  : SdaiSelect (config_control_designt_classified_item, config_control_designe_product_definition_formation )
{
   _stepentityh = o;
}

SdaiClassified_item::SdaiClassified_item( const SdaiAssembly_component_usageH& o )
  : SdaiSelect (config_control_designt_classified_item, config_control_designe_assembly_component_usage )
{
   _stepentityh = o;
}

SdaiClassified_item::~SdaiClassified_item()
{
}


	//  part 2
SdaiClassified_item::operator SdaiProduct_definition_formationH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiClassified_item::operator SdaiAssembly_component_usageH()
{
   if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
      return ((SdaiAssembly_component_usageH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiIdentifier 
SdaiClassified_item::Reference_designator() const
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usageH) _stepentityh) ->Reference_designator();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiClassified_item::Reference_designator (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usageH) _stepentityh) ->Reference_designator( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definitionH 
SdaiClassified_item::Related_product_definition() const 
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usageH) _stepentityh) ->Related_product_definition();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiClassified_item::Related_product_definition (SdaiProduct_definitionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usageH) _stepentityh) ->Related_product_definition( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definitionH 
SdaiClassified_item::Relating_product_definition() const 
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usageH) _stepentityh) ->Relating_product_definition();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiClassified_item::Relating_product_definition (SdaiProduct_definitionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usageH) _stepentityh) ->Relating_product_definition( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiClassified_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usageH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiClassified_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usageH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProductH 
SdaiClassified_item::Of_product() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiClassified_item::Of_product (SdaiProductH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiClassified_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usageH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiClassified_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usageH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiClassified_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	return ((SdaiAssembly_component_usageH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiClassified_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage ) 
	//  ASSEMBLY_COMPONENT_USAGE
	{  ((SdaiAssembly_component_usageH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiClassified_item& SdaiClassified_item::operator =( const SdaiProduct_definition_formationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}

SdaiClassified_item& SdaiClassified_item::operator =( const SdaiAssembly_component_usageH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_assembly_component_usage);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiClassified_item& SdaiClassified_item::operator =( const SdaiClassified_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiClassified_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh = ((SdaiClassified_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
	_stepentityh = ((SdaiClassified_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiClassified_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiClassified_item::IsAssembly_component_usage() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_assembly_component_usage )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiClassified_item


//////////  SELECT TYPE vector_or_direction

const TypeDescriptor * 
SdaiVector_or_direction::AssignEntity (STEPentity * se)
{
  //  VECTOR
  if (se -> eDesc -> IsA (config_control_designe_vector))
  {  
	_stepentityh = (SdaiVectorH) se;
	return SetUnderlyingType (config_control_designe_vector);
  }
  //  DIRECTION
  if (se -> eDesc -> IsA (config_control_designe_direction))
  {  
	_stepentityh = (SdaiDirectionH) se;
	return SetUnderlyingType (config_control_designe_direction);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiVector_or_direction::NewSelect ()
{
  SdaiVector_or_direction * tmp = new SdaiVector_or_direction ();
  return tmp;
}
// STEP Part 21

void
SdaiVector_or_direction::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_vector)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_direction)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiVector_or_direction::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_vector)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_direction)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiVector_or_direction::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiVector_or_direction::SdaiVector_or_direction()
  : SdaiSelect (config_control_designt_vector_or_direction)
{
   nullify();
}

	//  part 1
SdaiVector_or_direction::SdaiVector_or_direction( const SdaiVectorH& o )
  : SdaiSelect (config_control_designt_vector_or_direction, config_control_designe_vector )
{
   _stepentityh = o;
}

SdaiVector_or_direction::SdaiVector_or_direction( const SdaiDirectionH& o )
  : SdaiSelect (config_control_designt_vector_or_direction, config_control_designe_direction )
{
   _stepentityh = o;
}

SdaiVector_or_direction::~SdaiVector_or_direction()
{
}


	//  part 2
SdaiVector_or_direction::operator SdaiVectorH()
{
   if( CurrentUnderlyingType () == config_control_designe_vector )
      return ((SdaiVectorH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiVector_or_direction::operator SdaiDirectionH()
{
   if( CurrentUnderlyingType () == config_control_designe_direction )
      return ((SdaiDirectionH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const RealAggregateH 
SdaiVector_or_direction::Direction_ratios() const 
{
  if( CurrentUnderlyingType () == config_control_designe_direction ) 
	//  DIRECTION
	return ((SdaiDirectionH) _stepentityh) ->Direction_ratios();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiVector_or_direction::Direction_ratios (RealAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_direction ) 
	//  DIRECTION
	{  ((SdaiDirectionH) _stepentityh) ->Direction_ratios( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLength_measure 
SdaiVector_or_direction::Magnitude() const 
{
  if( CurrentUnderlyingType () == config_control_designe_vector ) 
	//  VECTOR
	return ((SdaiVectorH) _stepentityh) ->Magnitude();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiVector_or_direction::Magnitude (SdaiLength_measure x)
{
  if( CurrentUnderlyingType () == config_control_designe_vector ) 
	//  VECTOR
	{  ((SdaiVectorH) _stepentityh) ->Magnitude( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiDirectionH 
SdaiVector_or_direction::Orientation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_vector ) 
	//  VECTOR
	return ((SdaiVectorH) _stepentityh) ->Orientation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiVector_or_direction::Orientation (SdaiDirectionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_vector ) 
	//  VECTOR
	{  ((SdaiVectorH) _stepentityh) ->Orientation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiVector_or_direction::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_vector ) 
	//  VECTOR
	return ((SdaiVectorH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_direction ) 
	//  DIRECTION
	return ((SdaiDirectionH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiVector_or_direction::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_vector ) 
	//  VECTOR
	{  ((SdaiVectorH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_direction ) 
	//  DIRECTION
	{  ((SdaiDirectionH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiVector_or_direction& SdaiVector_or_direction::operator =( const SdaiVectorH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_vector);
   return *this;
}

SdaiVector_or_direction& SdaiVector_or_direction::operator =( const SdaiDirectionH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_direction);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiVector_or_direction& SdaiVector_or_direction::operator =( const SdaiVector_or_directionH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_vector )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_direction )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiVector_or_direction::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_vector )
	_stepentityh = ((SdaiVector_or_direction&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_direction )
	_stepentityh = ((SdaiVector_or_direction&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiVector_or_direction::IsVector() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_vector )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiVector_or_direction::IsDirection() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_direction )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiVector_or_direction


//////////  SELECT TYPE wireframe_model

const TypeDescriptor * 
SdaiWireframe_model::AssignEntity (STEPentity * se)
{
  //  SHELL_BASED_WIREFRAME_MODEL
  if (se -> eDesc -> IsA (config_control_designe_shell_based_wireframe_model))
  {  
	_stepentityh = (SdaiShell_based_wireframe_modelH) se;
	return SetUnderlyingType (config_control_designe_shell_based_wireframe_model);
  }
  //  EDGE_BASED_WIREFRAME_MODEL
  if (se -> eDesc -> IsA (config_control_designe_edge_based_wireframe_model))
  {  
	_stepentityh = (SdaiEdge_based_wireframe_modelH) se;
	return SetUnderlyingType (config_control_designe_edge_based_wireframe_model);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiWireframe_model::NewSelect ()
{
  SdaiWireframe_model * tmp = new SdaiWireframe_model ();
  return tmp;
}
// STEP Part 21

void
SdaiWireframe_model::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiWireframe_model::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiWireframe_model::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiWireframe_model::SdaiWireframe_model()
  : SdaiSelect (config_control_designt_wireframe_model)
{
   nullify();
}

	//  part 1
SdaiWireframe_model::SdaiWireframe_model( const SdaiShell_based_wireframe_modelH& o )
  : SdaiSelect (config_control_designt_wireframe_model, config_control_designe_shell_based_wireframe_model )
{
   _stepentityh = o;
}

SdaiWireframe_model::SdaiWireframe_model( const SdaiEdge_based_wireframe_modelH& o )
  : SdaiSelect (config_control_designt_wireframe_model, config_control_designe_edge_based_wireframe_model )
{
   _stepentityh = o;
}

SdaiWireframe_model::~SdaiWireframe_model()
{
}


	//  part 2
SdaiWireframe_model::operator SdaiShell_based_wireframe_modelH()
{
   if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
      return ((SdaiShell_based_wireframe_modelH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiWireframe_model::operator SdaiEdge_based_wireframe_modelH()
{
   if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
      return ((SdaiEdge_based_wireframe_modelH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const EntityAggregateH 
SdaiWireframe_model::Ebwm_boundary() const 
{
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model ) 
	//  EDGE_BASED_WIREFRAME_MODEL
	return ((SdaiEdge_based_wireframe_modelH) _stepentityh) ->Ebwm_boundary();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiWireframe_model::Ebwm_boundary (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model ) 
	//  EDGE_BASED_WIREFRAME_MODEL
	{  ((SdaiEdge_based_wireframe_modelH) _stepentityh) ->Ebwm_boundary( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiShellsH 
SdaiWireframe_model::Sbwm_boundary() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model ) 
	//  SHELL_BASED_WIREFRAME_MODEL
	return ((SdaiShell_based_wireframe_modelH) _stepentityh) ->Sbwm_boundary();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiWireframe_model::Sbwm_boundary (SdaiShellsH x)
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model ) 
	//  SHELL_BASED_WIREFRAME_MODEL
	{  ((SdaiShell_based_wireframe_modelH) _stepentityh) ->Sbwm_boundary( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiWireframe_model::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model ) 
	//  SHELL_BASED_WIREFRAME_MODEL
	return ((SdaiShell_based_wireframe_modelH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model ) 
	//  EDGE_BASED_WIREFRAME_MODEL
	return ((SdaiEdge_based_wireframe_modelH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiWireframe_model::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model ) 
	//  SHELL_BASED_WIREFRAME_MODEL
	{  ((SdaiShell_based_wireframe_modelH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model ) 
	//  EDGE_BASED_WIREFRAME_MODEL
	{  ((SdaiEdge_based_wireframe_modelH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiWireframe_model& SdaiWireframe_model::operator =( const SdaiShell_based_wireframe_modelH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_shell_based_wireframe_model);
   return *this;
}

SdaiWireframe_model& SdaiWireframe_model::operator =( const SdaiEdge_based_wireframe_modelH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_edge_based_wireframe_model);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiWireframe_model& SdaiWireframe_model::operator =( const SdaiWireframe_modelH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiWireframe_model::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
	_stepentityh = ((SdaiWireframe_model&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
	_stepentityh = ((SdaiWireframe_model&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiWireframe_model::IsShell_based_wireframe_model() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_shell_based_wireframe_model )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiWireframe_model::IsEdge_based_wireframe_model() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_edge_based_wireframe_model )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiWireframe_model


//////////  SELECT TYPE geometric_set_select

const TypeDescriptor * 
SdaiGeometric_set_select::AssignEntity (STEPentity * se)
{
  //  POINT
  if (se -> eDesc -> IsA (config_control_designe_point))
  {  
	_stepentityh = (SdaiPointH) se;
	return SetUnderlyingType (config_control_designe_point);
  }
  //  CURVE
  if (se -> eDesc -> IsA (config_control_designe_curve))
  {  
	_stepentityh = (SdaiCurveH) se;
	return SetUnderlyingType (config_control_designe_curve);
  }
  //  SURFACE
  if (se -> eDesc -> IsA (config_control_designe_surface))
  {  
	_stepentityh = (SdaiSurfaceH) se;
	return SetUnderlyingType (config_control_designe_surface);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiGeometric_set_select::NewSelect ()
{
  SdaiGeometric_set_select * tmp = new SdaiGeometric_set_select ();
  return tmp;
}
// STEP Part 21

void
SdaiGeometric_set_select::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_point)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_curve)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_surface)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiGeometric_set_select::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_point)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_curve)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_surface)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiGeometric_set_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiGeometric_set_select::SdaiGeometric_set_select()
  : SdaiSelect (config_control_designt_geometric_set_select)
{
   nullify();
}

	//  part 1
SdaiGeometric_set_select::SdaiGeometric_set_select( const SdaiPointH& o )
  : SdaiSelect (config_control_designt_geometric_set_select, config_control_designe_point )
{
   _stepentityh = o;
}

SdaiGeometric_set_select::SdaiGeometric_set_select( const SdaiCurveH& o )
  : SdaiSelect (config_control_designt_geometric_set_select, config_control_designe_curve )
{
   _stepentityh = o;
}

SdaiGeometric_set_select::SdaiGeometric_set_select( const SdaiSurfaceH& o )
  : SdaiSelect (config_control_designt_geometric_set_select, config_control_designe_surface )
{
   _stepentityh = o;
}

SdaiGeometric_set_select::~SdaiGeometric_set_select()
{
}


	//  part 2
SdaiGeometric_set_select::operator SdaiPointH()
{
   if( CurrentUnderlyingType () == config_control_designe_point )
      return ((SdaiPointH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiGeometric_set_select::operator SdaiCurveH()
{
   if( CurrentUnderlyingType () == config_control_designe_curve )
      return ((SdaiCurveH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiGeometric_set_select::operator SdaiSurfaceH()
{
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return ((SdaiSurfaceH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiLabel 
SdaiGeometric_set_select::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_point ) 
	//  POINT
	return ((SdaiPointH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_curve ) 
	//  CURVE
	return ((SdaiCurveH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_surface ) 
	//  SURFACE
	return ((SdaiSurfaceH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiGeometric_set_select::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_point ) 
	//  POINT
	{  ((SdaiPointH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_curve ) 
	//  CURVE
	{  ((SdaiCurveH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_surface ) 
	//  SURFACE
	{  ((SdaiSurfaceH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiPointH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_point);
   return *this;
}

SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiCurveH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_curve);
   return *this;
}

SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiSurfaceH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_surface);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiGeometric_set_select& SdaiGeometric_set_select::operator =( const SdaiGeometric_set_selectH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_point )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_curve )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_surface )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiGeometric_set_select::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_point )
	_stepentityh = ((SdaiGeometric_set_select&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_curve )
	_stepentityh = ((SdaiGeometric_set_select&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_surface )
	_stepentityh = ((SdaiGeometric_set_select&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiGeometric_set_select::IsPoint() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_point )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiGeometric_set_select::IsCurve() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_curve )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiGeometric_set_select::IsSurface() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_surface )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiGeometric_set_select


//////////  SELECT TYPE start_request_item

const TypeDescriptor * 
SdaiStart_request_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> eDesc -> IsA (config_control_designe_product_definition_formation))
  {  
	_stepentityh = (SdaiProduct_definition_formationH) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiStart_request_item::NewSelect ()
{
  SdaiStart_request_item * tmp = new SdaiStart_request_item ();
  return tmp;
}
// STEP Part 21

void
SdaiStart_request_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiStart_request_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiStart_request_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiStart_request_item::SdaiStart_request_item()
  : SdaiSelect (config_control_designt_start_request_item)
{
   nullify();
}

	//  part 1
SdaiStart_request_item::SdaiStart_request_item( const SdaiProduct_definition_formationH& o )
  : SdaiSelect (config_control_designt_start_request_item, config_control_designe_product_definition_formation )
{
   _stepentityh = o;
}

SdaiStart_request_item::~SdaiStart_request_item()
{
}


	//  part 2
SdaiStart_request_item::operator SdaiProduct_definition_formationH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiProductH 
SdaiStart_request_item::Of_product() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiStart_request_item::Of_product (SdaiProductH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiStart_request_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiStart_request_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiStart_request_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiStart_request_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiStart_request_item& SdaiStart_request_item::operator =( const SdaiProduct_definition_formationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiStart_request_item& SdaiStart_request_item::operator =( const SdaiStart_request_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiStart_request_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh = ((SdaiStart_request_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiStart_request_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiStart_request_item


//////////  SELECT TYPE person_organization_item

const TypeDescriptor * 
SdaiPerson_organization_item::AssignEntity (STEPentity * se)
{
  //  CHANGE
  if (se -> eDesc -> IsA (config_control_designe_change))
  {  
	_stepentityh = (SdaiChangeH) se;
	return SetUnderlyingType (config_control_designe_change);
  }
  //  START_WORK
  if (se -> eDesc -> IsA (config_control_designe_start_work))
  {  
	_stepentityh = (SdaiStart_workH) se;
	return SetUnderlyingType (config_control_designe_start_work);
  }
  //  CHANGE_REQUEST
  if (se -> eDesc -> IsA (config_control_designe_change_request))
  {  
	_stepentityh = (SdaiChange_requestH) se;
	return SetUnderlyingType (config_control_designe_change_request);
  }
  //  START_REQUEST
  if (se -> eDesc -> IsA (config_control_designe_start_request))
  {  
	_stepentityh = (SdaiStart_requestH) se;
	return SetUnderlyingType (config_control_designe_start_request);
  }
  //  CONFIGURATION_ITEM
  if (se -> eDesc -> IsA (config_control_designe_configuration_item))
  {  
	_stepentityh = (SdaiConfiguration_itemH) se;
	return SetUnderlyingType (config_control_designe_configuration_item);
  }
  //  PRODUCT
  if (se -> eDesc -> IsA (config_control_designe_product))
  {  
	_stepentityh = (SdaiProductH) se;
	return SetUnderlyingType (config_control_designe_product);
  }
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> eDesc -> IsA (config_control_designe_product_definition_formation))
  {  
	_stepentityh = (SdaiProduct_definition_formationH) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  //  PRODUCT_DEFINITION
  if (se -> eDesc -> IsA (config_control_designe_product_definition))
  {  
	_stepentityh = (SdaiProduct_definitionH) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  CONTRACT
  if (se -> eDesc -> IsA (config_control_designe_contract))
  {  
	_stepentityh = (SdaiContractH) se;
	return SetUnderlyingType (config_control_designe_contract);
  }
  //  SECURITY_CLASSIFICATION
  if (se -> eDesc -> IsA (config_control_designe_security_classification))
  {  
	_stepentityh = (SdaiSecurity_classificationH) se;
	return SetUnderlyingType (config_control_designe_security_classification);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiPerson_organization_item::NewSelect ()
{
  SdaiPerson_organization_item * tmp = new SdaiPerson_organization_item ();
  return tmp;
}
// STEP Part 21

void
SdaiPerson_organization_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_change)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_start_work)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_change_request)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_start_request)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_configuration_item)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_product)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_contract)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_security_classification)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiPerson_organization_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_change)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_start_work)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_change_request)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_start_request)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_configuration_item)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_product)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_contract)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_security_classification)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiPerson_organization_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiPerson_organization_item::SdaiPerson_organization_item()
  : SdaiSelect (config_control_designt_person_organization_item)
{
   nullify();
}

	//  part 1
SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiChangeH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_change )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiStart_workH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_start_work )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiChange_requestH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_change_request )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiStart_requestH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_start_request )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiConfiguration_itemH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_configuration_item )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiProductH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_product )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiProduct_definition_formationH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_product_definition_formation )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiProduct_definitionH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_product_definition )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiContractH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_contract )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::SdaiPerson_organization_item( const SdaiSecurity_classificationH& o )
  : SdaiSelect (config_control_designt_person_organization_item, config_control_designe_security_classification )
{
   _stepentityh = o;
}

SdaiPerson_organization_item::~SdaiPerson_organization_item()
{
}


	//  part 2
SdaiPerson_organization_item::operator SdaiChangeH()
{
   if( CurrentUnderlyingType () == config_control_designe_change )
      return ((SdaiChangeH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiStart_workH()
{
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return ((SdaiStart_workH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiChange_requestH()
{
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return ((SdaiChange_requestH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiStart_requestH()
{
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return ((SdaiStart_requestH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiConfiguration_itemH()
{
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return ((SdaiConfiguration_itemH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiProductH()
{
   if( CurrentUnderlyingType () == config_control_designe_product )
      return ((SdaiProductH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiProduct_definition_formationH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiProduct_definitionH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definitionH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiContractH()
{
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return ((SdaiContractH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiPerson_organization_item::operator SdaiSecurity_classificationH()
{
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return ((SdaiSecurity_classificationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiSecurity_classification_levelH 
SdaiPerson_organization_item::Security_level() const 
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Security_level();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Security_level (SdaiSecurity_classification_levelH x)
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Security_level( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiContract_typeH 
SdaiPerson_organization_item::Kind() const 
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Kind();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Kind (SdaiContract_typeH x)
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Kind( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_formationH 
SdaiPerson_organization_item::Formation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Formation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Formation (SdaiProduct_definition_formationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Formation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProductH 
SdaiPerson_organization_item::Of_product() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Of_product (SdaiProductH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const EntityAggregateH 
SdaiPerson_organization_item::Frame_of_reference() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	return ((SdaiProductH) _stepentityh) ->Frame_of_reference();
  //  PRODUCT_DEFINITION
	//  attribute access function has a different return type
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Frame_of_reference (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	{  ((SdaiProductH) _stepentityh) ->Frame_of_reference( x );
	  return;
	}
  //  for PRODUCT_DEFINITION  attribute access function has a different argument type

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiPerson_organization_item::Purpose() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Purpose();
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Purpose();
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Purpose();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Purpose (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Purpose( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Purpose( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Purpose( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_conceptH 
SdaiPerson_organization_item::Item_concept() const 
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Item_concept();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Item_concept (SdaiProduct_conceptH x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Item_concept( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiPerson_organization_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	return ((SdaiProductH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	{  ((SdaiProductH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiPerson_organization_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	return ((SdaiProductH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	{  ((SdaiProductH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiPerson_organization_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	return ((SdaiProductH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product ) 
	//  PRODUCT
	{  ((SdaiProductH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiVersioned_action_requestH 
SdaiPerson_organization_item::Assigned_action_request() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	return ((SdaiChange_requestH) _stepentityh) ->Assigned_action_request();
  if( CurrentUnderlyingType () == config_control_designe_start_request ) 
	//  START_REQUEST
	return ((SdaiStart_requestH) _stepentityh) ->Assigned_action_request();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Assigned_action_request (SdaiVersioned_action_requestH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	{  ((SdaiChange_requestH) _stepentityh) ->Assigned_action_request( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_request ) 
	//  START_REQUEST
	{  ((SdaiStart_requestH) _stepentityh) ->Assigned_action_request( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiWork_itemsH 
SdaiPerson_organization_item::Items() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	return ((SdaiChangeH) _stepentityh) ->Items();
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	return ((SdaiStart_workH) _stepentityh) ->Items();
  //  CHANGE_REQUEST
	//  attribute access function has a different return type
  //  START_REQUEST
	//  attribute access function has a different return type
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Items (SdaiWork_itemsH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	{  ((SdaiChangeH) _stepentityh) ->Items( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	{  ((SdaiStart_workH) _stepentityh) ->Items( x );
	  return;
	}
  //  for CHANGE_REQUEST  attribute access function has a different argument type
  //  for START_REQUEST  attribute access function has a different argument type

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiActionH 
SdaiPerson_organization_item::Assigned_action() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	return ((SdaiChangeH) _stepentityh) ->Assigned_action();
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	return ((SdaiStart_workH) _stepentityh) ->Assigned_action();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiPerson_organization_item::Assigned_action (SdaiActionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	{  ((SdaiChangeH) _stepentityh) ->Assigned_action( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	{  ((SdaiStart_workH) _stepentityh) ->Assigned_action( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiChangeH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_change);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiStart_workH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_start_work);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiChange_requestH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_change_request);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiStart_requestH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_start_request);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiConfiguration_itemH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_configuration_item);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiProductH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiProduct_definition_formationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiProduct_definitionH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiContractH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_contract);
   return *this;
}

SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiSecurity_classificationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_security_classification);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiPerson_organization_item& SdaiPerson_organization_item::operator =( const SdaiPerson_organization_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_change )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_start_work )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_change_request )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_start_request )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_configuration_item )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_product )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_contract )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_security_classification )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiPerson_organization_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_change )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_start_work )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_change_request )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_start_request )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_configuration_item )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_product )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_contract )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_security_classification )
	_stepentityh = ((SdaiPerson_organization_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiPerson_organization_item::IsChange() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_change )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsStart_work() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsChange_request() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsStart_request() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsConfiguration_item() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsProduct() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsProduct_definition() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsContract() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiPerson_organization_item::IsSecurity_classification() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiPerson_organization_item


//////////  SELECT TYPE date_time_item

const TypeDescriptor * 
SdaiDate_time_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION
  if (se -> eDesc -> IsA (config_control_designe_product_definition))
  {  
	_stepentityh = (SdaiProduct_definitionH) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  CHANGE_REQUEST
  if (se -> eDesc -> IsA (config_control_designe_change_request))
  {  
	_stepentityh = (SdaiChange_requestH) se;
	return SetUnderlyingType (config_control_designe_change_request);
  }
  //  START_REQUEST
  if (se -> eDesc -> IsA (config_control_designe_start_request))
  {  
	_stepentityh = (SdaiStart_requestH) se;
	return SetUnderlyingType (config_control_designe_start_request);
  }
  //  CHANGE
  if (se -> eDesc -> IsA (config_control_designe_change))
  {  
	_stepentityh = (SdaiChangeH) se;
	return SetUnderlyingType (config_control_designe_change);
  }
  //  START_WORK
  if (se -> eDesc -> IsA (config_control_designe_start_work))
  {  
	_stepentityh = (SdaiStart_workH) se;
	return SetUnderlyingType (config_control_designe_start_work);
  }
  //  APPROVAL_PERSON_ORGANIZATION
  if (se -> eDesc -> IsA (config_control_designe_approval_person_organization))
  {  
	_stepentityh = (SdaiApproval_person_organizationH) se;
	return SetUnderlyingType (config_control_designe_approval_person_organization);
  }
  //  CONTRACT
  if (se -> eDesc -> IsA (config_control_designe_contract))
  {  
	_stepentityh = (SdaiContractH) se;
	return SetUnderlyingType (config_control_designe_contract);
  }
  //  SECURITY_CLASSIFICATION
  if (se -> eDesc -> IsA (config_control_designe_security_classification))
  {  
	_stepentityh = (SdaiSecurity_classificationH) se;
	return SetUnderlyingType (config_control_designe_security_classification);
  }
  //  CERTIFICATION
  if (se -> eDesc -> IsA (config_control_designe_certification))
  {  
	_stepentityh = (SdaiCertificationH) se;
	return SetUnderlyingType (config_control_designe_certification);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiDate_time_item::NewSelect ()
{
  SdaiDate_time_item * tmp = new SdaiDate_time_item ();
  return tmp;
}
// STEP Part 21

void
SdaiDate_time_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_change_request)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_start_request)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_change)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_start_work)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_approval_person_organization)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_contract)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_security_classification)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_certification)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiDate_time_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_change_request)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_start_request)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_change)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_start_work)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_approval_person_organization)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_contract)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_security_classification)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_certification)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiDate_time_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiDate_time_item::SdaiDate_time_item()
  : SdaiSelect (config_control_designt_date_time_item)
{
   nullify();
}

	//  part 1
SdaiDate_time_item::SdaiDate_time_item( const SdaiProduct_definitionH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_product_definition )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiChange_requestH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_change_request )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiStart_requestH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_start_request )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiChangeH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_change )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiStart_workH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_start_work )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiApproval_person_organizationH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_approval_person_organization )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiContractH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_contract )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiSecurity_classificationH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_security_classification )
{
   _stepentityh = o;
}

SdaiDate_time_item::SdaiDate_time_item( const SdaiCertificationH& o )
  : SdaiSelect (config_control_designt_date_time_item, config_control_designe_certification )
{
   _stepentityh = o;
}

SdaiDate_time_item::~SdaiDate_time_item()
{
}


	//  part 2
SdaiDate_time_item::operator SdaiProduct_definitionH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definitionH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiChange_requestH()
{
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return ((SdaiChange_requestH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiStart_requestH()
{
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return ((SdaiStart_requestH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiChangeH()
{
   if( CurrentUnderlyingType () == config_control_designe_change )
      return ((SdaiChangeH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiStart_workH()
{
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return ((SdaiStart_workH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiApproval_person_organizationH()
{
   if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
      return ((SdaiApproval_person_organizationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiContractH()
{
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return ((SdaiContractH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiSecurity_classificationH()
{
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return ((SdaiSecurity_classificationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiDate_time_item::operator SdaiCertificationH()
{
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return ((SdaiCertificationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiSecurity_classification_levelH 
SdaiDate_time_item::Security_level() const 
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Security_level();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Security_level (SdaiSecurity_classification_levelH x)
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Security_level( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiContract_typeH 
SdaiDate_time_item::Kind() const 
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Kind();
  //  CERTIFICATION
	//  attribute access function has a different return type
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Kind (SdaiContract_typeH x)
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Kind( x );
	  return;
	}
  //  for CERTIFICATION  attribute access function has a different argument type

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiDate_time_item::Purpose() const
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Purpose();
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Purpose();
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	return ((SdaiCertificationH) _stepentityh) ->Purpose();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Purpose (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Purpose( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Purpose( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	{  ((SdaiCertificationH) _stepentityh) ->Purpose( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiDate_time_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	return ((SdaiCertificationH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	{  ((SdaiCertificationH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiApproval_roleH 
SdaiDate_time_item::Role() const 
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization ) 
	//  APPROVAL_PERSON_ORGANIZATION
	return ((SdaiApproval_person_organizationH) _stepentityh) ->Role();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Role (SdaiApproval_roleH x)
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization ) 
	//  APPROVAL_PERSON_ORGANIZATION
	{  ((SdaiApproval_person_organizationH) _stepentityh) ->Role( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiApprovalH 
SdaiDate_time_item::Authorized_approval() const 
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization ) 
	//  APPROVAL_PERSON_ORGANIZATION
	return ((SdaiApproval_person_organizationH) _stepentityh) ->Authorized_approval();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Authorized_approval (SdaiApprovalH x)
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization ) 
	//  APPROVAL_PERSON_ORGANIZATION
	{  ((SdaiApproval_person_organizationH) _stepentityh) ->Authorized_approval( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiPerson_organization_selectH 
SdaiDate_time_item::Person_organization() const 
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization ) 
	//  APPROVAL_PERSON_ORGANIZATION
	return ((SdaiApproval_person_organizationH) _stepentityh) ->Person_organization();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Person_organization (SdaiPerson_organization_selectH x)
{
  if( CurrentUnderlyingType () == config_control_designe_approval_person_organization ) 
	//  APPROVAL_PERSON_ORGANIZATION
	{  ((SdaiApproval_person_organizationH) _stepentityh) ->Person_organization( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiActionH 
SdaiDate_time_item::Assigned_action() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	return ((SdaiChangeH) _stepentityh) ->Assigned_action();
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	return ((SdaiStart_workH) _stepentityh) ->Assigned_action();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Assigned_action (SdaiActionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	{  ((SdaiChangeH) _stepentityh) ->Assigned_action( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	{  ((SdaiStart_workH) _stepentityh) ->Assigned_action( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiChange_request_itemsH 
SdaiDate_time_item::Items() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	return ((SdaiChange_requestH) _stepentityh) ->Items();
  //  START_REQUEST
	//  attribute access function has a different return type
  //  CHANGE
	//  attribute access function has a different return type
  //  START_WORK
	//  attribute access function has a different return type
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Items (SdaiChange_request_itemsH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	{  ((SdaiChange_requestH) _stepentityh) ->Items( x );
	  return;
	}
  //  for START_REQUEST  attribute access function has a different argument type
  //  for CHANGE  attribute access function has a different argument type
  //  for START_WORK  attribute access function has a different argument type

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiVersioned_action_requestH 
SdaiDate_time_item::Assigned_action_request() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	return ((SdaiChange_requestH) _stepentityh) ->Assigned_action_request();
  if( CurrentUnderlyingType () == config_control_designe_start_request ) 
	//  START_REQUEST
	return ((SdaiStart_requestH) _stepentityh) ->Assigned_action_request();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Assigned_action_request (SdaiVersioned_action_requestH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	{  ((SdaiChange_requestH) _stepentityh) ->Assigned_action_request( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_request ) 
	//  START_REQUEST
	{  ((SdaiStart_requestH) _stepentityh) ->Assigned_action_request( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_contextH 
SdaiDate_time_item::Frame_of_reference() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Frame_of_reference (SdaiProduct_definition_contextH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_formationH 
SdaiDate_time_item::Formation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Formation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Formation (SdaiProduct_definition_formationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Formation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiDate_time_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiDate_time_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiProduct_definitionH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiChange_requestH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_change_request);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiStart_requestH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_start_request);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiChangeH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_change);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiStart_workH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_start_work);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiApproval_person_organizationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_approval_person_organization);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiContractH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_contract);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiSecurity_classificationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_security_classification);
   return *this;
}

SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiCertificationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_certification);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiDate_time_item& SdaiDate_time_item::operator =( const SdaiDate_time_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_change_request )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_start_request )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_change )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_start_work )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_contract )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_security_classification )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_certification )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiDate_time_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_change_request )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_start_request )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_change )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_start_work )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_approval_person_organization )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_contract )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_security_classification )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_certification )
	_stepentityh = ((SdaiDate_time_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiDate_time_item::IsProduct_definition() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsChange_request() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsStart_request() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsChange() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_change )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsStart_work() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsApproval_person_organization() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_approval_person_organization )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsContract() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsSecurity_classification() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiDate_time_item::IsCertification() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiDate_time_item


//////////  SELECT TYPE shell

const TypeDescriptor * 
SdaiShell::AssignEntity (STEPentity * se)
{
  //  OPEN_SHELL
  if (se -> eDesc -> IsA (config_control_designe_open_shell))
  {  
	_stepentityh = (SdaiOpen_shellH) se;
	return SetUnderlyingType (config_control_designe_open_shell);
  }
  //  CLOSED_SHELL
  if (se -> eDesc -> IsA (config_control_designe_closed_shell))
  {  
	_stepentityh = (SdaiClosed_shellH) se;
	return SetUnderlyingType (config_control_designe_closed_shell);
  }
  //  VERTEX_SHELL
  if (se -> eDesc -> IsA (config_control_designe_vertex_shell))
  {  
	_stepentityh = (SdaiVertex_shellH) se;
	return SetUnderlyingType (config_control_designe_vertex_shell);
  }
  //  WIRE_SHELL
  if (se -> eDesc -> IsA (config_control_designe_wire_shell))
  {  
	_stepentityh = (SdaiWire_shellH) se;
	return SetUnderlyingType (config_control_designe_wire_shell);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiShell::NewSelect ()
{
  SdaiShell * tmp = new SdaiShell ();
  return tmp;
}
// STEP Part 21

void
SdaiShell::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_open_shell)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_closed_shell)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_vertex_shell)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_wire_shell)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiShell::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_open_shell)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_closed_shell)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_vertex_shell)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_wire_shell)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiShell::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiShell::SdaiShell()
  : SdaiSelect (config_control_designt_shell)
{
   nullify();
}

	//  part 1
SdaiShell::SdaiShell( const SdaiOpen_shellH& o )
  : SdaiSelect (config_control_designt_shell, config_control_designe_open_shell )
{
   _stepentityh = o;
}

SdaiShell::SdaiShell( const SdaiClosed_shellH& o )
  : SdaiSelect (config_control_designt_shell, config_control_designe_closed_shell )
{
   _stepentityh = o;
}

SdaiShell::SdaiShell( const SdaiVertex_shellH& o )
  : SdaiSelect (config_control_designt_shell, config_control_designe_vertex_shell )
{
   _stepentityh = o;
}

SdaiShell::SdaiShell( const SdaiWire_shellH& o )
  : SdaiSelect (config_control_designt_shell, config_control_designe_wire_shell )
{
   _stepentityh = o;
}

SdaiShell::~SdaiShell()
{
}


	//  part 2
SdaiShell::operator SdaiOpen_shellH()
{
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return ((SdaiOpen_shellH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShell::operator SdaiClosed_shellH()
{
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return ((SdaiClosed_shellH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShell::operator SdaiVertex_shellH()
{
   if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
      return ((SdaiVertex_shellH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiShell::operator SdaiWire_shellH()
{
   if( CurrentUnderlyingType () == config_control_designe_wire_shell )
      return ((SdaiWire_shellH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const EntityAggregateH 
SdaiShell::Wire_shell_extent() const 
{
  if( CurrentUnderlyingType () == config_control_designe_wire_shell ) 
	//  WIRE_SHELL
	return ((SdaiWire_shellH) _stepentityh) ->Wire_shell_extent();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShell::Wire_shell_extent (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_wire_shell ) 
	//  WIRE_SHELL
	{  ((SdaiWire_shellH) _stepentityh) ->Wire_shell_extent( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiVertex_loopH 
SdaiShell::Vertex_shell_extent() const 
{
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell ) 
	//  VERTEX_SHELL
	return ((SdaiVertex_shellH) _stepentityh) ->Vertex_shell_extent();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShell::Vertex_shell_extent (SdaiVertex_loopH x)
{
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell ) 
	//  VERTEX_SHELL
	{  ((SdaiVertex_shellH) _stepentityh) ->Vertex_shell_extent( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const EntityAggregateH 
SdaiShell::Cfs_faces() const 
{
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	return ((SdaiOpen_shellH) _stepentityh) ->Cfs_faces();
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	return ((SdaiClosed_shellH) _stepentityh) ->Cfs_faces();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShell::Cfs_faces (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	{  ((SdaiOpen_shellH) _stepentityh) ->Cfs_faces( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	{  ((SdaiClosed_shellH) _stepentityh) ->Cfs_faces( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiShell::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	return ((SdaiOpen_shellH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	return ((SdaiClosed_shellH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell ) 
	//  VERTEX_SHELL
	return ((SdaiVertex_shellH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_wire_shell ) 
	//  WIRE_SHELL
	return ((SdaiWire_shellH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiShell::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_open_shell ) 
	//  OPEN_SHELL
	{  ((SdaiOpen_shellH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_closed_shell ) 
	//  CLOSED_SHELL
	{  ((SdaiClosed_shellH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_vertex_shell ) 
	//  VERTEX_SHELL
	{  ((SdaiVertex_shellH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_wire_shell ) 
	//  WIRE_SHELL
	{  ((SdaiWire_shellH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiShell& SdaiShell::operator =( const SdaiOpen_shellH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_open_shell);
   return *this;
}

SdaiShell& SdaiShell::operator =( const SdaiClosed_shellH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_closed_shell);
   return *this;
}

SdaiShell& SdaiShell::operator =( const SdaiVertex_shellH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_vertex_shell);
   return *this;
}

SdaiShell& SdaiShell::operator =( const SdaiWire_shellH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_wire_shell);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiShell& SdaiShell::operator =( const SdaiShellH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_open_shell )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_closed_shell )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_vertex_shell )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_wire_shell )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiShell::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_open_shell )
	_stepentityh = ((SdaiShell&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_closed_shell )
	_stepentityh = ((SdaiShell&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_vertex_shell )
	_stepentityh = ((SdaiShell&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_wire_shell )
	_stepentityh = ((SdaiShell&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiShell::IsOpen_shell() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_open_shell )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiShell::IsClosed_shell() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_closed_shell )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiShell::IsVertex_shell() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_vertex_shell )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiShell::IsWire_shell() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_wire_shell )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiShell


//////////  SELECT TYPE transformation

const TypeDescriptor * 
SdaiTransformation::AssignEntity (STEPentity * se)
{
  //  ITEM_DEFINED_TRANSFORMATION
  if (se -> eDesc -> IsA (config_control_designe_item_defined_transformation))
  {  
	_stepentityh = (SdaiItem_defined_transformationH) se;
	return SetUnderlyingType (config_control_designe_item_defined_transformation);
  }
  //  FUNCTIONALLY_DEFINED_TRANSFORMATION
  if (se -> eDesc -> IsA (config_control_designe_functionally_defined_transformation))
  {  
	_stepentityh = (SdaiFunctionally_defined_transformationH) se;
	return SetUnderlyingType (config_control_designe_functionally_defined_transformation);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiTransformation::NewSelect ()
{
  SdaiTransformation * tmp = new SdaiTransformation ();
  return tmp;
}
// STEP Part 21

void
SdaiTransformation::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_item_defined_transformation)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiTransformation::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_item_defined_transformation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiTransformation::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiTransformation::SdaiTransformation()
  : SdaiSelect (config_control_designt_transformation)
{
   nullify();
}

	//  part 1
SdaiTransformation::SdaiTransformation( const SdaiItem_defined_transformationH& o )
  : SdaiSelect (config_control_designt_transformation, config_control_designe_item_defined_transformation )
{
   _stepentityh = o;
}

SdaiTransformation::SdaiTransformation( const SdaiFunctionally_defined_transformationH& o )
  : SdaiSelect (config_control_designt_transformation, config_control_designe_functionally_defined_transformation )
{
   _stepentityh = o;
}

SdaiTransformation::~SdaiTransformation()
{
}


	//  part 2
SdaiTransformation::operator SdaiItem_defined_transformationH()
{
   if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
      return ((SdaiItem_defined_transformationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiTransformation::operator SdaiFunctionally_defined_transformationH()
{
   if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
      return ((SdaiFunctionally_defined_transformationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiRepresentation_itemH 
SdaiTransformation::Transform_item_2() const 
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformationH) _stepentityh) ->Transform_item_2();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiTransformation::Transform_item_2 (SdaiRepresentation_itemH x)
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformationH) _stepentityh) ->Transform_item_2( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiRepresentation_itemH 
SdaiTransformation::Transform_item_1() const 
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformationH) _stepentityh) ->Transform_item_1();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiTransformation::Transform_item_1 (SdaiRepresentation_itemH x)
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformationH) _stepentityh) ->Transform_item_1( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiTransformation::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformationH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation ) 
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	return ((SdaiFunctionally_defined_transformationH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiTransformation::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformationH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation ) 
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	{  ((SdaiFunctionally_defined_transformationH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiTransformation::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	return ((SdaiItem_defined_transformationH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation ) 
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	return ((SdaiFunctionally_defined_transformationH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiTransformation::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation ) 
	//  ITEM_DEFINED_TRANSFORMATION
	{  ((SdaiItem_defined_transformationH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation ) 
	//  FUNCTIONALLY_DEFINED_TRANSFORMATION
	{  ((SdaiFunctionally_defined_transformationH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiTransformation& SdaiTransformation::operator =( const SdaiItem_defined_transformationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_item_defined_transformation);
   return *this;
}

SdaiTransformation& SdaiTransformation::operator =( const SdaiFunctionally_defined_transformationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_functionally_defined_transformation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiTransformation& SdaiTransformation::operator =( const SdaiTransformationH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiTransformation::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
	_stepentityh = ((SdaiTransformation&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
	_stepentityh = ((SdaiTransformation&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiTransformation::IsItem_defined_transformation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_item_defined_transformation )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiTransformation::IsFunctionally_defined_transformation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_functionally_defined_transformation )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiTransformation


//////////  SELECT TYPE boolean_operand

const TypeDescriptor * 
SdaiBoolean_operand::AssignEntity (STEPentity * se)
{
  //  SOLID_MODEL
  if (se -> eDesc -> IsA (config_control_designe_solid_model))
  {  
	_stepentityh = (SdaiSolid_modelH) se;
	return SetUnderlyingType (config_control_designe_solid_model);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiBoolean_operand::NewSelect ()
{
  SdaiBoolean_operand * tmp = new SdaiBoolean_operand ();
  return tmp;
}
// STEP Part 21

void
SdaiBoolean_operand::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_solid_model)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiBoolean_operand::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_solid_model)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiBoolean_operand::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiBoolean_operand::SdaiBoolean_operand()
  : SdaiSelect (config_control_designt_boolean_operand)
{
   nullify();
}

	//  part 1
SdaiBoolean_operand::SdaiBoolean_operand( const SdaiSolid_modelH& o )
  : SdaiSelect (config_control_designt_boolean_operand, config_control_designe_solid_model )
{
   _stepentityh = o;
}

SdaiBoolean_operand::~SdaiBoolean_operand()
{
}


	//  part 2
SdaiBoolean_operand::operator SdaiSolid_modelH()
{
   if( CurrentUnderlyingType () == config_control_designe_solid_model )
      return ((SdaiSolid_modelH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiLabel 
SdaiBoolean_operand::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_solid_model ) 
	//  SOLID_MODEL
	return ((SdaiSolid_modelH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiBoolean_operand::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_solid_model ) 
	//  SOLID_MODEL
	{  ((SdaiSolid_modelH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiBoolean_operand& SdaiBoolean_operand::operator =( const SdaiSolid_modelH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_solid_model);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiBoolean_operand& SdaiBoolean_operand::operator =( const SdaiBoolean_operandH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_solid_model )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiBoolean_operand::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_solid_model )
	_stepentityh = ((SdaiBoolean_operand&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiBoolean_operand::IsSolid_model() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_solid_model )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiBoolean_operand


//////////  SELECT TYPE certified_item

const TypeDescriptor * 
SdaiCertified_item::AssignEntity (STEPentity * se)
{
  //  SUPPLIED_PART_RELATIONSHIP
  if (se -> eDesc -> IsA (config_control_designe_supplied_part_relationship))
  {  
	_stepentityh = (SdaiSupplied_part_relationshipH) se;
	return SetUnderlyingType (config_control_designe_supplied_part_relationship);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiCertified_item::NewSelect ()
{
  SdaiCertified_item * tmp = new SdaiCertified_item ();
  return tmp;
}
// STEP Part 21

void
SdaiCertified_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_supplied_part_relationship)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCertified_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_supplied_part_relationship)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCertified_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiCertified_item::SdaiCertified_item()
  : SdaiSelect (config_control_designt_certified_item)
{
   nullify();
}

	//  part 1
SdaiCertified_item::SdaiCertified_item( const SdaiSupplied_part_relationshipH& o )
  : SdaiSelect (config_control_designt_certified_item, config_control_designe_supplied_part_relationship )
{
   _stepentityh = o;
}

SdaiCertified_item::~SdaiCertified_item()
{
}


	//  part 2
SdaiCertified_item::operator SdaiSupplied_part_relationshipH()
{
   if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
      return ((SdaiSupplied_part_relationshipH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiProduct_definitionH 
SdaiCertified_item::Related_product_definition() const 
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationshipH) _stepentityh) ->Related_product_definition();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCertified_item::Related_product_definition (SdaiProduct_definitionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationshipH) _stepentityh) ->Related_product_definition( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definitionH 
SdaiCertified_item::Relating_product_definition() const 
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationshipH) _stepentityh) ->Relating_product_definition();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCertified_item::Relating_product_definition (SdaiProduct_definitionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationshipH) _stepentityh) ->Relating_product_definition( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiCertified_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationshipH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCertified_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationshipH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiCertified_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationshipH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCertified_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationshipH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiCertified_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	return ((SdaiSupplied_part_relationshipH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCertified_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship ) 
	//  SUPPLIED_PART_RELATIONSHIP
	{  ((SdaiSupplied_part_relationshipH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiCertified_item& SdaiCertified_item::operator =( const SdaiSupplied_part_relationshipH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_supplied_part_relationship);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiCertified_item& SdaiCertified_item::operator =( const SdaiCertified_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiCertified_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
	_stepentityh = ((SdaiCertified_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiCertified_item::IsSupplied_part_relationship() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_supplied_part_relationship )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiCertified_item


//////////  SELECT TYPE date_time_select

const TypeDescriptor * 
SdaiDate_time_select::AssignEntity (STEPentity * se)
{
  //  DATE_AND_TIME
  if (se -> eDesc -> IsA (config_control_designe_date_and_time))
  {  
	_stepentityh = (SdaiDate_and_timeH) se;
	return SetUnderlyingType (config_control_designe_date_and_time);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiDate_time_select::NewSelect ()
{
  SdaiDate_time_select * tmp = new SdaiDate_time_select ();
  return tmp;
}
// STEP Part 21

void
SdaiDate_time_select::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_date_and_time)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiDate_time_select::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_date_and_time)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiDate_time_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiDate_time_select::SdaiDate_time_select()
  : SdaiSelect (config_control_designt_date_time_select)
{
   nullify();
}

	//  part 1
SdaiDate_time_select::SdaiDate_time_select( const SdaiDate_and_timeH& o )
  : SdaiSelect (config_control_designt_date_time_select, config_control_designe_date_and_time )
{
   _stepentityh = o;
}

SdaiDate_time_select::~SdaiDate_time_select()
{
}


	//  part 2
SdaiDate_time_select::operator SdaiDate_and_timeH()
{
   if( CurrentUnderlyingType () == config_control_designe_date_and_time )
      return ((SdaiDate_and_timeH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiLocal_timeH 
SdaiDate_time_select::Time_component() const 
{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time ) 
	//  DATE_AND_TIME
	return ((SdaiDate_and_timeH) _stepentityh) ->Time_component();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_select::Time_component (SdaiLocal_timeH x)
{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time ) 
	//  DATE_AND_TIME
	{  ((SdaiDate_and_timeH) _stepentityh) ->Time_component( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiDateH 
SdaiDate_time_select::Date_component() const 
{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time ) 
	//  DATE_AND_TIME
	return ((SdaiDate_and_timeH) _stepentityh) ->Date_component();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiDate_time_select::Date_component (SdaiDateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_date_and_time ) 
	//  DATE_AND_TIME
	{  ((SdaiDate_and_timeH) _stepentityh) ->Date_component( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiDate_time_select& SdaiDate_time_select::operator =( const SdaiDate_and_timeH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_date_and_time);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiDate_time_select& SdaiDate_time_select::operator =( const SdaiDate_time_selectH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_date_and_time )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiDate_time_select::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_date_and_time )
	_stepentityh = ((SdaiDate_time_select&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiDate_time_select::IsDate_and_time() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_date_and_time )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiDate_time_select


//////////  SELECT TYPE curve_on_surface

const TypeDescriptor * 
SdaiCurve_on_surface::AssignEntity (STEPentity * se)
{
  //  PCURVE
  if (se -> eDesc -> IsA (config_control_designe_pcurve))
  {  
	_stepentityh = (SdaiPcurveH) se;
	return SetUnderlyingType (config_control_designe_pcurve);
  }
  //  SURFACE_CURVE
  if (se -> eDesc -> IsA (config_control_designe_surface_curve))
  {  
	_stepentityh = (SdaiSurface_curveH) se;
	return SetUnderlyingType (config_control_designe_surface_curve);
  }
  //  COMPOSITE_CURVE_ON_SURFACE
  if (se -> eDesc -> IsA (config_control_designe_composite_curve_on_surface))
  {  
	_stepentityh = (SdaiComposite_curve_on_surfaceH) se;
	return SetUnderlyingType (config_control_designe_composite_curve_on_surface);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiCurve_on_surface::NewSelect ()
{
  SdaiCurve_on_surface * tmp = new SdaiCurve_on_surface ();
  return tmp;
}
// STEP Part 21

void
SdaiCurve_on_surface::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_pcurve)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_surface_curve)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiCurve_on_surface::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_pcurve)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_surface_curve)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiCurve_on_surface::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiCurve_on_surface::SdaiCurve_on_surface()
  : SdaiSelect (config_control_designt_curve_on_surface)
{
   nullify();
}

	//  part 1
SdaiCurve_on_surface::SdaiCurve_on_surface( const SdaiPcurveH& o )
  : SdaiSelect (config_control_designt_curve_on_surface, config_control_designe_pcurve )
{
   _stepentityh = o;
}

SdaiCurve_on_surface::SdaiCurve_on_surface( const SdaiSurface_curveH& o )
  : SdaiSelect (config_control_designt_curve_on_surface, config_control_designe_surface_curve )
{
   _stepentityh = o;
}

SdaiCurve_on_surface::SdaiCurve_on_surface( const SdaiComposite_curve_on_surfaceH& o )
  : SdaiSelect (config_control_designt_curve_on_surface, config_control_designe_composite_curve_on_surface )
{
   _stepentityh = o;
}

SdaiCurve_on_surface::~SdaiCurve_on_surface()
{
}


	//  part 2
SdaiCurve_on_surface::operator SdaiPcurveH()
{
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return ((SdaiPcurveH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiCurve_on_surface::operator SdaiSurface_curveH()
{
   if( CurrentUnderlyingType () == config_control_designe_surface_curve )
      return ((SdaiSurface_curveH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiCurve_on_surface::operator SdaiComposite_curve_on_surfaceH()
{
   if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
      return ((SdaiComposite_curve_on_surfaceH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const LOGICAL 
SdaiCurve_on_surface::Self_intersect() const 
{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface ) 
	//  COMPOSITE_CURVE_ON_SURFACE
	return ((SdaiComposite_curve_on_surfaceH) _stepentityh) ->Self_intersect();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return (LOGICAL) NULL;
}


void 
SdaiCurve_on_surface::Self_intersect (LOGICAL x)
{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface ) 
	//  COMPOSITE_CURVE_ON_SURFACE
	{  ((SdaiComposite_curve_on_surfaceH) _stepentityh) ->Self_intersect( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const EntityAggregateH 
SdaiCurve_on_surface::Segments() const 
{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface ) 
	//  COMPOSITE_CURVE_ON_SURFACE
	return ((SdaiComposite_curve_on_surfaceH) _stepentityh) ->Segments();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCurve_on_surface::Segments (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface ) 
	//  COMPOSITE_CURVE_ON_SURFACE
	{  ((SdaiComposite_curve_on_surfaceH) _stepentityh) ->Segments( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const sdaiPreferred_surface_curve_representation  
SdaiCurve_on_surface::Master_representation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	return ((SdaiSurface_curveH) _stepentityh) ->Master_representation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return (sdaiPreferred_surface_curve_representation) NULL;
}


void 
SdaiCurve_on_surface::Master_representation (sdaiPreferred_surface_curve_representation x)
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	{  ((SdaiSurface_curveH) _stepentityh) ->Master_representation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiPcurve_or_surfacesH 
SdaiCurve_on_surface::Associated_geometry() const 
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	return ((SdaiSurface_curveH) _stepentityh) ->Associated_geometry();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCurve_on_surface::Associated_geometry (SdaiPcurve_or_surfacesH x)
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	{  ((SdaiSurface_curveH) _stepentityh) ->Associated_geometry( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiCurveH 
SdaiCurve_on_surface::Curve_3d() const 
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	return ((SdaiSurface_curveH) _stepentityh) ->Curve_3d();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCurve_on_surface::Curve_3d (SdaiCurveH x)
{
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	{  ((SdaiSurface_curveH) _stepentityh) ->Curve_3d( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiDefinitional_representationH 
SdaiCurve_on_surface::Reference_to_curve() const 
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	return ((SdaiPcurveH) _stepentityh) ->Reference_to_curve();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCurve_on_surface::Reference_to_curve (SdaiDefinitional_representationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	{  ((SdaiPcurveH) _stepentityh) ->Reference_to_curve( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiSurfaceH 
SdaiCurve_on_surface::Basis_surface() const 
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	return ((SdaiPcurveH) _stepentityh) ->Basis_surface();
  //  for SURFACE_CURVE  attribute is derived
  //  for COMPOSITE_CURVE_ON_SURFACE  attribute is derived
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCurve_on_surface::Basis_surface (SdaiSurfaceH x)
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	{  ((SdaiPcurveH) _stepentityh) ->Basis_surface( x );
	  return;
	}
  //  for SURFACE_CURVE  attribute is derived
  //  for COMPOSITE_CURVE_ON_SURFACE  attribute is derived

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiCurve_on_surface::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	return ((SdaiPcurveH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	return ((SdaiSurface_curveH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface ) 
	//  COMPOSITE_CURVE_ON_SURFACE
	return ((SdaiComposite_curve_on_surfaceH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiCurve_on_surface::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_pcurve ) 
	//  PCURVE
	{  ((SdaiPcurveH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_surface_curve ) 
	//  SURFACE_CURVE
	{  ((SdaiSurface_curveH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface ) 
	//  COMPOSITE_CURVE_ON_SURFACE
	{  ((SdaiComposite_curve_on_surfaceH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiPcurveH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_pcurve);
   return *this;
}

SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiSurface_curveH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_surface_curve);
   return *this;
}

SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiComposite_curve_on_surfaceH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_composite_curve_on_surface);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiCurve_on_surface& SdaiCurve_on_surface::operator =( const SdaiCurve_on_surfaceH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_pcurve )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_surface_curve )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiCurve_on_surface::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_pcurve )
	_stepentityh = ((SdaiCurve_on_surface&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_surface_curve )
	_stepentityh = ((SdaiCurve_on_surface&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
	_stepentityh = ((SdaiCurve_on_surface&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiCurve_on_surface::IsPcurve() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_pcurve )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiCurve_on_surface::IsSurface_curve() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_surface_curve )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiCurve_on_surface::IsComposite_curve_on_surface() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_composite_curve_on_surface )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiCurve_on_surface


//////////  SELECT TYPE trimming_select

const TypeDescriptor * 
SdaiTrimming_select::AssignEntity (STEPentity * se)
{
  //  CARTESIAN_POINT
  if (se -> eDesc -> IsA (config_control_designe_cartesian_point))
  {  
	_stepentityh = (SdaiCartesian_pointH) se;
	return SetUnderlyingType (config_control_designe_cartesian_point);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiTrimming_select::NewSelect ()
{
  SdaiTrimming_select * tmp = new SdaiTrimming_select ();
  return tmp;
}
// STEP Part 21

void
SdaiTrimming_select::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_cartesian_point)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designt_parameter_value)
	out <<  _sdaireal;
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiTrimming_select::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_cartesian_point)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designt_parameter_value)   {
	ReadReal (_sdaireal, in, &_error, "),");
	return severity ();
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiTrimming_select::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiTrimming_select::SdaiTrimming_select()
  : SdaiSelect (config_control_designt_trimming_select)
{
   nullify();
}

	//  part 1
SdaiTrimming_select::SdaiTrimming_select( const SdaiCartesian_pointH& o )
  : SdaiSelect (config_control_designt_trimming_select, config_control_designe_cartesian_point )
{
   _stepentityh = o;
}

SdaiTrimming_select::SdaiTrimming_select( const SdaiParameter_value& o )
  : SdaiSelect (config_control_designt_trimming_select, config_control_designt_parameter_value )
{
   _sdaireal = o;
}

SdaiTrimming_select::~SdaiTrimming_select()
{
}


	//  part 2
SdaiTrimming_select::operator SdaiCartesian_pointH()
{
   if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
      return ((SdaiCartesian_pointH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiTrimming_select::operator SdaiParameter_value()
{
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return  _sdaireal;

  severity( SEVERITY_WARNING );
  Error( "Underlying type is not SdaiParameter_value" );

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const RealAggregateH 
SdaiTrimming_select::Coordinates() const 
{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point ) 
	//  CARTESIAN_POINT
	return ((SdaiCartesian_pointH) _stepentityh) ->Coordinates();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiTrimming_select::Coordinates (RealAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point ) 
	//  CARTESIAN_POINT
	{  ((SdaiCartesian_pointH) _stepentityh) ->Coordinates( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiTrimming_select::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point ) 
	//  CARTESIAN_POINT
	return ((SdaiCartesian_pointH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiTrimming_select::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_cartesian_point ) 
	//  CARTESIAN_POINT
	{  ((SdaiCartesian_pointH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiTrimming_select& SdaiTrimming_select::operator =( const SdaiCartesian_pointH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_cartesian_point);
   return *this;
}

SdaiTrimming_select& SdaiTrimming_select::operator =( const SdaiParameter_value& o )
{
  nullify ();
   _sdaireal = o;
   SetUnderlyingType (config_control_designt_parameter_value);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiTrimming_select& SdaiTrimming_select::operator =( const SdaiTrimming_selectH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_cartesian_point )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designt_parameter_value )
	_sdaireal =  o -> _sdaireal;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiTrimming_select::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_cartesian_point )
	_stepentityh = ((SdaiTrimming_select&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designt_parameter_value )
	_sdaireal = ((SdaiTrimming_select&) o)._sdaireal;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiTrimming_select::IsCartesian_point() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_cartesian_point )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiTrimming_select::IsParameter_value() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_parameter_value )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiTrimming_select


//////////  SELECT TYPE contracted_item

const TypeDescriptor * 
SdaiContracted_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> eDesc -> IsA (config_control_designe_product_definition_formation))
  {  
	_stepentityh = (SdaiProduct_definition_formationH) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiContracted_item::NewSelect ()
{
  SdaiContracted_item * tmp = new SdaiContracted_item ();
  return tmp;
}
// STEP Part 21

void
SdaiContracted_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiContracted_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiContracted_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiContracted_item::SdaiContracted_item()
  : SdaiSelect (config_control_designt_contracted_item)
{
   nullify();
}

	//  part 1
SdaiContracted_item::SdaiContracted_item( const SdaiProduct_definition_formationH& o )
  : SdaiSelect (config_control_designt_contracted_item, config_control_designe_product_definition_formation )
{
   _stepentityh = o;
}

SdaiContracted_item::~SdaiContracted_item()
{
}


	//  part 2
SdaiContracted_item::operator SdaiProduct_definition_formationH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiProductH 
SdaiContracted_item::Of_product() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiContracted_item::Of_product (SdaiProductH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiContracted_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiContracted_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiContracted_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiContracted_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiContracted_item& SdaiContracted_item::operator =( const SdaiProduct_definition_formationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiContracted_item& SdaiContracted_item::operator =( const SdaiContracted_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiContracted_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh = ((SdaiContracted_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiContracted_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiContracted_item


//////////  SELECT TYPE unit

const TypeDescriptor * 
SdaiUnit::AssignEntity (STEPentity * se)
{
  //  NAMED_UNIT
  if (se -> eDesc -> IsA (config_control_designe_named_unit))
  {  
	_stepentityh = (SdaiNamed_unitH) se;
	return SetUnderlyingType (config_control_designe_named_unit);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiUnit::NewSelect ()
{
  SdaiUnit * tmp = new SdaiUnit ();
  return tmp;
}
// STEP Part 21

void
SdaiUnit::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_named_unit)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiUnit::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_named_unit)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiUnit::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiUnit::SdaiUnit()
  : SdaiSelect (config_control_designt_unit)
{
   nullify();
}

	//  part 1
SdaiUnit::SdaiUnit( const SdaiNamed_unitH& o )
  : SdaiSelect (config_control_designt_unit, config_control_designe_named_unit )
{
   _stepentityh = o;
}

SdaiUnit::~SdaiUnit()
{
}


	//  part 2
SdaiUnit::operator SdaiNamed_unitH()
{
   if( CurrentUnderlyingType () == config_control_designe_named_unit )
      return ((SdaiNamed_unitH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiDimensional_exponentsH 
SdaiUnit::Dimensions() const 
{
  if( CurrentUnderlyingType () == config_control_designe_named_unit ) 
	//  NAMED_UNIT
	return ((SdaiNamed_unitH) _stepentityh) ->Dimensions();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiUnit::Dimensions (SdaiDimensional_exponentsH x)
{
  if( CurrentUnderlyingType () == config_control_designe_named_unit ) 
	//  NAMED_UNIT
	{  ((SdaiNamed_unitH) _stepentityh) ->Dimensions( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiUnit& SdaiUnit::operator =( const SdaiNamed_unitH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_named_unit);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiUnit& SdaiUnit::operator =( const SdaiUnitH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_named_unit )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiUnit::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_named_unit )
	_stepentityh = ((SdaiUnit&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiUnit::IsNamed_unit() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_named_unit )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiUnit


//////////  SELECT TYPE reversible_topology

const TypeDescriptor * 
SdaiReversible_topology::AssignEntity (STEPentity * se)
{
  //  REVERSIBLE_TOPOLOGY_ITEM
  if (config_control_designt_reversible_topology_item -> CanBe (se -> eDesc))
  {  
	_sdaireversible_topology_item.AssignEntity (se);
	return SetUnderlyingType (config_control_designt_reversible_topology_item);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiReversible_topology::NewSelect ()
{
  SdaiReversible_topology * tmp = new SdaiReversible_topology ();
  return tmp;
}
// STEP Part 21

void
SdaiReversible_topology::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designt_reversible_topology_item)
	_sdaireversible_topology_item.STEPwrite (out);
  else    if (CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item)
	_sdaireversible_topology_items.STEPwrite (out);
  else    if (CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item)
	_sdaireversible_topology_items.STEPwrite (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiReversible_topology::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designt_reversible_topology_item)   {
	_sdaireversible_topology_item.STEPread (in, &_error, instances, addFileId);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item)   {
	_sdaireversible_topology_items.STEPread (in, &_error, config_control_designt_list_of_reversible_topology_item -> AggrElemTypeDescriptor (), instances, addFileId);
	return severity ();
  }
  if (CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item)   {
	_sdaireversible_topology_items.STEPread (in, &_error, config_control_designt_set_of_reversible_topology_item -> AggrElemTypeDescriptor (), instances, addFileId);
	return severity ();
  }
  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiReversible_topology::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  case LIST_TYPE :  
	return _sdaireversible_topology_items.StrToVal (str, &_error, config_control_designt_list_of_reversible_topology_item -> AggrElemTypeDescriptor ());
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiReversible_topology::SdaiReversible_topology()
  : SdaiSelect (config_control_designt_reversible_topology)
{
   nullify();
}

	//  part 1
SdaiReversible_topology::SdaiReversible_topology( const SdaiReversible_topology_itemH& o )
  : SdaiSelect (config_control_designt_reversible_topology, config_control_designt_reversible_topology_item )
{
   _sdaireversible_topology_item = o;
}

SdaiReversible_topology::SdaiReversible_topology( const SdaiReversible_topology_itemsH& o )
  : SdaiSelect (config_control_designt_reversible_topology, config_control_designt_set_of_reversible_topology_item )
{
   _sdaireversible_topology_items.ShallowCopy (*o);
//  NOTE:  Underlying type defaults to config_control_designt_set_of_reversible_topology_item instead of NULL
}

SdaiReversible_topology::~SdaiReversible_topology()
{
}


	//  part 2
SdaiReversible_topology::operator SdaiReversible_topology_itemH()
{
   if( CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
      return & _sdaireversible_topology_item;

  severity( SEVERITY_WARNING );
  Error( "Underlying type is not SdaiReversible_topology_itemH" );

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiReversible_topology::operator SdaiSet_of_reversible_topology_itemH()
{
   if( CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
      return & _sdaireversible_topology_items;
   if( CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
      return & _sdaireversible_topology_items;

  severity( SEVERITY_WARNING );
  Error( "Underlying type is not SdaiSet_of_reversible_topology_itemH" );

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

	//  part 4
SdaiReversible_topology& SdaiReversible_topology::operator =( const SdaiReversible_topology_itemH& o )
{
  nullify ();
   _sdaireversible_topology_item = o;
   SetUnderlyingType (config_control_designt_reversible_topology_item);
   return *this;
}

SdaiReversible_topology& SdaiReversible_topology::operator =( const SdaiReversible_topology_itemsH& o )
{
   _sdaireversible_topology_items.ShallowCopy (*o);
  underlying_type = 0; // MUST BE SET BY USER 
//	discriminator = UNSET
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiReversible_topology& SdaiReversible_topology::operator =( const SdaiReversible_topologyH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
	_sdaireversible_topology_item =  o -> _sdaireversible_topology_item;
   if( o -> CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
      _sdaireversible_topology_items = o -> _sdaireversible_topology_items;
   if( o -> CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
      _sdaireversible_topology_items = o -> _sdaireversible_topology_items;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiReversible_topology::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
	_sdaireversible_topology_item = ((SdaiReversible_topology&) o)._sdaireversible_topology_item;
   if( o.CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
	_sdaireversible_topology_items = ((SdaiReversible_topology&) o)._sdaireversible_topology_items;
   if( o.CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
	_sdaireversible_topology_items = ((SdaiReversible_topology&) o)._sdaireversible_topology_items;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiReversible_topology::IsReversible_topology_item() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_reversible_topology_item )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiReversible_topology::IsList_of_reversible_topology_item() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_list_of_reversible_topology_item )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiReversible_topology::IsSet_of_reversible_topology_item() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designt_set_of_reversible_topology_item )
      return sdaiTRUE;
   return sdaiFALSE;
}


	//  part 7
const TypeDescriptor * 
SdaiReversible_topology::SetUnderlyingType (const TypeDescriptor * td)
{
  return SdaiSelect::SetUnderlyingType (td);
}
//////////  END SELECT TYPE SdaiReversible_topology


//////////  SELECT TYPE work_item

const TypeDescriptor * 
SdaiWork_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> eDesc -> IsA (config_control_designe_product_definition_formation))
  {  
	_stepentityh = (SdaiProduct_definition_formationH) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiWork_item::NewSelect ()
{
  SdaiWork_item * tmp = new SdaiWork_item ();
  return tmp;
}
// STEP Part 21

void
SdaiWork_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiWork_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiWork_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiWork_item::SdaiWork_item()
  : SdaiSelect (config_control_designt_work_item)
{
   nullify();
}

	//  part 1
SdaiWork_item::SdaiWork_item( const SdaiProduct_definition_formationH& o )
  : SdaiSelect (config_control_designt_work_item, config_control_designe_product_definition_formation )
{
   _stepentityh = o;
}

SdaiWork_item::~SdaiWork_item()
{
}


	//  part 2
SdaiWork_item::operator SdaiProduct_definition_formationH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiProductH 
SdaiWork_item::Of_product() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiWork_item::Of_product (SdaiProductH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiWork_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiWork_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiWork_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiWork_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiWork_item& SdaiWork_item::operator =( const SdaiProduct_definition_formationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiWork_item& SdaiWork_item::operator =( const SdaiWork_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiWork_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh = ((SdaiWork_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiWork_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiWork_item


//////////  SELECT TYPE supported_item

const TypeDescriptor * 
SdaiSupported_item::AssignEntity (STEPentity * se)
{
  //  ACTION_DIRECTIVE
  if (se -> eDesc -> IsA (config_control_designe_action_directive))
  {  
	_stepentityh = (SdaiAction_directiveH) se;
	return SetUnderlyingType (config_control_designe_action_directive);
  }
  //  ACTION
  if (se -> eDesc -> IsA (config_control_designe_action))
  {  
	_stepentityh = (SdaiActionH) se;
	return SetUnderlyingType (config_control_designe_action);
  }
  //  ACTION_METHOD
  if (se -> eDesc -> IsA (config_control_designe_action_method))
  {  
	_stepentityh = (SdaiAction_methodH) se;
	return SetUnderlyingType (config_control_designe_action_method);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiSupported_item::NewSelect ()
{
  SdaiSupported_item * tmp = new SdaiSupported_item ();
  return tmp;
}
// STEP Part 21

void
SdaiSupported_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_action_directive)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_action)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_action_method)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiSupported_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_action_directive)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_action)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_action_method)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiSupported_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiSupported_item::SdaiSupported_item()
  : SdaiSelect (config_control_designt_supported_item)
{
   nullify();
}

	//  part 1
SdaiSupported_item::SdaiSupported_item( const SdaiAction_directiveH& o )
  : SdaiSelect (config_control_designt_supported_item, config_control_designe_action_directive )
{
   _stepentityh = o;
}

SdaiSupported_item::SdaiSupported_item( const SdaiActionH& o )
  : SdaiSelect (config_control_designt_supported_item, config_control_designe_action )
{
   _stepentityh = o;
}

SdaiSupported_item::SdaiSupported_item( const SdaiAction_methodH& o )
  : SdaiSelect (config_control_designt_supported_item, config_control_designe_action_method )
{
   _stepentityh = o;
}

SdaiSupported_item::~SdaiSupported_item()
{
}


	//  part 2
SdaiSupported_item::operator SdaiAction_directiveH()
{
   if( CurrentUnderlyingType () == config_control_designe_action_directive )
      return ((SdaiAction_directiveH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiSupported_item::operator SdaiActionH()
{
   if( CurrentUnderlyingType () == config_control_designe_action )
      return ((SdaiActionH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiSupported_item::operator SdaiAction_methodH()
{
   if( CurrentUnderlyingType () == config_control_designe_action_method )
      return ((SdaiAction_methodH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiText 
SdaiSupported_item::Purpose() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	return ((SdaiAction_methodH) _stepentityh) ->Purpose();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Purpose (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	{  ((SdaiAction_methodH) _stepentityh) ->Purpose( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiSupported_item::Consequence() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	return ((SdaiAction_methodH) _stepentityh) ->Consequence();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Consequence (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	{  ((SdaiAction_methodH) _stepentityh) ->Consequence( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiAction_methodH 
SdaiSupported_item::Chosen_method() const 
{
  if( CurrentUnderlyingType () == config_control_designe_action ) 
	//  ACTION
	return ((SdaiActionH) _stepentityh) ->Chosen_method();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Chosen_method (SdaiAction_methodH x)
{
  if( CurrentUnderlyingType () == config_control_designe_action ) 
	//  ACTION
	{  ((SdaiActionH) _stepentityh) ->Chosen_method( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const EntityAggregateH 
SdaiSupported_item::Requests() const 
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directiveH) _stepentityh) ->Requests();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Requests (EntityAggregateH x)
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directiveH) _stepentityh) ->Requests( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiSupported_item::Comment() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directiveH) _stepentityh) ->Comment();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Comment (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directiveH) _stepentityh) ->Comment( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiSupported_item::Analysis() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directiveH) _stepentityh) ->Analysis();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Analysis (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directiveH) _stepentityh) ->Analysis( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiSupported_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directiveH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_action ) 
	//  ACTION
	return ((SdaiActionH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	return ((SdaiAction_methodH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directiveH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action ) 
	//  ACTION
	{  ((SdaiActionH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	{  ((SdaiAction_methodH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiSupported_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	return ((SdaiAction_directiveH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_action ) 
	//  ACTION
	return ((SdaiActionH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	return ((SdaiAction_methodH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSupported_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_action_directive ) 
	//  ACTION_DIRECTIVE
	{  ((SdaiAction_directiveH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action ) 
	//  ACTION
	{  ((SdaiActionH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_action_method ) 
	//  ACTION_METHOD
	{  ((SdaiAction_methodH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiSupported_item& SdaiSupported_item::operator =( const SdaiAction_directiveH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_action_directive);
   return *this;
}

SdaiSupported_item& SdaiSupported_item::operator =( const SdaiActionH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_action);
   return *this;
}

SdaiSupported_item& SdaiSupported_item::operator =( const SdaiAction_methodH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_action_method);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiSupported_item& SdaiSupported_item::operator =( const SdaiSupported_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_action_directive )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_action )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_action_method )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiSupported_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_action_directive )
	_stepentityh = ((SdaiSupported_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_action )
	_stepentityh = ((SdaiSupported_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_action_method )
	_stepentityh = ((SdaiSupported_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiSupported_item::IsAction_directive() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_action_directive )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiSupported_item::IsAction() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_action )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiSupported_item::IsAction_method() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_action_method )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiSupported_item


//////////  SELECT TYPE approved_item

const TypeDescriptor * 
SdaiApproved_item::AssignEntity (STEPentity * se)
{
  //  PRODUCT_DEFINITION_FORMATION
  if (se -> eDesc -> IsA (config_control_designe_product_definition_formation))
  {  
	_stepentityh = (SdaiProduct_definition_formationH) se;
	return SetUnderlyingType (config_control_designe_product_definition_formation);
  }
  //  PRODUCT_DEFINITION
  if (se -> eDesc -> IsA (config_control_designe_product_definition))
  {  
	_stepentityh = (SdaiProduct_definitionH) se;
	return SetUnderlyingType (config_control_designe_product_definition);
  }
  //  CONFIGURATION_EFFECTIVITY
  if (se -> eDesc -> IsA (config_control_designe_configuration_effectivity))
  {  
	_stepentityh = (SdaiConfiguration_effectivityH) se;
	return SetUnderlyingType (config_control_designe_configuration_effectivity);
  }
  //  CONFIGURATION_ITEM
  if (se -> eDesc -> IsA (config_control_designe_configuration_item))
  {  
	_stepentityh = (SdaiConfiguration_itemH) se;
	return SetUnderlyingType (config_control_designe_configuration_item);
  }
  //  SECURITY_CLASSIFICATION
  if (se -> eDesc -> IsA (config_control_designe_security_classification))
  {  
	_stepentityh = (SdaiSecurity_classificationH) se;
	return SetUnderlyingType (config_control_designe_security_classification);
  }
  //  CHANGE_REQUEST
  if (se -> eDesc -> IsA (config_control_designe_change_request))
  {  
	_stepentityh = (SdaiChange_requestH) se;
	return SetUnderlyingType (config_control_designe_change_request);
  }
  //  CHANGE
  if (se -> eDesc -> IsA (config_control_designe_change))
  {  
	_stepentityh = (SdaiChangeH) se;
	return SetUnderlyingType (config_control_designe_change);
  }
  //  START_REQUEST
  if (se -> eDesc -> IsA (config_control_designe_start_request))
  {  
	_stepentityh = (SdaiStart_requestH) se;
	return SetUnderlyingType (config_control_designe_start_request);
  }
  //  START_WORK
  if (se -> eDesc -> IsA (config_control_designe_start_work))
  {  
	_stepentityh = (SdaiStart_workH) se;
	return SetUnderlyingType (config_control_designe_start_work);
  }
  //  CERTIFICATION
  if (se -> eDesc -> IsA (config_control_designe_certification))
  {  
	_stepentityh = (SdaiCertificationH) se;
	return SetUnderlyingType (config_control_designe_certification);
  }
  //  CONTRACT
  if (se -> eDesc -> IsA (config_control_designe_contract))
  {  
	_stepentityh = (SdaiContractH) se;
	return SetUnderlyingType (config_control_designe_contract);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiApproved_item::NewSelect ()
{
  SdaiApproved_item * tmp = new SdaiApproved_item ();
  return tmp;
}
// STEP Part 21

void
SdaiApproved_item::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_product_definition)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_configuration_effectivity)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_configuration_item)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_security_classification)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_change_request)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_change)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_start_request)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_start_work)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_certification)
	_stepentityh -> STEPwrite_reference (out);
  else    if (CurrentUnderlyingType () == config_control_designe_contract)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiApproved_item::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_product_definition_formation)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_product_definition)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_configuration_effectivity)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_configuration_item)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_security_classification)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_change_request)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_change)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_start_request)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_start_work)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_certification)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  if (CurrentUnderlyingType () == config_control_designe_contract)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiApproved_item::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiApproved_item::SdaiApproved_item()
  : SdaiSelect (config_control_designt_approved_item)
{
   nullify();
}

	//  part 1
SdaiApproved_item::SdaiApproved_item( const SdaiProduct_definition_formationH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_product_definition_formation )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiProduct_definitionH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_product_definition )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiConfiguration_effectivityH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_configuration_effectivity )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiConfiguration_itemH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_configuration_item )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiSecurity_classificationH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_security_classification )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiChange_requestH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_change_request )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiChangeH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_change )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiStart_requestH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_start_request )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiStart_workH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_start_work )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiCertificationH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_certification )
{
   _stepentityh = o;
}

SdaiApproved_item::SdaiApproved_item( const SdaiContractH& o )
  : SdaiSelect (config_control_designt_approved_item, config_control_designe_contract )
{
   _stepentityh = o;
}

SdaiApproved_item::~SdaiApproved_item()
{
}


	//  part 2
SdaiApproved_item::operator SdaiProduct_definition_formationH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return ((SdaiProduct_definition_formationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiProduct_definitionH()
{
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return ((SdaiProduct_definitionH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiConfiguration_effectivityH()
{
   if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
      return ((SdaiConfiguration_effectivityH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiConfiguration_itemH()
{
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return ((SdaiConfiguration_itemH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiSecurity_classificationH()
{
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return ((SdaiSecurity_classificationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiChange_requestH()
{
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return ((SdaiChange_requestH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiChangeH()
{
   if( CurrentUnderlyingType () == config_control_designe_change )
      return ((SdaiChangeH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiStart_requestH()
{
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return ((SdaiStart_requestH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiStart_workH()
{
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return ((SdaiStart_workH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiCertificationH()
{
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return ((SdaiCertificationH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}

SdaiApproved_item::operator SdaiContractH()
{
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return ((SdaiContractH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

SdaiCertification_typeH 
SdaiApproved_item::Kind() const 
{
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	return ((SdaiCertificationH) _stepentityh) ->Kind();
  //  CONTRACT
	//  attribute access function has a different return type
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Kind (SdaiCertification_typeH x)
{
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	{  ((SdaiCertificationH) _stepentityh) ->Kind( x );
	  return;
	}
  //  for CONTRACT  attribute access function has a different argument type

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiActionH 
SdaiApproved_item::Assigned_action() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	return ((SdaiChangeH) _stepentityh) ->Assigned_action();
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	return ((SdaiStart_workH) _stepentityh) ->Assigned_action();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Assigned_action (SdaiActionH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change ) 
	//  CHANGE
	{  ((SdaiChangeH) _stepentityh) ->Assigned_action( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_work ) 
	//  START_WORK
	{  ((SdaiStart_workH) _stepentityh) ->Assigned_action( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiChange_request_itemsH 
SdaiApproved_item::Items() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	return ((SdaiChange_requestH) _stepentityh) ->Items();
  //  CHANGE
	//  attribute access function has a different return type
  //  START_REQUEST
	//  attribute access function has a different return type
  //  START_WORK
	//  attribute access function has a different return type
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Items (SdaiChange_request_itemsH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	{  ((SdaiChange_requestH) _stepentityh) ->Items( x );
	  return;
	}
  //  for CHANGE  attribute access function has a different argument type
  //  for START_REQUEST  attribute access function has a different argument type
  //  for START_WORK  attribute access function has a different argument type

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiVersioned_action_requestH 
SdaiApproved_item::Assigned_action_request() const 
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	return ((SdaiChange_requestH) _stepentityh) ->Assigned_action_request();
  if( CurrentUnderlyingType () == config_control_designe_start_request ) 
	//  START_REQUEST
	return ((SdaiStart_requestH) _stepentityh) ->Assigned_action_request();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Assigned_action_request (SdaiVersioned_action_requestH x)
{
  if( CurrentUnderlyingType () == config_control_designe_change_request ) 
	//  CHANGE_REQUEST
	{  ((SdaiChange_requestH) _stepentityh) ->Assigned_action_request( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_start_request ) 
	//  START_REQUEST
	{  ((SdaiStart_requestH) _stepentityh) ->Assigned_action_request( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiSecurity_classification_levelH 
SdaiApproved_item::Security_level() const 
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Security_level();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Security_level (SdaiSecurity_classification_levelH x)
{
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Security_level( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiApproved_item::Purpose() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Purpose();
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Purpose();
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	return ((SdaiCertificationH) _stepentityh) ->Purpose();
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Purpose();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Purpose (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Purpose( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Purpose( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	{  ((SdaiCertificationH) _stepentityh) ->Purpose( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Purpose( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_conceptH 
SdaiApproved_item::Item_concept() const 
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Item_concept();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Item_concept (SdaiProduct_conceptH x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Item_concept( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiApproved_item::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	return ((SdaiSecurity_classificationH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	return ((SdaiCertificationH) _stepentityh) ->Name();
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	return ((SdaiContractH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_security_classification ) 
	//  SECURITY_CLASSIFICATION
	{  ((SdaiSecurity_classificationH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_certification ) 
	//  CERTIFICATION
	{  ((SdaiCertificationH) _stepentityh) ->Name( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_contract ) 
	//  CONTRACT
	{  ((SdaiContractH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiConfiguration_designH 
SdaiApproved_item::Configuration() const 
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity ) 
	//  CONFIGURATION_EFFECTIVITY
	return ((SdaiConfiguration_effectivityH) _stepentityh) ->Configuration();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Configuration (SdaiConfiguration_designH x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity ) 
	//  CONFIGURATION_EFFECTIVITY
	{  ((SdaiConfiguration_effectivityH) _stepentityh) ->Configuration( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_relationshipH 
SdaiApproved_item::Usage() const 
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity ) 
	//  CONFIGURATION_EFFECTIVITY
	return ((SdaiConfiguration_effectivityH) _stepentityh) ->Usage();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Usage (SdaiProduct_definition_relationshipH x)
{
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity ) 
	//  CONFIGURATION_EFFECTIVITY
	{  ((SdaiConfiguration_effectivityH) _stepentityh) ->Usage( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_contextH 
SdaiApproved_item::Frame_of_reference() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Frame_of_reference (SdaiProduct_definition_contextH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Frame_of_reference( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProduct_definition_formationH 
SdaiApproved_item::Formation() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Formation();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Formation (SdaiProduct_definition_formationH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Formation( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

SdaiProductH 
SdaiApproved_item::Of_product() const 
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Of_product (SdaiProductH x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Of_product( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiText 
SdaiApproved_item::Description() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Description();
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Description();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Description (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Description( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Description( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiIdentifier 
SdaiApproved_item::Id() const
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	return ((SdaiProduct_definition_formationH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	return ((SdaiProduct_definitionH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity ) 
	//  CONFIGURATION_EFFECTIVITY
	return ((SdaiConfiguration_effectivityH) _stepentityh) ->Id();
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	return ((SdaiConfiguration_itemH) _stepentityh) ->Id();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiApproved_item::Id (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_product_definition_formation ) 
	//  PRODUCT_DEFINITION_FORMATION
	{  ((SdaiProduct_definition_formationH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_product_definition ) 
	//  PRODUCT_DEFINITION
	{  ((SdaiProduct_definitionH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity ) 
	//  CONFIGURATION_EFFECTIVITY
	{  ((SdaiConfiguration_effectivityH) _stepentityh) ->Id( x );
	  return;
	}
  if( CurrentUnderlyingType () == config_control_designe_configuration_item ) 
	//  CONFIGURATION_ITEM
	{  ((SdaiConfiguration_itemH) _stepentityh) ->Id( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiApproved_item& SdaiApproved_item::operator =( const SdaiProduct_definition_formationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition_formation);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiProduct_definitionH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_product_definition);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiConfiguration_effectivityH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_configuration_effectivity);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiConfiguration_itemH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_configuration_item);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiSecurity_classificationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_security_classification);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiChange_requestH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_change_request);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiChangeH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_change);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiStart_requestH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_start_request);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiStart_workH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_start_work);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiCertificationH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_certification);
   return *this;
}

SdaiApproved_item& SdaiApproved_item::operator =( const SdaiContractH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_contract);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiApproved_item& SdaiApproved_item::operator =( const SdaiApproved_itemH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_configuration_item )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_security_classification )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_change_request )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_change )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_start_request )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_start_work )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_certification )
	_stepentityh =  o -> _stepentityh;
   if( o -> CurrentUnderlyingType () == config_control_designe_contract )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiApproved_item::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition_formation )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_product_definition )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_configuration_item )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_security_classification )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_change_request )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_change )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_start_request )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_start_work )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_certification )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   if( o.CurrentUnderlyingType () == config_control_designe_contract )
	_stepentityh = ((SdaiApproved_item&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiApproved_item::IsProduct_definition_formation() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition_formation )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsProduct_definition() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_product_definition )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsConfiguration_effectivity() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_configuration_effectivity )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsConfiguration_item() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_configuration_item )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsSecurity_classification() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_security_classification )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsChange_request() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_change_request )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsChange() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_change )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsStart_request() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_start_request )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsStart_work() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_start_work )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsCertification() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_certification )
      return sdaiTRUE;
   return sdaiFALSE;
}

SdaiLogical SdaiApproved_item::IsContract() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_contract )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiApproved_item


//////////  SELECT TYPE surface_model

const TypeDescriptor * 
SdaiSurface_model::AssignEntity (STEPentity * se)
{
  //  SHELL_BASED_SURFACE_MODEL
  if (se -> eDesc -> IsA (config_control_designe_shell_based_surface_model))
  {  
	_stepentityh = (SdaiShell_based_surface_modelH) se;
	return SetUnderlyingType (config_control_designe_shell_based_surface_model);
  }
  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
  G4cerr << se -> EntityName () << endl;
#endif
  return 0;
}

SdaiSelect * 
SdaiSurface_model::NewSelect ()
{
  SdaiSurface_model * tmp = new SdaiSurface_model ();
  return tmp;
}
// STEP Part 21

void
SdaiSurface_model::STEPwrite_content (ostream& out) const
{
  if (CurrentUnderlyingType () == config_control_designe_shell_based_surface_model)
	_stepentityh -> STEPwrite_reference (out);
  else    {
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
  }
  return;
}

Severity
SdaiSurface_model::STEPread_content (istream& in, InstMgr * instances, int addFileId)
{

  if (CurrentUnderlyingType () == config_control_designe_shell_based_surface_model)   {
	// set Underlying Type in Select class
	_stepentityh = ReadEntityRef (in, &_error, ",)", instances, addFileId);
	if (_stepentityh && (_stepentityh != S_ENTITY_NULL)
 	  && (CurrentUnderlyingType () -> CanBe (_stepentityh -> eDesc )) )
	  return severity ();
	else {
 	  Error ("Reference to instance that is not indicated type\n");
	  _stepentityh = 0;
	  nullify ();
	  return severity (SEVERITY_USERMSG);
	}
  }

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << instances << "  " << addFileId << endl;
#endif

  return severity ();
}

Severity
SdaiSurface_model::StrToVal_content (const char * str, InstMgr * instances)
{
  switch (base_type)  {
  default:  // should never be here - Done in Select class

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
#ifdef __SUNCPLUSPLUS__
G4cerr << str << "  " << instances << endl;
#endif
	return SEVERITY_WARNING;
  }
#ifdef __GNUG__

  return SEVERITY_NULL;
#endif
}

// STEP Part 22:  SDAI

	//  part 0
SdaiSurface_model::SdaiSurface_model()
  : SdaiSelect (config_control_designt_surface_model)
{
   nullify();
}

	//  part 1
SdaiSurface_model::SdaiSurface_model( const SdaiShell_based_surface_modelH& o )
  : SdaiSelect (config_control_designt_surface_model, config_control_designe_shell_based_surface_model )
{
   _stepentityh = o;
}

SdaiSurface_model::~SdaiSurface_model()
{
}


	//  part 2
SdaiSurface_model::operator SdaiShell_based_surface_modelH()
{
   if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
      return ((SdaiShell_based_surface_modelH) _stepentityh);

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );
   return NULL;
}


	//  part 3

const SdaiShellsH 
SdaiSurface_model::Sbsm_boundary() const 
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model ) 
	//  SHELL_BASED_SURFACE_MODEL
	return ((SdaiShell_based_surface_modelH) _stepentityh) ->Sbsm_boundary();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSurface_model::Sbsm_boundary (SdaiShellsH x)
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model ) 
	//  SHELL_BASED_SURFACE_MODEL
	{  ((SdaiShell_based_surface_modelH) _stepentityh) ->Sbsm_boundary( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

const SdaiLabel 
SdaiSurface_model::Name() const
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model ) 
	//  SHELL_BASED_SURFACE_MODEL
	return ((SdaiShell_based_surface_modelH) _stepentityh) ->Name();
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  ERROR in schema library:  \n" 
	<< _POC_ << "\n\n";
   return NULL;
}


void 
SdaiSurface_model::Name (const char * x)
{
  if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model ) 
	//  SHELL_BASED_SURFACE_MODEL
	{  ((SdaiShell_based_surface_modelH) _stepentityh) ->Name( x );
	  return;
	}

  severity( SEVERITY_WARNING );
   G4cerr << __FILE__ << ":" << __LINE__ <<  ":  WARNING:  possible misuse of SELECT TYPE from schema library.\n";
  Error( "Mismatch in underlying type." );

}

	//  part 4
SdaiSurface_model& SdaiSurface_model::operator =( const SdaiShell_based_surface_modelH& o )
{
  nullify ();
   _stepentityh = o;
   SetUnderlyingType (config_control_designe_shell_based_surface_model);
   return *this;
}


#ifdef COMPILER_DEFINES_OPERATOR_EQ
#else
SdaiSurface_model& SdaiSurface_model::operator =( const SdaiSurface_modelH& o )
{
   if( o -> CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	_stepentityh =  o -> _stepentityh;
   underlying_type = o -> CurrentUnderlyingType ();
   return *this;
}
SdaiSelect& SdaiSurface_model::operator =( const SdaiSelect& o )
{
   if( o.CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
	_stepentityh = ((SdaiSurface_model&) o)._stepentityh;
   underlying_type = o.CurrentUnderlyingType ();
   return *this;
}
#endif

	//  part 5
SdaiLogical SdaiSurface_model::IsShell_based_surface_model() const
{
   if( !exists() )
      return sdaiUNKNOWN;
   if( CurrentUnderlyingType () == config_control_designe_shell_based_surface_model )
      return sdaiTRUE;
   return sdaiFALSE;
}

//////////  END SELECT TYPE SdaiSurface_model


/*	**************  ENTITIES  	*/

/////////	 ENTITY representation_item 

EntityDescriptor *config_control_designe_representation_item =0;
AttrDescriptor *a_0name =0;
SdaiRepresentation_item::SdaiRepresentation_item( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_item;

    STEPattribute * a = new STEPattribute (*a_0name,  &_name);
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_item::SdaiRepresentation_item (SdaiRepresentation_item& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRepresentation_item::~SdaiRepresentation_item () {  }
SdaiRepresentation_item::SdaiRepresentation_item( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_item;

    STEPattribute * a = new STEPattribute (*a_0name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiRepresentation_item::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiRepresentation_item::Name (const char * x)
	{ _name = x; }

/////////	 END_ENTITY representation_item 


/////////	 ENTITY geometric_representation_item 

EntityDescriptor *config_control_designe_geometric_representation_item =0;
AttrDescriptor *a_1Ddim =0;
SdaiGeometric_representation_item::SdaiGeometric_representation_item( ) 
{

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_item;
}
SdaiGeometric_representation_item::SdaiGeometric_representation_item (SdaiGeometric_representation_item& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGeometric_representation_item::~SdaiGeometric_representation_item () {  }
SdaiGeometric_representation_item::SdaiGeometric_representation_item (STEPentity *se ) : SdaiRepresentation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_item;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_representation_item 


/////////	 ENTITY functionally_defined_transformation 

EntityDescriptor *config_control_designe_functionally_defined_transformation =0;
AttrDescriptor *a_2name =0;
AttrDescriptor *a_3description =0;
SdaiFunctionally_defined_transformation::SdaiFunctionally_defined_transformation( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_functionally_defined_transformation;

    STEPattribute * a = new STEPattribute (*a_2name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_3description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiFunctionally_defined_transformation::SdaiFunctionally_defined_transformation (SdaiFunctionally_defined_transformation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiFunctionally_defined_transformation::~SdaiFunctionally_defined_transformation () {  }
SdaiFunctionally_defined_transformation::SdaiFunctionally_defined_transformation( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_functionally_defined_transformation;

    STEPattribute * a = new STEPattribute (*a_2name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_3description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiFunctionally_defined_transformation::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiFunctionally_defined_transformation::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiFunctionally_defined_transformation::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiFunctionally_defined_transformation::Description (const char * x)
	{ _description = x; }

/////////	 END_ENTITY functionally_defined_transformation 


/////////	 ENTITY cartesian_transformation_operator 

EntityDescriptor *config_control_designe_cartesian_transformation_operator =0;
AttrDescriptor *a_4axis1 =0;
AttrDescriptor *a_5axis2 =0;
AttrDescriptor *a_6local_origin =0;
AttrDescriptor *a_7scale =0;
AttrDescriptor *a_8Dscl =0;
SdaiCartesian_transformation_operator::SdaiCartesian_transformation_operator( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiFunctionally_defined_transformation  */
    AppendMultInstance(new SdaiFunctionally_defined_transformation(this)); 

    eDesc = config_control_designe_cartesian_transformation_operator;

    STEPattribute * a = new STEPattribute (*a_4axis1, (STEPentityH *) &_axis1);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_5axis2, (STEPentityH *) &_axis2);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_6local_origin, (STEPentityH *) &_local_origin);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_7scale,  &_scale);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("name");
    MakeDerived ("name");
}
SdaiCartesian_transformation_operator::SdaiCartesian_transformation_operator (SdaiCartesian_transformation_operator& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCartesian_transformation_operator::~SdaiCartesian_transformation_operator () {  }
SdaiCartesian_transformation_operator::SdaiCartesian_transformation_operator (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiFunctionally_defined_transformation  */
    se->AppendMultInstance(new SdaiFunctionally_defined_transformation(se)); 

    eDesc = config_control_designe_cartesian_transformation_operator;

    STEPattribute * a = new STEPattribute (*a_4axis1, (STEPentityH *) &_axis1);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_5axis2, (STEPentityH *) &_axis2);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_6local_origin, (STEPentityH *) &_local_origin);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_7scale,  &_scale);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("name");
    MakeDerived ("name");
}

SdaiDirectionH 
SdaiCartesian_transformation_operator::Axis1() const 
	{ return (SdaiDirectionH) _axis1; }

void 
SdaiCartesian_transformation_operator::Axis1 (SdaiDirectionH x)
	{ _axis1 = x; }

SdaiDirectionH 
SdaiCartesian_transformation_operator::Axis2() const 
	{ return (SdaiDirectionH) _axis2; }

void 
SdaiCartesian_transformation_operator::Axis2 (SdaiDirectionH x)
	{ _axis2 = x; }

SdaiCartesian_pointH 
SdaiCartesian_transformation_operator::Local_origin() const 
	{ return (SdaiCartesian_pointH) _local_origin; }

void 
SdaiCartesian_transformation_operator::Local_origin (SdaiCartesian_pointH x)
	{ _local_origin = x; }

const SdaiReal 
SdaiCartesian_transformation_operator::Scale() const 
	{ return (const SdaiReal) _scale; }

void 
SdaiCartesian_transformation_operator::Scale (SdaiReal x)
	{ _scale = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

const SdaiLabel 
SdaiCartesian_transformation_operator::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiCartesian_transformation_operator::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiCartesian_transformation_operator::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiCartesian_transformation_operator::Description (const char * x)
	{ _description = x; }

#endif

/////////	 END_ENTITY cartesian_transformation_operator 


/////////	 ENTITY cartesian_transformation_operator_3d 

EntityDescriptor *config_control_designe_cartesian_transformation_operator_3d =0;
AttrDescriptor *a_9axis3 =0;
AttrDescriptor *a_10Du =0;
SdaiCartesian_transformation_operator_3d::SdaiCartesian_transformation_operator_3d( ) 
{

	/*  parent: SdaiCartesian_transformation_operator  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_transformation_operator_3d;

    STEPattribute * a = new STEPattribute (*a_9axis3, (STEPentityH *) &_axis3);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("name");
}
SdaiCartesian_transformation_operator_3d::SdaiCartesian_transformation_operator_3d (SdaiCartesian_transformation_operator_3d& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCartesian_transformation_operator_3d::~SdaiCartesian_transformation_operator_3d () {  }
SdaiCartesian_transformation_operator_3d::SdaiCartesian_transformation_operator_3d (STEPentity *se ) : SdaiCartesian_transformation_operator(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCartesian_transformation_operator  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_transformation_operator_3d;

    STEPattribute * a = new STEPattribute (*a_9axis3, (STEPentityH *) &_axis3);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("name");
}

SdaiDirectionH 
SdaiCartesian_transformation_operator_3d::Axis3() const 
	{ return (SdaiDirectionH) _axis3; }

void 
SdaiCartesian_transformation_operator_3d::Axis3 (SdaiDirectionH x)
	{ _axis3 = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cartesian_transformation_operator_3d 


/////////	 ENTITY versioned_action_request 

EntityDescriptor *config_control_designe_versioned_action_request =0;
AttrDescriptor *a_11id =0;
AttrDescriptor *a_12version =0;
AttrDescriptor *a_13purpose =0;
AttrDescriptor *a_14description =0;
SdaiVersioned_action_request::SdaiVersioned_action_request( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_versioned_action_request;

    STEPattribute * a = new STEPattribute (*a_11id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_12version,  &_version);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_13purpose,  &_purpose);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_14description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiVersioned_action_request::SdaiVersioned_action_request (SdaiVersioned_action_request& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVersioned_action_request::~SdaiVersioned_action_request () {  }
SdaiVersioned_action_request::SdaiVersioned_action_request( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_versioned_action_request;

    STEPattribute * a = new STEPattribute (*a_11id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_12version,  &_version);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_13purpose,  &_purpose);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_14description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiVersioned_action_request::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiVersioned_action_request::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiVersioned_action_request::Version() const
	{ return (const SdaiLabel) _version; }

void 
SdaiVersioned_action_request::Version (const char * x)
	{ _version = x; }

const SdaiText 
SdaiVersioned_action_request::Purpose() const
	{ return (const SdaiText) _purpose; }

void 
SdaiVersioned_action_request::Purpose (const char * x)
	{ _purpose = x; }

const SdaiText 
SdaiVersioned_action_request::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiVersioned_action_request::Description (const char * x)
	{ _description = x; }

/////////	 END_ENTITY versioned_action_request 


/////////	 ENTITY representation 

EntityDescriptor *config_control_designe_representation =0;
AttrDescriptor *a_15name =0;
AttrDescriptor *a_16items =0;
AttrDescriptor *a_17context_of_items =0;
SdaiRepresentation::SdaiRepresentation( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation;

    STEPattribute * a = new STEPattribute (*a_15name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_16items,  &_items);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_17context_of_items, (STEPentityH *) &_context_of_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation::SdaiRepresentation (SdaiRepresentation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRepresentation::~SdaiRepresentation () {  }
SdaiRepresentation::SdaiRepresentation( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_representation;

    STEPattribute * a = new STEPattribute (*a_15name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_16items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_17context_of_items, (STEPentityH *) &_context_of_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiRepresentation::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiRepresentation::Name (const char * x)
	{ _name = x; }

const EntityAggregateH 
SdaiRepresentation::Items() const 
	{ return (EntityAggregateH) &_items; }

void 
SdaiRepresentation::Items (EntityAggregateH x)
	{ _items.ShallowCopy (*x); }

SdaiRepresentation_contextH 
SdaiRepresentation::Context_of_items() const 
	{ return (SdaiRepresentation_contextH) _context_of_items; }

void 
SdaiRepresentation::Context_of_items (SdaiRepresentation_contextH x)
	{ _context_of_items = x; }

/////////	 END_ENTITY representation 


/////////	 ENTITY shape_representation 

EntityDescriptor *config_control_designe_shape_representation =0;
SdaiShape_representation::SdaiShape_representation( ) 
{

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation;
}
SdaiShape_representation::SdaiShape_representation (SdaiShape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShape_representation::~SdaiShape_representation () {  }
SdaiShape_representation::SdaiShape_representation (STEPentity *se ) : SdaiRepresentation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shape_representation 


/////////	 ENTITY manifold_surface_shape_representation 

EntityDescriptor *config_control_designe_manifold_surface_shape_representation =0;
SdaiManifold_surface_shape_representation::SdaiManifold_surface_shape_representation( ) 
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_surface_shape_representation;
}
SdaiManifold_surface_shape_representation::SdaiManifold_surface_shape_representation (SdaiManifold_surface_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiManifold_surface_shape_representation::~SdaiManifold_surface_shape_representation () {  }
SdaiManifold_surface_shape_representation::SdaiManifold_surface_shape_representation (STEPentity *se ) : SdaiShape_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_surface_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY manifold_surface_shape_representation 


/////////	 ENTITY certification 

EntityDescriptor *config_control_designe_certification =0;
AttrDescriptor *a_18name =0;
AttrDescriptor *a_19purpose =0;
AttrDescriptor *a_20kind =0;
SdaiCertification::SdaiCertification( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_certification;

    STEPattribute * a = new STEPattribute (*a_18name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_19purpose,  &_purpose);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_20kind, (STEPentityH *) &_kind);
    a -> set_null ();
    attributes.push (a);
}
SdaiCertification::SdaiCertification (SdaiCertification& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCertification::~SdaiCertification () {  }
SdaiCertification::SdaiCertification( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_certification;

    STEPattribute * a = new STEPattribute (*a_18name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_19purpose,  &_purpose);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_20kind, (STEPentityH *) &_kind);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiCertification::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiCertification::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiCertification::Purpose() const
	{ return (const SdaiText) _purpose; }

void 
SdaiCertification::Purpose (const char * x)
	{ _purpose = x; }

SdaiCertification_typeH 
SdaiCertification::Kind() const 
	{ return (SdaiCertification_typeH) _kind; }

void 
SdaiCertification::Kind (SdaiCertification_typeH x)
	{ _kind = x; }

/////////	 END_ENTITY certification 


/////////	 ENTITY product_definition_relationship 

EntityDescriptor *config_control_designe_product_definition_relationship =0;
AttrDescriptor *a_21id =0;
AttrDescriptor *a_22name =0;
AttrDescriptor *a_23description =0;
AttrDescriptor *a_24relating_product_definition =0;
AttrDescriptor *a_25related_product_definition =0;
SdaiProduct_definition_relationship::SdaiProduct_definition_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_relationship;

    STEPattribute * a = new STEPattribute (*a_21id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_22name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_23description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_24relating_product_definition, (STEPentityH *) &_relating_product_definition);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_25related_product_definition, (STEPentityH *) &_related_product_definition);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_relationship::SdaiProduct_definition_relationship (SdaiProduct_definition_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_relationship::~SdaiProduct_definition_relationship () {  }
SdaiProduct_definition_relationship::SdaiProduct_definition_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_relationship;

    STEPattribute * a = new STEPattribute (*a_21id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_22name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_23description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_24relating_product_definition, (STEPentityH *) &_relating_product_definition);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_25related_product_definition, (STEPentityH *) &_related_product_definition);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiProduct_definition_relationship::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiProduct_definition_relationship::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiProduct_definition_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiProduct_definition_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiProduct_definition_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProduct_definition_relationship::Description (const char * x)
	{ _description = x; }

SdaiProduct_definitionH 
SdaiProduct_definition_relationship::Relating_product_definition() const 
	{ return (SdaiProduct_definitionH) _relating_product_definition; }

void 
SdaiProduct_definition_relationship::Relating_product_definition (SdaiProduct_definitionH x)
	{ _relating_product_definition = x; }

SdaiProduct_definitionH 
SdaiProduct_definition_relationship::Related_product_definition() const 
	{ return (SdaiProduct_definitionH) _related_product_definition; }

void 
SdaiProduct_definition_relationship::Related_product_definition (SdaiProduct_definitionH x)
	{ _related_product_definition = x; }

/////////	 END_ENTITY product_definition_relationship 


/////////	 ENTITY product_definition_usage 

EntityDescriptor *config_control_designe_product_definition_usage =0;
SdaiProduct_definition_usage::SdaiProduct_definition_usage( ) 
{

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_usage;
}
SdaiProduct_definition_usage::SdaiProduct_definition_usage (SdaiProduct_definition_usage& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_usage::~SdaiProduct_definition_usage () {  }
SdaiProduct_definition_usage::SdaiProduct_definition_usage (STEPentity *se ) : SdaiProduct_definition_relationship(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_usage;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_usage 


/////////	 ENTITY assembly_component_usage 

EntityDescriptor *config_control_designe_assembly_component_usage =0;
AttrDescriptor *a_26reference_designator =0;
SdaiAssembly_component_usage::SdaiAssembly_component_usage( ) 
{

	/*  parent: SdaiProduct_definition_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_assembly_component_usage;

    STEPattribute * a = new STEPattribute (*a_26reference_designator,  &_reference_designator);
    a -> set_null ();
    attributes.push (a);
}
SdaiAssembly_component_usage::SdaiAssembly_component_usage (SdaiAssembly_component_usage& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAssembly_component_usage::~SdaiAssembly_component_usage () {  }
SdaiAssembly_component_usage::SdaiAssembly_component_usage (STEPentity *se ) : SdaiProduct_definition_usage(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_assembly_component_usage;

    STEPattribute * a = new STEPattribute (*a_26reference_designator,  &_reference_designator);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiAssembly_component_usage::Reference_designator() const
	{ return (const SdaiIdentifier) _reference_designator; }

void 
SdaiAssembly_component_usage::Reference_designator (const char * x)
	{ _reference_designator = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY assembly_component_usage 


/////////	 ENTITY quantified_assembly_component_usage 

EntityDescriptor *config_control_designe_quantified_assembly_component_usage =0;
AttrDescriptor *a_27quantity =0;
SdaiQuantified_assembly_component_usage::SdaiQuantified_assembly_component_usage( ) 
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quantified_assembly_component_usage;

    STEPattribute * a = new STEPattribute (*a_27quantity, (STEPentityH *) &_quantity);
    a -> set_null ();
    attributes.push (a);
}
SdaiQuantified_assembly_component_usage::SdaiQuantified_assembly_component_usage (SdaiQuantified_assembly_component_usage& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiQuantified_assembly_component_usage::~SdaiQuantified_assembly_component_usage () {  }
SdaiQuantified_assembly_component_usage::SdaiQuantified_assembly_component_usage (STEPentity *se ) : SdaiAssembly_component_usage(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quantified_assembly_component_usage;

    STEPattribute * a = new STEPattribute (*a_27quantity, (STEPentityH *) &_quantity);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiMeasure_with_unitH 
SdaiQuantified_assembly_component_usage::Quantity() const 
	{ return (SdaiMeasure_with_unitH) _quantity; }

void 
SdaiQuantified_assembly_component_usage::Quantity (SdaiMeasure_with_unitH x)
	{ _quantity = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY quantified_assembly_component_usage 


/////////	 ENTITY solid_model 

EntityDescriptor *config_control_designe_solid_model =0;
SdaiSolid_model::SdaiSolid_model( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_model;
}
SdaiSolid_model::SdaiSolid_model (SdaiSolid_model& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSolid_model::~SdaiSolid_model () {  }
SdaiSolid_model::SdaiSolid_model (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_model;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY solid_model 


/////////	 ENTITY manifold_solid_brep 

EntityDescriptor *config_control_designe_manifold_solid_brep =0;
AttrDescriptor *a_28outer =0;
SdaiManifold_solid_brep::SdaiManifold_solid_brep( ) 
{

	/*  parent: SdaiSolid_model  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_solid_brep;

    STEPattribute * a = new STEPattribute (*a_28outer, (STEPentityH *) &_outer);
    a -> set_null ();
    attributes.push (a);
}
SdaiManifold_solid_brep::SdaiManifold_solid_brep (SdaiManifold_solid_brep& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiManifold_solid_brep::~SdaiManifold_solid_brep () {  }
SdaiManifold_solid_brep::SdaiManifold_solid_brep (STEPentity *se ) : SdaiSolid_model(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSolid_model  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_manifold_solid_brep;

    STEPattribute * a = new STEPattribute (*a_28outer, (STEPentityH *) &_outer);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiClosed_shellH 
SdaiManifold_solid_brep::Outer() const 
	{ return (SdaiClosed_shellH) _outer; }

void 
SdaiManifold_solid_brep::Outer (SdaiClosed_shellH x)
	{ _outer = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY manifold_solid_brep 


/////////	 ENTITY faceted_brep 

EntityDescriptor *config_control_designe_faceted_brep =0;
SdaiFaceted_brep::SdaiFaceted_brep( ) 
{

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep;
}
SdaiFaceted_brep::SdaiFaceted_brep (SdaiFaceted_brep& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiFaceted_brep::~SdaiFaceted_brep () {  }
SdaiFaceted_brep::SdaiFaceted_brep (STEPentity *se ) : SdaiManifold_solid_brep(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY faceted_brep 


/////////	 ENTITY action_directive 

EntityDescriptor *config_control_designe_action_directive =0;
AttrDescriptor *a_29name =0;
AttrDescriptor *a_30description =0;
AttrDescriptor *a_31analysis =0;
AttrDescriptor *a_32comment =0;
AttrDescriptor *a_33requests =0;
SdaiAction_directive::SdaiAction_directive( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_directive;

    STEPattribute * a = new STEPattribute (*a_29name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_30description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_31analysis,  &_analysis);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_32comment,  &_comment);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_33requests,  &_requests);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_directive::SdaiAction_directive (SdaiAction_directive& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction_directive::~SdaiAction_directive () {  }
SdaiAction_directive::SdaiAction_directive( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action_directive;

    STEPattribute * a = new STEPattribute (*a_29name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_30description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_31analysis,  &_analysis);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_32comment,  &_comment);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_33requests,  &_requests);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAction_directive::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiAction_directive::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiAction_directive::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiAction_directive::Description (const char * x)
	{ _description = x; }

const SdaiText 
SdaiAction_directive::Analysis() const
	{ return (const SdaiText) _analysis; }

void 
SdaiAction_directive::Analysis (const char * x)
	{ _analysis = x; }

const SdaiText 
SdaiAction_directive::Comment() const
	{ return (const SdaiText) _comment; }

void 
SdaiAction_directive::Comment (const char * x)
	{ _comment = x; }

const EntityAggregateH 
SdaiAction_directive::Requests() const 
	{ return (EntityAggregateH) &_requests; }

void 
SdaiAction_directive::Requests (EntityAggregateH x)
	{ _requests.ShallowCopy (*x); }

/////////	 END_ENTITY action_directive 


/////////	 ENTITY named_unit 

EntityDescriptor *config_control_designe_named_unit =0;
AttrDescriptor *a_34dimensions =0;
SdaiNamed_unit::SdaiNamed_unit( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_named_unit;

    STEPattribute * a = new STEPattribute (*a_34dimensions, (STEPentityH *) &_dimensions);
    a -> set_null ();
    attributes.push (a);
}
SdaiNamed_unit::SdaiNamed_unit (SdaiNamed_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiNamed_unit::~SdaiNamed_unit () {  }
SdaiNamed_unit::SdaiNamed_unit( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_named_unit;

    STEPattribute * a = new STEPattribute (*a_34dimensions, (STEPentityH *) &_dimensions);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDimensional_exponentsH 
SdaiNamed_unit::Dimensions() const 
	{ return (SdaiDimensional_exponentsH) _dimensions; }

void 
SdaiNamed_unit::Dimensions (SdaiDimensional_exponentsH x)
	{ _dimensions = x; }

/////////	 END_ENTITY named_unit 


/////////	 ENTITY plane_angle_unit 

EntityDescriptor *config_control_designe_plane_angle_unit =0;
SdaiPlane_angle_unit::SdaiPlane_angle_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_unit;
}
SdaiPlane_angle_unit::SdaiPlane_angle_unit (SdaiPlane_angle_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPlane_angle_unit::~SdaiPlane_angle_unit () {  }
SdaiPlane_angle_unit::SdaiPlane_angle_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY plane_angle_unit 


/////////	 ENTITY measure_with_unit 

EntityDescriptor *config_control_designe_measure_with_unit =0;
AttrDescriptor *a_35value_component =0;
AttrDescriptor *a_36unit_component =0;
SdaiMeasure_with_unit::SdaiMeasure_with_unit( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_measure_with_unit;

    STEPattribute * a = new STEPattribute (*a_35value_component,  &_value_component);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_36unit_component,  &_unit_component);
    a -> set_null ();
    attributes.push (a);
}
SdaiMeasure_with_unit::SdaiMeasure_with_unit (SdaiMeasure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiMeasure_with_unit::~SdaiMeasure_with_unit () {  }
SdaiMeasure_with_unit::SdaiMeasure_with_unit( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_measure_with_unit;

    STEPattribute * a = new STEPattribute (*a_35value_component,  &_value_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_36unit_component,  &_unit_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiMeasure_valueH 
SdaiMeasure_with_unit::Value_component() const 
	{ return (const SdaiMeasure_valueH) &_value_component; }

void 
SdaiMeasure_with_unit::Value_component (SdaiMeasure_valueH x)
	{ _value_component = x; }

const SdaiUnitH 
SdaiMeasure_with_unit::Unit_component() const 
	{ return (const SdaiUnitH) &_unit_component; }

void 
SdaiMeasure_with_unit::Unit_component (SdaiUnitH x)
	{ _unit_component = x; }

/////////	 END_ENTITY measure_with_unit 


/////////	 ENTITY area_measure_with_unit 

EntityDescriptor *config_control_designe_area_measure_with_unit =0;
SdaiArea_measure_with_unit::SdaiArea_measure_with_unit( ) 
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_measure_with_unit;
}
SdaiArea_measure_with_unit::SdaiArea_measure_with_unit (SdaiArea_measure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiArea_measure_with_unit::~SdaiArea_measure_with_unit () {  }
SdaiArea_measure_with_unit::SdaiArea_measure_with_unit (STEPentity *se ) : SdaiMeasure_with_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY area_measure_with_unit 


/////////	 ENTITY effectivity 

EntityDescriptor *config_control_designe_effectivity =0;
AttrDescriptor *a_37id =0;
SdaiEffectivity::SdaiEffectivity( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_effectivity;

    STEPattribute * a = new STEPattribute (*a_37id,  &_id);
    a -> set_null ();
    attributes.push (a);
}
SdaiEffectivity::SdaiEffectivity (SdaiEffectivity& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEffectivity::~SdaiEffectivity () {  }
SdaiEffectivity::SdaiEffectivity( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_effectivity;

    STEPattribute * a = new STEPattribute (*a_37id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiEffectivity::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiEffectivity::Id (const char * x)
	{ _id = x; }

/////////	 END_ENTITY effectivity 


/////////	 ENTITY serial_numbered_effectivity 

EntityDescriptor *config_control_designe_serial_numbered_effectivity =0;
AttrDescriptor *a_38effectivity_start_id =0;
AttrDescriptor *a_39effectivity_end_id =0;
SdaiSerial_numbered_effectivity::SdaiSerial_numbered_effectivity( ) 
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_serial_numbered_effectivity;

    STEPattribute * a = new STEPattribute (*a_38effectivity_start_id,  &_effectivity_start_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_39effectivity_end_id,  &_effectivity_end_id);
    a -> set_null ();
    attributes.push (a);
}
SdaiSerial_numbered_effectivity::SdaiSerial_numbered_effectivity (SdaiSerial_numbered_effectivity& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSerial_numbered_effectivity::~SdaiSerial_numbered_effectivity () {  }
SdaiSerial_numbered_effectivity::SdaiSerial_numbered_effectivity (STEPentity *se ) : SdaiEffectivity(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_serial_numbered_effectivity;

    STEPattribute * a = new STEPattribute (*a_38effectivity_start_id,  &_effectivity_start_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_39effectivity_end_id,  &_effectivity_end_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiSerial_numbered_effectivity::Effectivity_start_id() const
	{ return (const SdaiIdentifier) _effectivity_start_id; }

void 
SdaiSerial_numbered_effectivity::Effectivity_start_id (const char * x)
	{ _effectivity_start_id = x; }

const SdaiIdentifier 
SdaiSerial_numbered_effectivity::Effectivity_end_id() const
	{ return (const SdaiIdentifier) _effectivity_end_id; }

void 
SdaiSerial_numbered_effectivity::Effectivity_end_id (const char * x)
	{ _effectivity_end_id = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY serial_numbered_effectivity 


/////////	 ENTITY surface 

EntityDescriptor *config_control_designe_surface =0;
SdaiSurface::SdaiSurface( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface;
}
SdaiSurface::SdaiSurface (SdaiSurface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSurface::~SdaiSurface () {  }
SdaiSurface::SdaiSurface (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface 


/////////	 ENTITY offset_surface 

EntityDescriptor *config_control_designe_offset_surface =0;
AttrDescriptor *a_40basis_surface =0;
AttrDescriptor *a_41distance =0;
AttrDescriptor *a_42self_intersect =0;
SdaiOffset_surface::SdaiOffset_surface( ) 
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_surface;

    STEPattribute * a = new STEPattribute (*a_40basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_41distance,  &_distance);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_42self_intersect,  &_self_intersect);
    a -> set_null ();
    attributes.push (a);
}
SdaiOffset_surface::SdaiOffset_surface (SdaiOffset_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOffset_surface::~SdaiOffset_surface () {  }
SdaiOffset_surface::SdaiOffset_surface (STEPentity *se ) : SdaiSurface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_surface;

    STEPattribute * a = new STEPattribute (*a_40basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_41distance,  &_distance);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_42self_intersect,  &_self_intersect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiOffset_surface::Basis_surface() const 
	{ return (SdaiSurfaceH) _basis_surface; }

void 
SdaiOffset_surface::Basis_surface (SdaiSurfaceH x)
	{ _basis_surface = x; }

const SdaiLength_measure 
SdaiOffset_surface::Distance() const 
	{ return (const SdaiLength_measure) _distance; }

void 
SdaiOffset_surface::Distance (SdaiLength_measure x)
	{ _distance = x; }

const LOGICAL 
SdaiOffset_surface::Self_intersect() const 
	{ return (LOGICAL) _self_intersect; }

void 
SdaiOffset_surface::Self_intersect (LOGICAL x)
	{ _self_intersect.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY offset_surface 


/////////	 ENTITY placement 

EntityDescriptor *config_control_designe_placement =0;
AttrDescriptor *a_43location =0;
SdaiPlacement::SdaiPlacement( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_placement;

    STEPattribute * a = new STEPattribute (*a_43location, (STEPentityH *) &_location);
    a -> set_null ();
    attributes.push (a);
}
SdaiPlacement::SdaiPlacement (SdaiPlacement& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPlacement::~SdaiPlacement () {  }
SdaiPlacement::SdaiPlacement (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_placement;

    STEPattribute * a = new STEPattribute (*a_43location, (STEPentityH *) &_location);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCartesian_pointH 
SdaiPlacement::Location() const 
	{ return (SdaiCartesian_pointH) _location; }

void 
SdaiPlacement::Location (SdaiCartesian_pointH x)
	{ _location = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY placement 


/////////	 ENTITY axis2_placement_2d 

EntityDescriptor *config_control_designe_axis2_placement_2d =0;
AttrDescriptor *a_44ref_direction =0;
AttrDescriptor *a_45Dp =0;
SdaiAxis2_placement_2d::SdaiAxis2_placement_2d( ) 
{

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_2d;

    STEPattribute * a = new STEPattribute (*a_44ref_direction, (STEPentityH *) &_ref_direction);
    a -> set_null ();
    attributes.push (a);
}
SdaiAxis2_placement_2d::SdaiAxis2_placement_2d (SdaiAxis2_placement_2d& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAxis2_placement_2d::~SdaiAxis2_placement_2d () {  }
SdaiAxis2_placement_2d::SdaiAxis2_placement_2d (STEPentity *se ) : SdaiPlacement(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_2d;

    STEPattribute * a = new STEPattribute (*a_44ref_direction, (STEPentityH *) &_ref_direction);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDirectionH 
SdaiAxis2_placement_2d::Ref_direction() const 
	{ return (SdaiDirectionH) _ref_direction; }

void 
SdaiAxis2_placement_2d::Ref_direction (SdaiDirectionH x)
	{ _ref_direction = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY axis2_placement_2d 


/////////	 ENTITY product_category 

EntityDescriptor *config_control_designe_product_category =0;
AttrDescriptor *a_46name =0;
AttrDescriptor *a_47description =0;
SdaiProduct_category::SdaiProduct_category( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category;

    STEPattribute * a = new STEPattribute (*a_46name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_47description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_category::SdaiProduct_category (SdaiProduct_category& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_category::~SdaiProduct_category () {  }
SdaiProduct_category::SdaiProduct_category( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category;

    STEPattribute * a = new STEPattribute (*a_46name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_47description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiProduct_category::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiProduct_category::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiProduct_category::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProduct_category::Description (const char * x)
	{ _description = x; }

/////////	 END_ENTITY product_category 


/////////	 ENTITY product_related_product_category 

EntityDescriptor *config_control_designe_product_related_product_category =0;
AttrDescriptor *a_48products =0;
SdaiProduct_related_product_category::SdaiProduct_related_product_category( ) 
{

	/*  parent: SdaiProduct_category  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_related_product_category;

    STEPattribute * a = new STEPattribute (*a_48products,  &_products);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_related_product_category::SdaiProduct_related_product_category (SdaiProduct_related_product_category& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_related_product_category::~SdaiProduct_related_product_category () {  }
SdaiProduct_related_product_category::SdaiProduct_related_product_category (STEPentity *se ) : SdaiProduct_category(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_category  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_related_product_category;

    STEPattribute * a = new STEPattribute (*a_48products,  &_products);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiProduct_related_product_category::Products() const 
	{ return (EntityAggregateH) &_products; }

void 
SdaiProduct_related_product_category::Products (EntityAggregateH x)
	{ _products.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_related_product_category 


/////////	 ENTITY curve 

EntityDescriptor *config_control_designe_curve =0;
SdaiCurve::SdaiCurve( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve;
}
SdaiCurve::SdaiCurve (SdaiCurve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCurve::~SdaiCurve () {  }
SdaiCurve::SdaiCurve (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY curve 


/////////	 ENTITY conic 

EntityDescriptor *config_control_designe_conic =0;
AttrDescriptor *a_49position =0;
SdaiConic::SdaiConic( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conic;

    STEPattribute * a = new STEPattribute (*a_49position,  &_position);
    a -> set_null ();
    attributes.push (a);
}
SdaiConic::SdaiConic (SdaiConic& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConic::~SdaiConic () {  }
SdaiConic::SdaiConic (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conic;

    STEPattribute * a = new STEPattribute (*a_49position,  &_position);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiAxis2_placementH 
SdaiConic::Position() const 
	{ return (const SdaiAxis2_placementH) &_position; }

void 
SdaiConic::Position (SdaiAxis2_placementH x)
	{ _position = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY conic 


/////////	 ENTITY hyperbola 

EntityDescriptor *config_control_designe_hyperbola =0;
AttrDescriptor *a_50semi_axis =0;
AttrDescriptor *a_51semi_imag_axis =0;
SdaiHyperbola::SdaiHyperbola( ) 
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_hyperbola;

    STEPattribute * a = new STEPattribute (*a_50semi_axis,  &_semi_axis);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_51semi_imag_axis,  &_semi_imag_axis);
    a -> set_null ();
    attributes.push (a);
}
SdaiHyperbola::SdaiHyperbola (SdaiHyperbola& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiHyperbola::~SdaiHyperbola () {  }
SdaiHyperbola::SdaiHyperbola (STEPentity *se ) : SdaiConic(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_hyperbola;

    STEPattribute * a = new STEPattribute (*a_50semi_axis,  &_semi_axis);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_51semi_imag_axis,  &_semi_imag_axis);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPositive_length_measure 
SdaiHyperbola::Semi_axis() const 
	{ return (const SdaiPositive_length_measure) _semi_axis; }

void 
SdaiHyperbola::Semi_axis (SdaiPositive_length_measure x)
	{ _semi_axis = x; }

const SdaiPositive_length_measure 
SdaiHyperbola::Semi_imag_axis() const 
	{ return (const SdaiPositive_length_measure) _semi_imag_axis; }

void 
SdaiHyperbola::Semi_imag_axis (SdaiPositive_length_measure x)
	{ _semi_imag_axis = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY hyperbola 


/////////	 ENTITY address 

EntityDescriptor *config_control_designe_address =0;
AttrDescriptor *a_52internal_location =0;
AttrDescriptor *a_53street_number =0;
AttrDescriptor *a_54street =0;
AttrDescriptor *a_55postal_box =0;
AttrDescriptor *a_56town =0;
AttrDescriptor *a_57region =0;
AttrDescriptor *a_58postal_code =0;
AttrDescriptor *a_59country =0;
AttrDescriptor *a_60facsimile_number =0;
AttrDescriptor *a_61telephone_number =0;
AttrDescriptor *a_62electronic_mail_address =0;
AttrDescriptor *a_63telex_number =0;
SdaiAddress::SdaiAddress( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_address;

    STEPattribute * a = new STEPattribute (*a_52internal_location,  &_internal_location);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_53street_number,  &_street_number);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_54street,  &_street);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_55postal_box,  &_postal_box);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_56town,  &_town);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_57region,  &_region);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_58postal_code,  &_postal_code);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_59country,  &_country);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_60facsimile_number,  &_facsimile_number);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_61telephone_number,  &_telephone_number);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_62electronic_mail_address,  &_electronic_mail_address);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_63telex_number,  &_telex_number);
    a -> set_null ();
    attributes.push (a);
}
SdaiAddress::SdaiAddress (SdaiAddress& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAddress::~SdaiAddress () {  }
SdaiAddress::SdaiAddress( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_address;

    STEPattribute * a = new STEPattribute (*a_52internal_location,  &_internal_location);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_53street_number,  &_street_number);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_54street,  &_street);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_55postal_box,  &_postal_box);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_56town,  &_town);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_57region,  &_region);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_58postal_code,  &_postal_code);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_59country,  &_country);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_60facsimile_number,  &_facsimile_number);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_61telephone_number,  &_telephone_number);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_62electronic_mail_address,  &_electronic_mail_address);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_63telex_number,  &_telex_number);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAddress::Internal_location() const
	{ return (const SdaiLabel) _internal_location; }

void 
SdaiAddress::Internal_location (const char * x)
	{ _internal_location = x; }

const SdaiLabel 
SdaiAddress::Street_number() const
	{ return (const SdaiLabel) _street_number; }

void 
SdaiAddress::Street_number (const char * x)
	{ _street_number = x; }

const SdaiLabel 
SdaiAddress::Street() const
	{ return (const SdaiLabel) _street; }

void 
SdaiAddress::Street (const char * x)
	{ _street = x; }

const SdaiLabel 
SdaiAddress::Postal_box() const
	{ return (const SdaiLabel) _postal_box; }

void 
SdaiAddress::Postal_box (const char * x)
	{ _postal_box = x; }

const SdaiLabel 
SdaiAddress::Town() const
	{ return (const SdaiLabel) _town; }

void 
SdaiAddress::Town (const char * x)
	{ _town = x; }

const SdaiLabel 
SdaiAddress::Region() const
	{ return (const SdaiLabel) _region; }

void 
SdaiAddress::Region (const char * x)
	{ _region = x; }

const SdaiLabel 
SdaiAddress::Postal_code() const
	{ return (const SdaiLabel) _postal_code; }

void 
SdaiAddress::Postal_code (const char * x)
	{ _postal_code = x; }

const SdaiLabel 
SdaiAddress::Country() const
	{ return (const SdaiLabel) _country; }

void 
SdaiAddress::Country (const char * x)
	{ _country = x; }

const SdaiLabel 
SdaiAddress::Facsimile_number() const
	{ return (const SdaiLabel) _facsimile_number; }

void 
SdaiAddress::Facsimile_number (const char * x)
	{ _facsimile_number = x; }

const SdaiLabel 
SdaiAddress::Telephone_number() const
	{ return (const SdaiLabel) _telephone_number; }

void 
SdaiAddress::Telephone_number (const char * x)
	{ _telephone_number = x; }

const SdaiLabel 
SdaiAddress::Electronic_mail_address() const
	{ return (const SdaiLabel) _electronic_mail_address; }

void 
SdaiAddress::Electronic_mail_address (const char * x)
	{ _electronic_mail_address = x; }

const SdaiLabel 
SdaiAddress::Telex_number() const
	{ return (const SdaiLabel) _telex_number; }

void 
SdaiAddress::Telex_number (const char * x)
	{ _telex_number = x; }

/////////	 END_ENTITY address 


/////////	 ENTITY organizational_address 

EntityDescriptor *config_control_designe_organizational_address =0;
AttrDescriptor *a_64organizations =0;
AttrDescriptor *a_65description =0;
SdaiOrganizational_address::SdaiOrganizational_address( ) 
{

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_organizational_address;

    STEPattribute * a = new STEPattribute (*a_64organizations,  &_organizations);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_65description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganizational_address::SdaiOrganizational_address (SdaiOrganizational_address& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOrganizational_address::~SdaiOrganizational_address () {  }
SdaiOrganizational_address::SdaiOrganizational_address (STEPentity *se ) : SdaiAddress(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_organizational_address;

    STEPattribute * a = new STEPattribute (*a_64organizations,  &_organizations);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_65description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiOrganizational_address::Organizations() const 
	{ return (EntityAggregateH) &_organizations; }

void 
SdaiOrganizational_address::Organizations (EntityAggregateH x)
	{ _organizations.ShallowCopy (*x); }

const SdaiText 
SdaiOrganizational_address::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiOrganizational_address::Description (const char * x)
	{ _description = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY organizational_address 


/////////	 ENTITY bounded_surface 

EntityDescriptor *config_control_designe_bounded_surface =0;
SdaiBounded_surface::SdaiBounded_surface( ) 
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_surface;
}
SdaiBounded_surface::SdaiBounded_surface (SdaiBounded_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiBounded_surface::~SdaiBounded_surface () {  }
SdaiBounded_surface::SdaiBounded_surface (STEPentity *se ) : SdaiSurface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_surface;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bounded_surface 


/////////	 ENTITY b_spline_surface 

EntityDescriptor *config_control_designe_b_spline_surface =0;
AttrDescriptor *a_66u_degree =0;
AttrDescriptor *a_67v_degree =0;
AttrDescriptor *a_68control_points_list =0;
AttrDescriptor *a_69surface_form =0;
AttrDescriptor *a_70u_closed =0;
AttrDescriptor *a_71v_closed =0;
AttrDescriptor *a_72self_intersect =0;
AttrDescriptor *a_73Du_upper =0;
AttrDescriptor *a_74Dv_upper =0;
AttrDescriptor *a_75Dcontrol_points =0;
SdaiB_spline_surface::SdaiB_spline_surface( ) 
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface;

    STEPattribute * a = new STEPattribute (*a_66u_degree,  &_u_degree);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_67v_degree,  &_v_degree);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_68control_points_list,  &_control_points_list);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_69surface_form,  &_surface_form);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_70u_closed,  &_u_closed);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_71v_closed,  &_v_closed);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_72self_intersect,  &_self_intersect);
    a -> set_null ();
    attributes.push (a);
}
SdaiB_spline_surface::SdaiB_spline_surface (SdaiB_spline_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiB_spline_surface::~SdaiB_spline_surface () {  }
SdaiB_spline_surface::SdaiB_spline_surface (STEPentity *se ) : SdaiBounded_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface;

    STEPattribute * a = new STEPattribute (*a_66u_degree,  &_u_degree);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_67v_degree,  &_v_degree);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_68control_points_list,  &_control_points_list);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_69surface_form,  &_surface_form);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_70u_closed,  &_u_closed);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_71v_closed,  &_v_closed);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_72self_intersect,  &_self_intersect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiInteger 
SdaiB_spline_surface::U_degree() const 
	{ return (const SdaiInteger) _u_degree; }

void 
SdaiB_spline_surface::U_degree (SdaiInteger x)
	{ _u_degree = x; }

const SdaiInteger 
SdaiB_spline_surface::V_degree() const 
	{ return (const SdaiInteger) _v_degree; }

void 
SdaiB_spline_surface::V_degree (SdaiInteger x)
	{ _v_degree = x; }

const GenericAggregateH 
SdaiB_spline_surface::Control_points_list() const 
	{ return (GenericAggregateH) &_control_points_list; }

void 
SdaiB_spline_surface::Control_points_list (GenericAggregateH x)
	{ _control_points_list.ShallowCopy (*x); }

const sdaiB_spline_surface_form  
SdaiB_spline_surface::Surface_form() const 
	{ return (sdaiB_spline_surface_form) _surface_form; }

void 
SdaiB_spline_surface::Surface_form (sdaiB_spline_surface_form x)
	{ _surface_form.put (x); }

const LOGICAL 
SdaiB_spline_surface::U_closed() const 
	{ return (LOGICAL) _u_closed; }

void 
SdaiB_spline_surface::U_closed (LOGICAL x)
	{ _u_closed.put (x); }

const LOGICAL 
SdaiB_spline_surface::V_closed() const 
	{ return (LOGICAL) _v_closed; }

void 
SdaiB_spline_surface::V_closed (LOGICAL x)
	{ _v_closed.put (x); }

const LOGICAL 
SdaiB_spline_surface::Self_intersect() const 
	{ return (LOGICAL) _self_intersect; }

void 
SdaiB_spline_surface::Self_intersect (LOGICAL x)
	{ _self_intersect.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_surface 


/////////	 ENTITY uniform_surface 

EntityDescriptor *config_control_designe_uniform_surface =0;
SdaiUniform_surface::SdaiUniform_surface( ) 
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_surface;
}
SdaiUniform_surface::SdaiUniform_surface (SdaiUniform_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiUniform_surface::~SdaiUniform_surface () {  }
SdaiUniform_surface::SdaiUniform_surface (STEPentity *se ) : SdaiB_spline_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_surface;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY uniform_surface 


/////////	 ENTITY geometrically_bounded_surface_shape_representation 

EntityDescriptor *config_control_designe_geometrically_bounded_surface_shape_representation =0;
SdaiGeometrically_bounded_surface_shape_representation::SdaiGeometrically_bounded_surface_shape_representation( ) 
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_surface_shape_representation;
}
SdaiGeometrically_bounded_surface_shape_representation::SdaiGeometrically_bounded_surface_shape_representation (SdaiGeometrically_bounded_surface_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGeometrically_bounded_surface_shape_representation::~SdaiGeometrically_bounded_surface_shape_representation () {  }
SdaiGeometrically_bounded_surface_shape_representation::SdaiGeometrically_bounded_surface_shape_representation (STEPentity *se ) : SdaiShape_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_surface_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometrically_bounded_surface_shape_representation 


/////////	 ENTITY axis1_placement 

EntityDescriptor *config_control_designe_axis1_placement =0;
AttrDescriptor *a_76axis =0;
AttrDescriptor *a_77Dz =0;
SdaiAxis1_placement::SdaiAxis1_placement( ) 
{

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis1_placement;

    STEPattribute * a = new STEPattribute (*a_76axis, (STEPentityH *) &_axis);
    a -> set_null ();
    attributes.push (a);
}
SdaiAxis1_placement::SdaiAxis1_placement (SdaiAxis1_placement& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAxis1_placement::~SdaiAxis1_placement () {  }
SdaiAxis1_placement::SdaiAxis1_placement (STEPentity *se ) : SdaiPlacement(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis1_placement;

    STEPattribute * a = new STEPattribute (*a_76axis, (STEPentityH *) &_axis);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDirectionH 
SdaiAxis1_placement::Axis() const 
	{ return (SdaiDirectionH) _axis; }

void 
SdaiAxis1_placement::Axis (SdaiDirectionH x)
	{ _axis = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY axis1_placement 


/////////	 ENTITY bounded_curve 

EntityDescriptor *config_control_designe_bounded_curve =0;
SdaiBounded_curve::SdaiBounded_curve( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_curve;
}
SdaiBounded_curve::SdaiBounded_curve (SdaiBounded_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiBounded_curve::~SdaiBounded_curve () {  }
SdaiBounded_curve::SdaiBounded_curve (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bounded_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bounded_curve 


/////////	 ENTITY b_spline_curve 

EntityDescriptor *config_control_designe_b_spline_curve =0;
AttrDescriptor *a_78degree =0;
AttrDescriptor *a_79control_points_list =0;
AttrDescriptor *a_80curve_form =0;
AttrDescriptor *a_81closed_curve =0;
AttrDescriptor *a_82self_intersect =0;
AttrDescriptor *a_83Dupper_index_on_control_points =0;
AttrDescriptor *a_84Dcontrol_points =0;
SdaiB_spline_curve::SdaiB_spline_curve( ) 
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve;

    STEPattribute * a = new STEPattribute (*a_78degree,  &_degree);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_79control_points_list,  &_control_points_list);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_80curve_form,  &_curve_form);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_81closed_curve,  &_closed_curve);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_82self_intersect,  &_self_intersect);
    a -> set_null ();
    attributes.push (a);
}
SdaiB_spline_curve::SdaiB_spline_curve (SdaiB_spline_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiB_spline_curve::~SdaiB_spline_curve () {  }
SdaiB_spline_curve::SdaiB_spline_curve (STEPentity *se ) : SdaiBounded_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve;

    STEPattribute * a = new STEPattribute (*a_78degree,  &_degree);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_79control_points_list,  &_control_points_list);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_80curve_form,  &_curve_form);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_81closed_curve,  &_closed_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_82self_intersect,  &_self_intersect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiInteger 
SdaiB_spline_curve::Degree() const 
	{ return (const SdaiInteger) _degree; }

void 
SdaiB_spline_curve::Degree (SdaiInteger x)
	{ _degree = x; }

const EntityAggregateH 
SdaiB_spline_curve::Control_points_list() const 
	{ return (EntityAggregateH) &_control_points_list; }

void 
SdaiB_spline_curve::Control_points_list (EntityAggregateH x)
	{ _control_points_list.ShallowCopy (*x); }

const sdaiB_spline_curve_form  
SdaiB_spline_curve::Curve_form() const 
	{ return (sdaiB_spline_curve_form) _curve_form; }

void 
SdaiB_spline_curve::Curve_form (sdaiB_spline_curve_form x)
	{ _curve_form.put (x); }

const LOGICAL 
SdaiB_spline_curve::Closed_curve() const 
	{ return (LOGICAL) _closed_curve; }

void 
SdaiB_spline_curve::Closed_curve (LOGICAL x)
	{ _closed_curve.put (x); }

const LOGICAL 
SdaiB_spline_curve::Self_intersect() const 
	{ return (LOGICAL) _self_intersect; }

void 
SdaiB_spline_curve::Self_intersect (LOGICAL x)
	{ _self_intersect.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_curve 


/////////	 ENTITY rational_b_spline_curve 

EntityDescriptor *config_control_designe_rational_b_spline_curve =0;
AttrDescriptor *a_85weights_data =0;
AttrDescriptor *a_86Dweights =0;
SdaiRational_b_spline_curve::SdaiRational_b_spline_curve( ) 
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_curve;

    STEPattribute * a = new STEPattribute (*a_85weights_data,  &_weights_data);
    a -> set_null ();
    attributes.push (a);
}
SdaiRational_b_spline_curve::SdaiRational_b_spline_curve (SdaiRational_b_spline_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRational_b_spline_curve::~SdaiRational_b_spline_curve () {  }
SdaiRational_b_spline_curve::SdaiRational_b_spline_curve (STEPentity *se ) : SdaiB_spline_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_curve;

    STEPattribute * a = new STEPattribute (*a_85weights_data,  &_weights_data);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const RealAggregateH 
SdaiRational_b_spline_curve::Weights_data() const 
	{ return (RealAggregateH) &_weights_data; }

void 
SdaiRational_b_spline_curve::Weights_data (RealAggregateH x)
	{ _weights_data.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rational_b_spline_curve 


/////////	 ENTITY action_request_assignment 

EntityDescriptor *config_control_designe_action_request_assignment =0;
AttrDescriptor *a_87assigned_action_request =0;
SdaiAction_request_assignment::SdaiAction_request_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_assignment;

    STEPattribute * a = new STEPattribute (*a_87assigned_action_request, (STEPentityH *) &_assigned_action_request);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_request_assignment::SdaiAction_request_assignment (SdaiAction_request_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction_request_assignment::~SdaiAction_request_assignment () {  }
SdaiAction_request_assignment::SdaiAction_request_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_assignment;

    STEPattribute * a = new STEPattribute (*a_87assigned_action_request, (STEPentityH *) &_assigned_action_request);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiVersioned_action_requestH 
SdaiAction_request_assignment::Assigned_action_request() const 
	{ return (SdaiVersioned_action_requestH) _assigned_action_request; }

void 
SdaiAction_request_assignment::Assigned_action_request (SdaiVersioned_action_requestH x)
	{ _assigned_action_request = x; }

/////////	 END_ENTITY action_request_assignment 


/////////	 ENTITY topological_representation_item 

EntityDescriptor *config_control_designe_topological_representation_item =0;
SdaiTopological_representation_item::SdaiTopological_representation_item( ) 
{

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_topological_representation_item;
}
SdaiTopological_representation_item::SdaiTopological_representation_item (SdaiTopological_representation_item& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiTopological_representation_item::~SdaiTopological_representation_item () {  }
SdaiTopological_representation_item::SdaiTopological_representation_item (STEPentity *se ) : SdaiRepresentation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_topological_representation_item;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY topological_representation_item 


/////////	 ENTITY face_bound 

EntityDescriptor *config_control_designe_face_bound =0;
AttrDescriptor *a_88bound =0;
AttrDescriptor *a_89orientation =0;
SdaiFace_bound::SdaiFace_bound( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_bound;

    STEPattribute * a = new STEPattribute (*a_88bound, (STEPentityH *) &_bound);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_89orientation,  &_orientation);
    a -> set_null ();
    attributes.push (a);
}
SdaiFace_bound::SdaiFace_bound (SdaiFace_bound& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiFace_bound::~SdaiFace_bound () {  }
SdaiFace_bound::SdaiFace_bound (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_bound;

    STEPattribute * a = new STEPattribute (*a_88bound, (STEPentityH *) &_bound);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_89orientation,  &_orientation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiLoopH 
SdaiFace_bound::Bound() const 
	{ return (SdaiLoopH) _bound; }

void 
SdaiFace_bound::Bound (SdaiLoopH x)
	{ _bound = x; }

const BOOLEAN 
SdaiFace_bound::Orientation() const 
	{ return (LOGICAL) _orientation; }

void 
SdaiFace_bound::Orientation (BOOLEAN x)
	{ _orientation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY face_bound 


/////////	 ENTITY length_measure_with_unit 

EntityDescriptor *config_control_designe_length_measure_with_unit =0;
SdaiLength_measure_with_unit::SdaiLength_measure_with_unit( ) 
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_measure_with_unit;
}
SdaiLength_measure_with_unit::SdaiLength_measure_with_unit (SdaiLength_measure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiLength_measure_with_unit::~SdaiLength_measure_with_unit () {  }
SdaiLength_measure_with_unit::SdaiLength_measure_with_unit (STEPentity *se ) : SdaiMeasure_with_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY length_measure_with_unit 


/////////	 ENTITY dated_effectivity 

EntityDescriptor *config_control_designe_dated_effectivity =0;
AttrDescriptor *a_90effectivity_start_date =0;
AttrDescriptor *a_91effectivity_end_date =0;
SdaiDated_effectivity::SdaiDated_effectivity( ) 
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_dated_effectivity;

    STEPattribute * a = new STEPattribute (*a_90effectivity_start_date, (STEPentityH *) &_effectivity_start_date);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_91effectivity_end_date, (STEPentityH *) &_effectivity_end_date);
    a -> set_null ();
    attributes.push (a);
}
SdaiDated_effectivity::SdaiDated_effectivity (SdaiDated_effectivity& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDated_effectivity::~SdaiDated_effectivity () {  }
SdaiDated_effectivity::SdaiDated_effectivity (STEPentity *se ) : SdaiEffectivity(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_dated_effectivity;

    STEPattribute * a = new STEPattribute (*a_90effectivity_start_date, (STEPentityH *) &_effectivity_start_date);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_91effectivity_end_date, (STEPentityH *) &_effectivity_end_date);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDate_and_timeH 
SdaiDated_effectivity::Effectivity_start_date() const 
	{ return (SdaiDate_and_timeH) _effectivity_start_date; }

void 
SdaiDated_effectivity::Effectivity_start_date (SdaiDate_and_timeH x)
	{ _effectivity_start_date = x; }

SdaiDate_and_timeH 
SdaiDated_effectivity::Effectivity_end_date() const 
	{ return (SdaiDate_and_timeH) _effectivity_end_date; }

void 
SdaiDated_effectivity::Effectivity_end_date (SdaiDate_and_timeH x)
	{ _effectivity_end_date = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY dated_effectivity 


/////////	 ENTITY direction 

EntityDescriptor *config_control_designe_direction =0;
AttrDescriptor *a_92direction_ratios =0;
SdaiDirection::SdaiDirection( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_direction;

    STEPattribute * a = new STEPattribute (*a_92direction_ratios,  &_direction_ratios);
    a -> set_null ();
    attributes.push (a);
}
SdaiDirection::SdaiDirection (SdaiDirection& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDirection::~SdaiDirection () {  }
SdaiDirection::SdaiDirection (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_direction;

    STEPattribute * a = new STEPattribute (*a_92direction_ratios,  &_direction_ratios);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const RealAggregateH 
SdaiDirection::Direction_ratios() const 
	{ return (RealAggregateH) &_direction_ratios; }

void 
SdaiDirection::Direction_ratios (RealAggregateH x)
	{ _direction_ratios.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY direction 


/////////	 ENTITY next_assembly_usage_occurrence 

EntityDescriptor *config_control_designe_next_assembly_usage_occurrence =0;
SdaiNext_assembly_usage_occurrence::SdaiNext_assembly_usage_occurrence( ) 
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_next_assembly_usage_occurrence;
}
SdaiNext_assembly_usage_occurrence::SdaiNext_assembly_usage_occurrence (SdaiNext_assembly_usage_occurrence& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiNext_assembly_usage_occurrence::~SdaiNext_assembly_usage_occurrence () {  }
SdaiNext_assembly_usage_occurrence::SdaiNext_assembly_usage_occurrence (STEPentity *se ) : SdaiAssembly_component_usage(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_next_assembly_usage_occurrence;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY next_assembly_usage_occurrence 


/////////	 ENTITY edge 

EntityDescriptor *config_control_designe_edge =0;
AttrDescriptor *a_93edge_start =0;
AttrDescriptor *a_94edge_end =0;
SdaiEdge::SdaiEdge( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge;

    STEPattribute * a = new STEPattribute (*a_93edge_start, (STEPentityH *) &_edge_start);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_94edge_end, (STEPentityH *) &_edge_end);
    a -> set_null ();
    attributes.push (a);
}
SdaiEdge::SdaiEdge (SdaiEdge& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEdge::~SdaiEdge () {  }
SdaiEdge::SdaiEdge (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge;

    STEPattribute * a = new STEPattribute (*a_93edge_start, (STEPentityH *) &_edge_start);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_94edge_end, (STEPentityH *) &_edge_end);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiVertexH 
SdaiEdge::Edge_start() const 
	{ return (SdaiVertexH) _edge_start; }

void 
SdaiEdge::Edge_start (SdaiVertexH x)
	{ _edge_start = x; }

SdaiVertexH 
SdaiEdge::Edge_end() const 
	{ return (SdaiVertexH) _edge_end; }

void 
SdaiEdge::Edge_end (SdaiVertexH x)
	{ _edge_end = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY edge 


/////////	 ENTITY oriented_edge 

EntityDescriptor *config_control_designe_oriented_edge =0;
AttrDescriptor *a_95edge_element =0;
AttrDescriptor *a_96orientation =0;
AttrDescriptor *a_97Dedge_edge_start =0;
AttrDescriptor *a_98Dedge_edge_end =0;
SdaiOriented_edge::SdaiOriented_edge( ) 
{

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_edge;

    STEPattribute * a = new STEPattribute (*a_95edge_element, (STEPentityH *) &_edge_element);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_96orientation,  &_orientation);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("edge_start");
    MakeDerived ("edge_end");
}
SdaiOriented_edge::SdaiOriented_edge (SdaiOriented_edge& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOriented_edge::~SdaiOriented_edge () {  }
SdaiOriented_edge::SdaiOriented_edge (STEPentity *se ) : SdaiEdge(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_edge;

    STEPattribute * a = new STEPattribute (*a_95edge_element, (STEPentityH *) &_edge_element);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_96orientation,  &_orientation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("edge_start");
    MakeDerived ("edge_end");
}

SdaiEdgeH 
SdaiOriented_edge::Edge_element() const 
	{ return (SdaiEdgeH) _edge_element; }

void 
SdaiOriented_edge::Edge_element (SdaiEdgeH x)
	{ _edge_element = x; }

const BOOLEAN 
SdaiOriented_edge::Orientation() const 
	{ return (LOGICAL) _orientation; }

void 
SdaiOriented_edge::Orientation (BOOLEAN x)
	{ _orientation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_edge 


/////////	 ENTITY person 

EntityDescriptor *config_control_designe_person =0;
AttrDescriptor *a_99id =0;
AttrDescriptor *a_100last_name =0;
AttrDescriptor *a_101first_name =0;
AttrDescriptor *a_102middle_names =0;
AttrDescriptor *a_103prefix_titles =0;
AttrDescriptor *a_104suffix_titles =0;
SdaiPerson::SdaiPerson( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person;

    STEPattribute * a = new STEPattribute (*a_99id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_100last_name,  &_last_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_101first_name,  &_first_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_102middle_names,  &_middle_names);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_103prefix_titles,  &_prefix_titles);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_104suffix_titles,  &_suffix_titles);
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson::SdaiPerson (SdaiPerson& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPerson::~SdaiPerson () {  }
SdaiPerson::SdaiPerson( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_person;

    STEPattribute * a = new STEPattribute (*a_99id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_100last_name,  &_last_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_101first_name,  &_first_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_102middle_names,  &_middle_names);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_103prefix_titles,  &_prefix_titles);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_104suffix_titles,  &_suffix_titles);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiPerson::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiPerson::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiPerson::Last_name() const
	{ return (const SdaiLabel) _last_name; }

void 
SdaiPerson::Last_name (const char * x)
	{ _last_name = x; }

const SdaiLabel 
SdaiPerson::First_name() const
	{ return (const SdaiLabel) _first_name; }

void 
SdaiPerson::First_name (const char * x)
	{ _first_name = x; }

const StringAggregateH 
SdaiPerson::Middle_names() const 
	{ return (StringAggregateH) &_middle_names; }

void 
SdaiPerson::Middle_names (StringAggregateH x)
	{ _middle_names.ShallowCopy (*x); }

const StringAggregateH 
SdaiPerson::Prefix_titles() const 
	{ return (StringAggregateH) &_prefix_titles; }

void 
SdaiPerson::Prefix_titles (StringAggregateH x)
	{ _prefix_titles.ShallowCopy (*x); }

const StringAggregateH 
SdaiPerson::Suffix_titles() const 
	{ return (StringAggregateH) &_suffix_titles; }

void 
SdaiPerson::Suffix_titles (StringAggregateH x)
	{ _suffix_titles.ShallowCopy (*x); }

/////////	 END_ENTITY person 


/////////	 ENTITY document 

EntityDescriptor *config_control_designe_document =0;
AttrDescriptor *a_105id =0;
AttrDescriptor *a_106name =0;
AttrDescriptor *a_107description =0;
AttrDescriptor *a_108kind =0;
SdaiDocument::SdaiDocument( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document;

    STEPattribute * a = new STEPattribute (*a_105id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_106name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_107description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_108kind, (STEPentityH *) &_kind);
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument::SdaiDocument (SdaiDocument& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDocument::~SdaiDocument () {  }
SdaiDocument::SdaiDocument( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_document;

    STEPattribute * a = new STEPattribute (*a_105id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_106name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_107description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_108kind, (STEPentityH *) &_kind);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiDocument::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiDocument::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiDocument::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiDocument::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiDocument::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiDocument::Description (const char * x)
	{ _description = x; }

SdaiDocument_typeH 
SdaiDocument::Kind() const 
	{ return (SdaiDocument_typeH) _kind; }

void 
SdaiDocument::Kind (SdaiDocument_typeH x)
	{ _kind = x; }

/////////	 END_ENTITY document 


/////////	 ENTITY document_with_class 

EntityDescriptor *config_control_designe_document_with_class =0;
AttrDescriptor *a_109class =0;
SdaiDocument_with_class::SdaiDocument_with_class( ) 
{

	/*  parent: SdaiDocument  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_document_with_class;

    STEPattribute * a = new STEPattribute (*a_109class,  &_class);
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_with_class::SdaiDocument_with_class (SdaiDocument_with_class& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDocument_with_class::~SdaiDocument_with_class () {  }
SdaiDocument_with_class::SdaiDocument_with_class (STEPentity *se ) : SdaiDocument(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiDocument  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_document_with_class;

    STEPattribute * a = new STEPattribute (*a_109class,  &_class);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiDocument_with_class::Class() const
	{ return (const SdaiIdentifier) _class; }

void 
SdaiDocument_with_class::Class (const char * x)
	{ _class = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY document_with_class 


/////////	 ENTITY conversion_based_unit 

EntityDescriptor *config_control_designe_conversion_based_unit =0;
AttrDescriptor *a_110name =0;
AttrDescriptor *a_111conversion_factor =0;
SdaiConversion_based_unit::SdaiConversion_based_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conversion_based_unit;

    STEPattribute * a = new STEPattribute (*a_110name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_111conversion_factor, (STEPentityH *) &_conversion_factor);
    a -> set_null ();
    attributes.push (a);
}
SdaiConversion_based_unit::SdaiConversion_based_unit (SdaiConversion_based_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConversion_based_unit::~SdaiConversion_based_unit () {  }
SdaiConversion_based_unit::SdaiConversion_based_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conversion_based_unit;

    STEPattribute * a = new STEPattribute (*a_110name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_111conversion_factor, (STEPentityH *) &_conversion_factor);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiConversion_based_unit::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiConversion_based_unit::Name (const char * x)
	{ _name = x; }

SdaiMeasure_with_unitH 
SdaiConversion_based_unit::Conversion_factor() const 
	{ return (SdaiMeasure_with_unitH) _conversion_factor; }

void 
SdaiConversion_based_unit::Conversion_factor (SdaiMeasure_with_unitH x)
	{ _conversion_factor = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY conversion_based_unit 


/////////	 ENTITY point 

EntityDescriptor *config_control_designe_point =0;
SdaiPoint::SdaiPoint( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point;
}
SdaiPoint::SdaiPoint (SdaiPoint& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPoint::~SdaiPoint () {  }
SdaiPoint::SdaiPoint (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point 


/////////	 ENTITY point_on_surface 

EntityDescriptor *config_control_designe_point_on_surface =0;
AttrDescriptor *a_112basis_surface =0;
AttrDescriptor *a_113point_parameter_u =0;
AttrDescriptor *a_114point_parameter_v =0;
SdaiPoint_on_surface::SdaiPoint_on_surface( ) 
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_surface;

    STEPattribute * a = new STEPattribute (*a_112basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_113point_parameter_u,  &_point_parameter_u);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_114point_parameter_v,  &_point_parameter_v);
    a -> set_null ();
    attributes.push (a);
}
SdaiPoint_on_surface::SdaiPoint_on_surface (SdaiPoint_on_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPoint_on_surface::~SdaiPoint_on_surface () {  }
SdaiPoint_on_surface::SdaiPoint_on_surface (STEPentity *se ) : SdaiPoint(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_surface;

    STEPattribute * a = new STEPattribute (*a_112basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_113point_parameter_u,  &_point_parameter_u);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_114point_parameter_v,  &_point_parameter_v);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiPoint_on_surface::Basis_surface() const 
	{ return (SdaiSurfaceH) _basis_surface; }

void 
SdaiPoint_on_surface::Basis_surface (SdaiSurfaceH x)
	{ _basis_surface = x; }

const SdaiParameter_value 
SdaiPoint_on_surface::Point_parameter_u() const 
	{ return (const SdaiParameter_value) _point_parameter_u; }

void 
SdaiPoint_on_surface::Point_parameter_u (SdaiParameter_value x)
	{ _point_parameter_u = x; }

const SdaiParameter_value 
SdaiPoint_on_surface::Point_parameter_v() const 
	{ return (const SdaiParameter_value) _point_parameter_v; }

void 
SdaiPoint_on_surface::Point_parameter_v (SdaiParameter_value x)
	{ _point_parameter_v = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point_on_surface 


/////////	 ENTITY product_definition_formation 

EntityDescriptor *config_control_designe_product_definition_formation =0;
AttrDescriptor *a_115id =0;
AttrDescriptor *a_116description =0;
AttrDescriptor *a_117of_product =0;
SdaiProduct_definition_formation::SdaiProduct_definition_formation( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_formation;

    STEPattribute * a = new STEPattribute (*a_115id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_116description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_117of_product, (STEPentityH *) &_of_product);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_formation::SdaiProduct_definition_formation (SdaiProduct_definition_formation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_formation::~SdaiProduct_definition_formation () {  }
SdaiProduct_definition_formation::SdaiProduct_definition_formation( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition_formation;

    STEPattribute * a = new STEPattribute (*a_115id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_116description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_117of_product, (STEPentityH *) &_of_product);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiProduct_definition_formation::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiProduct_definition_formation::Id (const char * x)
	{ _id = x; }

const SdaiText 
SdaiProduct_definition_formation::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProduct_definition_formation::Description (const char * x)
	{ _description = x; }

SdaiProductH 
SdaiProduct_definition_formation::Of_product() const 
	{ return (SdaiProductH) _of_product; }

void 
SdaiProduct_definition_formation::Of_product (SdaiProductH x)
	{ _of_product = x; }

/////////	 END_ENTITY product_definition_formation 


/////////	 ENTITY person_and_organization_assignment 

EntityDescriptor *config_control_designe_person_and_organization_assignment =0;
AttrDescriptor *a_118assigned_person_and_organization =0;
AttrDescriptor *a_119role =0;
SdaiPerson_and_organization_assignment::SdaiPerson_and_organization_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_assignment;

    STEPattribute * a = new STEPattribute (*a_118assigned_person_and_organization, (STEPentityH *) &_assigned_person_and_organization);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_119role, (STEPentityH *) &_role);
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson_and_organization_assignment::SdaiPerson_and_organization_assignment (SdaiPerson_and_organization_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPerson_and_organization_assignment::~SdaiPerson_and_organization_assignment () {  }
SdaiPerson_and_organization_assignment::SdaiPerson_and_organization_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_assignment;

    STEPattribute * a = new STEPattribute (*a_118assigned_person_and_organization, (STEPentityH *) &_assigned_person_and_organization);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_119role, (STEPentityH *) &_role);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiPerson_and_organizationH 
SdaiPerson_and_organization_assignment::Assigned_person_and_organization() const 
	{ return (SdaiPerson_and_organizationH) _assigned_person_and_organization; }

void 
SdaiPerson_and_organization_assignment::Assigned_person_and_organization (SdaiPerson_and_organizationH x)
	{ _assigned_person_and_organization = x; }

SdaiPerson_and_organization_roleH 
SdaiPerson_and_organization_assignment::Role() const 
	{ return (SdaiPerson_and_organization_roleH) _role; }

void 
SdaiPerson_and_organization_assignment::Role (SdaiPerson_and_organization_roleH x)
	{ _role = x; }

/////////	 END_ENTITY person_and_organization_assignment 


/////////	 ENTITY cc_design_person_and_organization_assignment 

EntityDescriptor *config_control_designe_cc_design_person_and_organization_assignment =0;
AttrDescriptor *a_120items =0;
SdaiCc_design_person_and_organization_assignment::SdaiCc_design_person_and_organization_assignment( ) 
{

	/*  parent: SdaiPerson_and_organization_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_person_and_organization_assignment;

    STEPattribute * a = new STEPattribute (*a_120items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_person_and_organization_assignment::SdaiCc_design_person_and_organization_assignment (SdaiCc_design_person_and_organization_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCc_design_person_and_organization_assignment::~SdaiCc_design_person_and_organization_assignment () {  }
SdaiCc_design_person_and_organization_assignment::SdaiCc_design_person_and_organization_assignment (STEPentity *se ) : SdaiPerson_and_organization_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPerson_and_organization_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_person_and_organization_assignment;

    STEPattribute * a = new STEPattribute (*a_120items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPerson_organization_itemsH 
SdaiCc_design_person_and_organization_assignment::Items() const 
	{ return (SdaiPerson_organization_itemsH) &_items; }

void 
SdaiCc_design_person_and_organization_assignment::Items (SdaiPerson_organization_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_person_and_organization_assignment 


/////////	 ENTITY offset_curve_3d 

EntityDescriptor *config_control_designe_offset_curve_3d =0;
AttrDescriptor *a_121basis_curve =0;
AttrDescriptor *a_122distance =0;
AttrDescriptor *a_123self_intersect =0;
AttrDescriptor *a_124ref_direction =0;
SdaiOffset_curve_3d::SdaiOffset_curve_3d( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_curve_3d;

    STEPattribute * a = new STEPattribute (*a_121basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_122distance,  &_distance);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_123self_intersect,  &_self_intersect);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_124ref_direction, (STEPentityH *) &_ref_direction);
    a -> set_null ();
    attributes.push (a);
}
SdaiOffset_curve_3d::SdaiOffset_curve_3d (SdaiOffset_curve_3d& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOffset_curve_3d::~SdaiOffset_curve_3d () {  }
SdaiOffset_curve_3d::SdaiOffset_curve_3d (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_curve_3d;

    STEPattribute * a = new STEPattribute (*a_121basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_122distance,  &_distance);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_123self_intersect,  &_self_intersect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_124ref_direction, (STEPentityH *) &_ref_direction);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiOffset_curve_3d::Basis_curve() const 
	{ return (SdaiCurveH) _basis_curve; }

void 
SdaiOffset_curve_3d::Basis_curve (SdaiCurveH x)
	{ _basis_curve = x; }

const SdaiLength_measure 
SdaiOffset_curve_3d::Distance() const 
	{ return (const SdaiLength_measure) _distance; }

void 
SdaiOffset_curve_3d::Distance (SdaiLength_measure x)
	{ _distance = x; }

const LOGICAL 
SdaiOffset_curve_3d::Self_intersect() const 
	{ return (LOGICAL) _self_intersect; }

void 
SdaiOffset_curve_3d::Self_intersect (LOGICAL x)
	{ _self_intersect.put (x); }

SdaiDirectionH 
SdaiOffset_curve_3d::Ref_direction() const 
	{ return (SdaiDirectionH) _ref_direction; }

void 
SdaiOffset_curve_3d::Ref_direction (SdaiDirectionH x)
	{ _ref_direction = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY offset_curve_3d 


/////////	 ENTITY approval 

EntityDescriptor *config_control_designe_approval =0;
AttrDescriptor *a_125status =0;
AttrDescriptor *a_126level =0;
SdaiApproval::SdaiApproval( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval;

    STEPattribute * a = new STEPattribute (*a_125status, (STEPentityH *) &_status);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_126level,  &_level);
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval::SdaiApproval (SdaiApproval& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApproval::~SdaiApproval () {  }
SdaiApproval::SdaiApproval( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_approval;

    STEPattribute * a = new STEPattribute (*a_125status, (STEPentityH *) &_status);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_126level,  &_level);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiApproval_statusH 
SdaiApproval::Status() const 
	{ return (SdaiApproval_statusH) _status; }

void 
SdaiApproval::Status (SdaiApproval_statusH x)
	{ _status = x; }

const SdaiLabel 
SdaiApproval::Level() const
	{ return (const SdaiLabel) _level; }

void 
SdaiApproval::Level (const char * x)
	{ _level = x; }

/////////	 END_ENTITY approval 


/////////	 ENTITY composite_curve 

EntityDescriptor *config_control_designe_composite_curve =0;
AttrDescriptor *a_127segments =0;
AttrDescriptor *a_128self_intersect =0;
AttrDescriptor *a_129Dn_segments =0;
AttrDescriptor *a_130Dclosed_curve =0;
SdaiComposite_curve::SdaiComposite_curve( ) 
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve;

    STEPattribute * a = new STEPattribute (*a_127segments,  &_segments);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_128self_intersect,  &_self_intersect);
    a -> set_null ();
    attributes.push (a);
}
SdaiComposite_curve::SdaiComposite_curve (SdaiComposite_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiComposite_curve::~SdaiComposite_curve () {  }
SdaiComposite_curve::SdaiComposite_curve (STEPentity *se ) : SdaiBounded_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve;

    STEPattribute * a = new STEPattribute (*a_127segments,  &_segments);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_128self_intersect,  &_self_intersect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiComposite_curve::Segments() const 
	{ return (EntityAggregateH) &_segments; }

void 
SdaiComposite_curve::Segments (EntityAggregateH x)
	{ _segments.ShallowCopy (*x); }

const LOGICAL 
SdaiComposite_curve::Self_intersect() const 
	{ return (LOGICAL) _self_intersect; }

void 
SdaiComposite_curve::Self_intersect (LOGICAL x)
	{ _self_intersect.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY composite_curve 


/////////	 ENTITY composite_curve_on_surface 

EntityDescriptor *config_control_designe_composite_curve_on_surface =0;
AttrDescriptor *a_131Dbasis_surface =0;
SdaiComposite_curve_on_surface::SdaiComposite_curve_on_surface( ) 
{

	/*  parent: SdaiComposite_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve_on_surface;
}
SdaiComposite_curve_on_surface::SdaiComposite_curve_on_surface (SdaiComposite_curve_on_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiComposite_curve_on_surface::~SdaiComposite_curve_on_surface () {  }
SdaiComposite_curve_on_surface::SdaiComposite_curve_on_surface (STEPentity *se ) : SdaiComposite_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiComposite_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_composite_curve_on_surface;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY composite_curve_on_surface 


/////////	 ENTITY boundary_curve 

EntityDescriptor *config_control_designe_boundary_curve =0;
SdaiBoundary_curve::SdaiBoundary_curve( ) 
{

	/*  parent: SdaiComposite_curve_on_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_boundary_curve;
}
SdaiBoundary_curve::SdaiBoundary_curve (SdaiBoundary_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiBoundary_curve::~SdaiBoundary_curve () {  }
SdaiBoundary_curve::SdaiBoundary_curve (STEPentity *se ) : SdaiComposite_curve_on_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiComposite_curve_on_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_boundary_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY boundary_curve 


/////////	 ENTITY representation_context 

EntityDescriptor *config_control_designe_representation_context =0;
AttrDescriptor *a_132context_identifier =0;
AttrDescriptor *a_133context_type =0;
InverseAttrDescriptor *a_134Irepresentations_in_context =0;
SdaiRepresentation_context::SdaiRepresentation_context( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_context;

    STEPattribute * a = new STEPattribute (*a_132context_identifier,  &_context_identifier);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_133context_type,  &_context_type);
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_context::SdaiRepresentation_context (SdaiRepresentation_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRepresentation_context::~SdaiRepresentation_context () {  }
SdaiRepresentation_context::SdaiRepresentation_context( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_context;

    STEPattribute * a = new STEPattribute (*a_132context_identifier,  &_context_identifier);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_133context_type,  &_context_type);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiRepresentation_context::Context_identifier() const
	{ return (const SdaiIdentifier) _context_identifier; }

void 
SdaiRepresentation_context::Context_identifier (const char * x)
	{ _context_identifier = x; }

const SdaiText 
SdaiRepresentation_context::Context_type() const
	{ return (const SdaiText) _context_type; }

void 
SdaiRepresentation_context::Context_type (const char * x)
	{ _context_type = x; }

const EntityAggregateH 
SdaiRepresentation_context::Representations_in_context() const 
	{ return (EntityAggregateH) &_representations_in_context; }

void 
SdaiRepresentation_context::Representations_in_context (EntityAggregateH x)
	{ _representations_in_context.ShallowCopy (*x); }

/////////	 END_ENTITY representation_context 


/////////	 ENTITY geometric_representation_context 

EntityDescriptor *config_control_designe_geometric_representation_context =0;
AttrDescriptor *a_135coordinate_space_dimension =0;
SdaiGeometric_representation_context::SdaiGeometric_representation_context( ) 
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_context;

    STEPattribute * a = new STEPattribute (*a_135coordinate_space_dimension,  &_coordinate_space_dimension);
    a -> set_null ();
    attributes.push (a);
}
SdaiGeometric_representation_context::SdaiGeometric_representation_context (SdaiGeometric_representation_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGeometric_representation_context::~SdaiGeometric_representation_context () {  }
SdaiGeometric_representation_context::SdaiGeometric_representation_context (STEPentity *se ) : SdaiRepresentation_context(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_representation_context;

    STEPattribute * a = new STEPattribute (*a_135coordinate_space_dimension,  &_coordinate_space_dimension);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiDimension_count 
SdaiGeometric_representation_context::Coordinate_space_dimension() const 
	{ return (const SdaiDimension_count) _coordinate_space_dimension; }

void 
SdaiGeometric_representation_context::Coordinate_space_dimension (SdaiDimension_count x)
	{ _coordinate_space_dimension = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_representation_context 


/////////	 ENTITY action_status 

EntityDescriptor *config_control_designe_action_status =0;
AttrDescriptor *a_136status =0;
AttrDescriptor *a_137assigned_action =0;
SdaiAction_status::SdaiAction_status( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_status;

    STEPattribute * a = new STEPattribute (*a_136status,  &_status);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_137assigned_action, (STEPentityH *) &_assigned_action);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_status::SdaiAction_status (SdaiAction_status& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction_status::~SdaiAction_status () {  }
SdaiAction_status::SdaiAction_status( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action_status;

    STEPattribute * a = new STEPattribute (*a_136status,  &_status);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_137assigned_action, (STEPentityH *) &_assigned_action);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAction_status::Status() const
	{ return (const SdaiLabel) _status; }

void 
SdaiAction_status::Status (const char * x)
	{ _status = x; }

SdaiExecuted_actionH 
SdaiAction_status::Assigned_action() const 
	{ return (SdaiExecuted_actionH) _assigned_action; }

void 
SdaiAction_status::Assigned_action (SdaiExecuted_actionH x)
	{ _assigned_action = x; }

/////////	 END_ENTITY action_status 


/////////	 ENTITY application_context 

EntityDescriptor *config_control_designe_application_context =0;
AttrDescriptor *a_138application =0;
InverseAttrDescriptor *a_139Icontext_elements =0;
SdaiApplication_context::SdaiApplication_context( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context;

    STEPattribute * a = new STEPattribute (*a_138application,  &_application);
    a -> set_null ();
    attributes.push (a);
}
SdaiApplication_context::SdaiApplication_context (SdaiApplication_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApplication_context::~SdaiApplication_context () {  }
SdaiApplication_context::SdaiApplication_context( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context;

    STEPattribute * a = new STEPattribute (*a_138application,  &_application);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiText 
SdaiApplication_context::Application() const
	{ return (const SdaiText) _application; }

void 
SdaiApplication_context::Application (const char * x)
	{ _application = x; }

const EntityAggregateH 
SdaiApplication_context::Context_elements() const 
	{ return (EntityAggregateH) &_context_elements; }

void 
SdaiApplication_context::Context_elements (EntityAggregateH x)
	{ _context_elements.ShallowCopy (*x); }

/////////	 END_ENTITY application_context 


/////////	 ENTITY change_request 

EntityDescriptor *config_control_designe_change_request =0;
AttrDescriptor *a_140items =0;
SdaiChange_request::SdaiChange_request( ) 
{

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change_request;

    STEPattribute * a = new STEPattribute (*a_140items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiChange_request::SdaiChange_request (SdaiChange_request& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiChange_request::~SdaiChange_request () {  }
SdaiChange_request::SdaiChange_request (STEPentity *se ) : SdaiAction_request_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change_request;

    STEPattribute * a = new STEPattribute (*a_140items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiChange_request_itemsH 
SdaiChange_request::Items() const 
	{ return (SdaiChange_request_itemsH) &_items; }

void 
SdaiChange_request::Items (SdaiChange_request_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY change_request 


/////////	 ENTITY date_and_time 

EntityDescriptor *config_control_designe_date_and_time =0;
AttrDescriptor *a_141date_component =0;
AttrDescriptor *a_142time_component =0;
SdaiDate_and_time::SdaiDate_and_time( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time;

    STEPattribute * a = new STEPattribute (*a_141date_component, (STEPentityH *) &_date_component);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_142time_component, (STEPentityH *) &_time_component);
    a -> set_null ();
    attributes.push (a);
}
SdaiDate_and_time::SdaiDate_and_time (SdaiDate_and_time& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDate_and_time::~SdaiDate_and_time () {  }
SdaiDate_and_time::SdaiDate_and_time( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time;

    STEPattribute * a = new STEPattribute (*a_141date_component, (STEPentityH *) &_date_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_142time_component, (STEPentityH *) &_time_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDateH 
SdaiDate_and_time::Date_component() const 
	{ return (SdaiDateH) _date_component; }

void 
SdaiDate_and_time::Date_component (SdaiDateH x)
	{ _date_component = x; }

SdaiLocal_timeH 
SdaiDate_and_time::Time_component() const 
	{ return (SdaiLocal_timeH) _time_component; }

void 
SdaiDate_and_time::Time_component (SdaiLocal_timeH x)
	{ _time_component = x; }

/////////	 END_ENTITY date_and_time 


/////////	 ENTITY approval_date_time 

EntityDescriptor *config_control_designe_approval_date_time =0;
AttrDescriptor *a_143date_time =0;
AttrDescriptor *a_144dated_approval =0;
SdaiApproval_date_time::SdaiApproval_date_time( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_date_time;

    STEPattribute * a = new STEPattribute (*a_143date_time,  &_date_time);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_144dated_approval, (STEPentityH *) &_dated_approval);
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_date_time::SdaiApproval_date_time (SdaiApproval_date_time& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApproval_date_time::~SdaiApproval_date_time () {  }
SdaiApproval_date_time::SdaiApproval_date_time( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_date_time;

    STEPattribute * a = new STEPattribute (*a_143date_time,  &_date_time);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_144dated_approval, (STEPentityH *) &_dated_approval);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiDate_time_selectH 
SdaiApproval_date_time::Date_time() const 
	{ return (const SdaiDate_time_selectH) &_date_time; }

void 
SdaiApproval_date_time::Date_time (SdaiDate_time_selectH x)
	{ _date_time = x; }

SdaiApprovalH 
SdaiApproval_date_time::Dated_approval() const 
	{ return (SdaiApprovalH) _dated_approval; }

void 
SdaiApproval_date_time::Dated_approval (SdaiApprovalH x)
	{ _dated_approval = x; }

/////////	 END_ENTITY approval_date_time 


/////////	 ENTITY approval_role 

EntityDescriptor *config_control_designe_approval_role =0;
AttrDescriptor *a_145role =0;
SdaiApproval_role::SdaiApproval_role( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_role;

    STEPattribute * a = new STEPattribute (*a_145role,  &_role);
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_role::SdaiApproval_role (SdaiApproval_role& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApproval_role::~SdaiApproval_role () {  }
SdaiApproval_role::SdaiApproval_role( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_role;

    STEPattribute * a = new STEPattribute (*a_145role,  &_role);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiApproval_role::Role() const
	{ return (const SdaiLabel) _role; }

void 
SdaiApproval_role::Role (const char * x)
	{ _role = x; }

/////////	 END_ENTITY approval_role 


/////////	 ENTITY application_context_element 

EntityDescriptor *config_control_designe_application_context_element =0;
AttrDescriptor *a_146name =0;
AttrDescriptor *a_147frame_of_reference =0;
SdaiApplication_context_element::SdaiApplication_context_element( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context_element;

    STEPattribute * a = new STEPattribute (*a_146name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_147frame_of_reference, (STEPentityH *) &_frame_of_reference);
    a -> set_null ();
    attributes.push (a);
}
SdaiApplication_context_element::SdaiApplication_context_element (SdaiApplication_context_element& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApplication_context_element::~SdaiApplication_context_element () {  }
SdaiApplication_context_element::SdaiApplication_context_element( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_application_context_element;

    STEPattribute * a = new STEPattribute (*a_146name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_147frame_of_reference, (STEPentityH *) &_frame_of_reference);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiApplication_context_element::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiApplication_context_element::Name (const char * x)
	{ _name = x; }

SdaiApplication_contextH 
SdaiApplication_context_element::Frame_of_reference() const 
	{ return (SdaiApplication_contextH) _frame_of_reference; }

void 
SdaiApplication_context_element::Frame_of_reference (SdaiApplication_contextH x)
	{ _frame_of_reference = x; }

/////////	 END_ENTITY application_context_element 


/////////	 ENTITY product_context 

EntityDescriptor *config_control_designe_product_context =0;
AttrDescriptor *a_148discipline_type =0;
SdaiProduct_context::SdaiProduct_context( ) 
{

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_context;

    STEPattribute * a = new STEPattribute (*a_148discipline_type,  &_discipline_type);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_context::SdaiProduct_context (SdaiProduct_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_context::~SdaiProduct_context () {  }
SdaiProduct_context::SdaiProduct_context (STEPentity *se ) : SdaiApplication_context_element(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_context;

    STEPattribute * a = new STEPattribute (*a_148discipline_type,  &_discipline_type);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiProduct_context::Discipline_type() const
	{ return (const SdaiLabel) _discipline_type; }

void 
SdaiProduct_context::Discipline_type (const char * x)
	{ _discipline_type = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_context 


/////////	 ENTITY elementary_surface 

EntityDescriptor *config_control_designe_elementary_surface =0;
AttrDescriptor *a_149position =0;
SdaiElementary_surface::SdaiElementary_surface( ) 
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_elementary_surface;

    STEPattribute * a = new STEPattribute (*a_149position, (STEPentityH *) &_position);
    a -> set_null ();
    attributes.push (a);
}
SdaiElementary_surface::SdaiElementary_surface (SdaiElementary_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiElementary_surface::~SdaiElementary_surface () {  }
SdaiElementary_surface::SdaiElementary_surface (STEPentity *se ) : SdaiSurface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_elementary_surface;

    STEPattribute * a = new STEPattribute (*a_149position, (STEPentityH *) &_position);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiAxis2_placement_3dH 
SdaiElementary_surface::Position() const 
	{ return (SdaiAxis2_placement_3dH) _position; }

void 
SdaiElementary_surface::Position (SdaiAxis2_placement_3dH x)
	{ _position = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY elementary_surface 


/////////	 ENTITY spherical_surface 

EntityDescriptor *config_control_designe_spherical_surface =0;
AttrDescriptor *a_150radius =0;
SdaiSpherical_surface::SdaiSpherical_surface( ) 
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_spherical_surface;

    STEPattribute * a = new STEPattribute (*a_150radius,  &_radius);
    a -> set_null ();
    attributes.push (a);
}
SdaiSpherical_surface::SdaiSpherical_surface (SdaiSpherical_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSpherical_surface::~SdaiSpherical_surface () {  }
SdaiSpherical_surface::SdaiSpherical_surface (STEPentity *se ) : SdaiElementary_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_spherical_surface;

    STEPattribute * a = new STEPattribute (*a_150radius,  &_radius);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPositive_length_measure 
SdaiSpherical_surface::Radius() const 
	{ return (const SdaiPositive_length_measure) _radius; }

void 
SdaiSpherical_surface::Radius (SdaiPositive_length_measure x)
	{ _radius = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY spherical_surface 


/////////	 ENTITY application_protocol_definition 

EntityDescriptor *config_control_designe_application_protocol_definition =0;
AttrDescriptor *a_151status =0;
AttrDescriptor *a_152application_interpreted_model_schema_name =0;
AttrDescriptor *a_153application_protocol_year =0;
AttrDescriptor *a_154application =0;
SdaiApplication_protocol_definition::SdaiApplication_protocol_definition( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_application_protocol_definition;

    STEPattribute * a = new STEPattribute (*a_151status,  &_status);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_152application_interpreted_model_schema_name,  &_application_interpreted_model_schema_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_153application_protocol_year,  &_application_protocol_year);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_154application, (STEPentityH *) &_application);
    a -> set_null ();
    attributes.push (a);
}
SdaiApplication_protocol_definition::SdaiApplication_protocol_definition (SdaiApplication_protocol_definition& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApplication_protocol_definition::~SdaiApplication_protocol_definition () {  }
SdaiApplication_protocol_definition::SdaiApplication_protocol_definition( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_application_protocol_definition;

    STEPattribute * a = new STEPattribute (*a_151status,  &_status);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_152application_interpreted_model_schema_name,  &_application_interpreted_model_schema_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_153application_protocol_year,  &_application_protocol_year);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_154application, (STEPentityH *) &_application);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiApplication_protocol_definition::Status() const
	{ return (const SdaiLabel) _status; }

void 
SdaiApplication_protocol_definition::Status (const char * x)
	{ _status = x; }

const SdaiLabel 
SdaiApplication_protocol_definition::Application_interpreted_model_schema_name() const
	{ return (const SdaiLabel) _application_interpreted_model_schema_name; }

void 
SdaiApplication_protocol_definition::Application_interpreted_model_schema_name (const char * x)
	{ _application_interpreted_model_schema_name = x; }

const SdaiYear_number 
SdaiApplication_protocol_definition::Application_protocol_year() const 
	{ return (const SdaiYear_number) _application_protocol_year; }

void 
SdaiApplication_protocol_definition::Application_protocol_year (SdaiYear_number x)
	{ _application_protocol_year = x; }

SdaiApplication_contextH 
SdaiApplication_protocol_definition::Application() const 
	{ return (SdaiApplication_contextH) _application; }

void 
SdaiApplication_protocol_definition::Application (SdaiApplication_contextH x)
	{ _application = x; }

/////////	 END_ENTITY application_protocol_definition 


/////////	 ENTITY specified_higher_usage_occurrence 

EntityDescriptor *config_control_designe_specified_higher_usage_occurrence =0;
AttrDescriptor *a_155upper_usage =0;
AttrDescriptor *a_156next_usage =0;
SdaiSpecified_higher_usage_occurrence::SdaiSpecified_higher_usage_occurrence( ) 
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_specified_higher_usage_occurrence;

    STEPattribute * a = new STEPattribute (*a_155upper_usage, (STEPentityH *) &_upper_usage);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_156next_usage, (STEPentityH *) &_next_usage);
    a -> set_null ();
    attributes.push (a);
}
SdaiSpecified_higher_usage_occurrence::SdaiSpecified_higher_usage_occurrence (SdaiSpecified_higher_usage_occurrence& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSpecified_higher_usage_occurrence::~SdaiSpecified_higher_usage_occurrence () {  }
SdaiSpecified_higher_usage_occurrence::SdaiSpecified_higher_usage_occurrence (STEPentity *se ) : SdaiAssembly_component_usage(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_specified_higher_usage_occurrence;

    STEPattribute * a = new STEPattribute (*a_155upper_usage, (STEPentityH *) &_upper_usage);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_156next_usage, (STEPentityH *) &_next_usage);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiAssembly_component_usageH 
SdaiSpecified_higher_usage_occurrence::Upper_usage() const 
	{ return (SdaiAssembly_component_usageH) _upper_usage; }

void 
SdaiSpecified_higher_usage_occurrence::Upper_usage (SdaiAssembly_component_usageH x)
	{ _upper_usage = x; }

SdaiNext_assembly_usage_occurrenceH 
SdaiSpecified_higher_usage_occurrence::Next_usage() const 
	{ return (SdaiNext_assembly_usage_occurrenceH) _next_usage; }

void 
SdaiSpecified_higher_usage_occurrence::Next_usage (SdaiNext_assembly_usage_occurrenceH x)
	{ _next_usage = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY specified_higher_usage_occurrence 


/////////	 ENTITY product_definition_formation_with_specified_source 

EntityDescriptor *config_control_designe_product_definition_formation_with_specified_source =0;
AttrDescriptor *a_157make_or_buy =0;
SdaiProduct_definition_formation_with_specified_source::SdaiProduct_definition_formation_with_specified_source( ) 
{

	/*  parent: SdaiProduct_definition_formation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_formation_with_specified_source;

    STEPattribute * a = new STEPattribute (*a_157make_or_buy,  &_make_or_buy);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_formation_with_specified_source::SdaiProduct_definition_formation_with_specified_source (SdaiProduct_definition_formation_with_specified_source& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_formation_with_specified_source::~SdaiProduct_definition_formation_with_specified_source () {  }
SdaiProduct_definition_formation_with_specified_source::SdaiProduct_definition_formation_with_specified_source (STEPentity *se ) : SdaiProduct_definition_formation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition_formation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_formation_with_specified_source;

    STEPattribute * a = new STEPattribute (*a_157make_or_buy,  &_make_or_buy);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const sdaiSource  
SdaiProduct_definition_formation_with_specified_source::Make_or_buy() const 
	{ return (sdaiSource) _make_or_buy; }

void 
SdaiProduct_definition_formation_with_specified_source::Make_or_buy (sdaiSource x)
	{ _make_or_buy.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_formation_with_specified_source 


/////////	 ENTITY action_request_solution 

EntityDescriptor *config_control_designe_action_request_solution =0;
AttrDescriptor *a_158method =0;
AttrDescriptor *a_159request =0;
SdaiAction_request_solution::SdaiAction_request_solution( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_solution;

    STEPattribute * a = new STEPattribute (*a_158method, (STEPentityH *) &_method);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_159request, (STEPentityH *) &_request);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_request_solution::SdaiAction_request_solution (SdaiAction_request_solution& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction_request_solution::~SdaiAction_request_solution () {  }
SdaiAction_request_solution::SdaiAction_request_solution( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_solution;

    STEPattribute * a = new STEPattribute (*a_158method, (STEPentityH *) &_method);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_159request, (STEPentityH *) &_request);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiAction_methodH 
SdaiAction_request_solution::Method() const 
	{ return (SdaiAction_methodH) _method; }

void 
SdaiAction_request_solution::Method (SdaiAction_methodH x)
	{ _method = x; }

SdaiVersioned_action_requestH 
SdaiAction_request_solution::Request() const 
	{ return (SdaiVersioned_action_requestH) _request; }

void 
SdaiAction_request_solution::Request (SdaiVersioned_action_requestH x)
	{ _request = x; }

/////////	 END_ENTITY action_request_solution 


/////////	 ENTITY uncertainty_measure_with_unit 

EntityDescriptor *config_control_designe_uncertainty_measure_with_unit =0;
AttrDescriptor *a_160name =0;
AttrDescriptor *a_161description =0;
SdaiUncertainty_measure_with_unit::SdaiUncertainty_measure_with_unit( ) 
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uncertainty_measure_with_unit;

    STEPattribute * a = new STEPattribute (*a_160name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_161description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiUncertainty_measure_with_unit::SdaiUncertainty_measure_with_unit (SdaiUncertainty_measure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiUncertainty_measure_with_unit::~SdaiUncertainty_measure_with_unit () {  }
SdaiUncertainty_measure_with_unit::SdaiUncertainty_measure_with_unit (STEPentity *se ) : SdaiMeasure_with_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uncertainty_measure_with_unit;

    STEPattribute * a = new STEPattribute (*a_160name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_161description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiUncertainty_measure_with_unit::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiUncertainty_measure_with_unit::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiUncertainty_measure_with_unit::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiUncertainty_measure_with_unit::Description (const char * x)
	{ _description = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY uncertainty_measure_with_unit 


/////////	 ENTITY edge_based_wireframe_model 

EntityDescriptor *config_control_designe_edge_based_wireframe_model =0;
AttrDescriptor *a_162ebwm_boundary =0;
SdaiEdge_based_wireframe_model::SdaiEdge_based_wireframe_model( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_model;

    STEPattribute * a = new STEPattribute (*a_162ebwm_boundary,  &_ebwm_boundary);
    a -> set_null ();
    attributes.push (a);
}
SdaiEdge_based_wireframe_model::SdaiEdge_based_wireframe_model (SdaiEdge_based_wireframe_model& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEdge_based_wireframe_model::~SdaiEdge_based_wireframe_model () {  }
SdaiEdge_based_wireframe_model::SdaiEdge_based_wireframe_model (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_model;

    STEPattribute * a = new STEPattribute (*a_162ebwm_boundary,  &_ebwm_boundary);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiEdge_based_wireframe_model::Ebwm_boundary() const 
	{ return (EntityAggregateH) &_ebwm_boundary; }

void 
SdaiEdge_based_wireframe_model::Ebwm_boundary (EntityAggregateH x)
	{ _ebwm_boundary.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY edge_based_wireframe_model 


/////////	 ENTITY path 

EntityDescriptor *config_control_designe_path =0;
AttrDescriptor *a_163edge_list =0;
SdaiPath::SdaiPath( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_path;

    STEPattribute * a = new STEPattribute (*a_163edge_list,  &_edge_list);
    a -> set_null ();
    attributes.push (a);
}
SdaiPath::SdaiPath (SdaiPath& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPath::~SdaiPath () {  }
SdaiPath::SdaiPath (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_path;

    STEPattribute * a = new STEPattribute (*a_163edge_list,  &_edge_list);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiPath::Edge_list() const 
	{ return (EntityAggregateH) &_edge_list; }

void 
SdaiPath::Edge_list (EntityAggregateH x)
	{ _edge_list.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY path 


/////////	 ENTITY connected_face_set 

EntityDescriptor *config_control_designe_connected_face_set =0;
AttrDescriptor *a_164cfs_faces =0;
SdaiConnected_face_set::SdaiConnected_face_set( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_face_set;

    STEPattribute * a = new STEPattribute (*a_164cfs_faces,  &_cfs_faces);
    a -> set_null ();
    attributes.push (a);
}
SdaiConnected_face_set::SdaiConnected_face_set (SdaiConnected_face_set& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConnected_face_set::~SdaiConnected_face_set () {  }
SdaiConnected_face_set::SdaiConnected_face_set (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_face_set;

    STEPattribute * a = new STEPattribute (*a_164cfs_faces,  &_cfs_faces);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiConnected_face_set::Cfs_faces() const 
	{ return (EntityAggregateH) &_cfs_faces; }

void 
SdaiConnected_face_set::Cfs_faces (EntityAggregateH x)
	{ _cfs_faces.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY connected_face_set 


/////////	 ENTITY open_shell 

EntityDescriptor *config_control_designe_open_shell =0;
SdaiOpen_shell::SdaiOpen_shell( ) 
{

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_open_shell;
}
SdaiOpen_shell::SdaiOpen_shell (SdaiOpen_shell& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOpen_shell::~SdaiOpen_shell () {  }
SdaiOpen_shell::SdaiOpen_shell (STEPentity *se ) : SdaiConnected_face_set(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_open_shell;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY open_shell 


/////////	 ENTITY oriented_open_shell 

EntityDescriptor *config_control_designe_oriented_open_shell =0;
AttrDescriptor *a_165open_shell_element =0;
AttrDescriptor *a_166orientation =0;
AttrDescriptor *a_167Dconnected_face_set_cfs_faces =0;
SdaiOriented_open_shell::SdaiOriented_open_shell( ) 
{

	/*  parent: SdaiOpen_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_open_shell;

    STEPattribute * a = new STEPattribute (*a_165open_shell_element, (STEPentityH *) &_open_shell_element);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_166orientation,  &_orientation);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("cfs_faces");
}
SdaiOriented_open_shell::SdaiOriented_open_shell (SdaiOriented_open_shell& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOriented_open_shell::~SdaiOriented_open_shell () {  }
SdaiOriented_open_shell::SdaiOriented_open_shell (STEPentity *se ) : SdaiOpen_shell(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiOpen_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_open_shell;

    STEPattribute * a = new STEPattribute (*a_165open_shell_element, (STEPentityH *) &_open_shell_element);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_166orientation,  &_orientation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("cfs_faces");
}

SdaiOpen_shellH 
SdaiOriented_open_shell::Open_shell_element() const 
	{ return (SdaiOpen_shellH) _open_shell_element; }

void 
SdaiOriented_open_shell::Open_shell_element (SdaiOpen_shellH x)
	{ _open_shell_element = x; }

const BOOLEAN 
SdaiOriented_open_shell::Orientation() const 
	{ return (LOGICAL) _orientation; }

void 
SdaiOriented_open_shell::Orientation (BOOLEAN x)
	{ _orientation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_open_shell 


/////////	 ENTITY solid_angle_unit 

EntityDescriptor *config_control_designe_solid_angle_unit =0;
SdaiSolid_angle_unit::SdaiSolid_angle_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_unit;
}
SdaiSolid_angle_unit::SdaiSolid_angle_unit (SdaiSolid_angle_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSolid_angle_unit::~SdaiSolid_angle_unit () {  }
SdaiSolid_angle_unit::SdaiSolid_angle_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY solid_angle_unit 


/////////	 ENTITY coordinated_universal_time_offset 

EntityDescriptor *config_control_designe_coordinated_universal_time_offset =0;
AttrDescriptor *a_168hour_offset =0;
AttrDescriptor *a_169minute_offset =0;
AttrDescriptor *a_170sense =0;
SdaiCoordinated_universal_time_offset::SdaiCoordinated_universal_time_offset( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_coordinated_universal_time_offset;

    STEPattribute * a = new STEPattribute (*a_168hour_offset,  &_hour_offset);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_169minute_offset,  &_minute_offset);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_170sense,  &_sense);
    a -> set_null ();
    attributes.push (a);
}
SdaiCoordinated_universal_time_offset::SdaiCoordinated_universal_time_offset (SdaiCoordinated_universal_time_offset& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCoordinated_universal_time_offset::~SdaiCoordinated_universal_time_offset () {  }
SdaiCoordinated_universal_time_offset::SdaiCoordinated_universal_time_offset( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_coordinated_universal_time_offset;

    STEPattribute * a = new STEPattribute (*a_168hour_offset,  &_hour_offset);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_169minute_offset,  &_minute_offset);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_170sense,  &_sense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiHour_in_day 
SdaiCoordinated_universal_time_offset::Hour_offset() const 
	{ return (const SdaiHour_in_day) _hour_offset; }

void 
SdaiCoordinated_universal_time_offset::Hour_offset (SdaiHour_in_day x)
	{ _hour_offset = x; }

const SdaiMinute_in_hour 
SdaiCoordinated_universal_time_offset::Minute_offset() const 
	{ return (const SdaiMinute_in_hour) _minute_offset; }

void 
SdaiCoordinated_universal_time_offset::Minute_offset (SdaiMinute_in_hour x)
	{ _minute_offset = x; }

const sdaiAhead_or_behind  
SdaiCoordinated_universal_time_offset::Sense() const 
	{ return (sdaiAhead_or_behind) _sense; }

void 
SdaiCoordinated_universal_time_offset::Sense (sdaiAhead_or_behind x)
	{ _sense.put (x); }

/////////	 END_ENTITY coordinated_universal_time_offset 


/////////	 ENTITY curve_replica 

EntityDescriptor *config_control_designe_curve_replica =0;
AttrDescriptor *a_171parent_curve =0;
AttrDescriptor *a_172transformation =0;
SdaiCurve_replica::SdaiCurve_replica( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_replica;

    STEPattribute * a = new STEPattribute (*a_171parent_curve, (STEPentityH *) &_parent_curve);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_172transformation, (STEPentityH *) &_transformation);
    a -> set_null ();
    attributes.push (a);
}
SdaiCurve_replica::SdaiCurve_replica (SdaiCurve_replica& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCurve_replica::~SdaiCurve_replica () {  }
SdaiCurve_replica::SdaiCurve_replica (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_replica;

    STEPattribute * a = new STEPattribute (*a_171parent_curve, (STEPentityH *) &_parent_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_172transformation, (STEPentityH *) &_transformation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiCurve_replica::Parent_curve() const 
	{ return (SdaiCurveH) _parent_curve; }

void 
SdaiCurve_replica::Parent_curve (SdaiCurveH x)
	{ _parent_curve = x; }

SdaiCartesian_transformation_operatorH 
SdaiCurve_replica::Transformation() const 
	{ return (SdaiCartesian_transformation_operatorH) _transformation; }

void 
SdaiCurve_replica::Transformation (SdaiCartesian_transformation_operatorH x)
	{ _transformation = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY curve_replica 


/////////	 ENTITY quasi_uniform_surface 

EntityDescriptor *config_control_designe_quasi_uniform_surface =0;
SdaiQuasi_uniform_surface::SdaiQuasi_uniform_surface( ) 
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_surface;
}
SdaiQuasi_uniform_surface::SdaiQuasi_uniform_surface (SdaiQuasi_uniform_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiQuasi_uniform_surface::~SdaiQuasi_uniform_surface () {  }
SdaiQuasi_uniform_surface::SdaiQuasi_uniform_surface (STEPentity *se ) : SdaiB_spline_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_surface;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY quasi_uniform_surface 


/////////	 ENTITY surface_curve 

EntityDescriptor *config_control_designe_surface_curve =0;
AttrDescriptor *a_173curve_3d =0;
AttrDescriptor *a_174associated_geometry =0;
AttrDescriptor *a_175master_representation =0;
AttrDescriptor *a_176Dbasis_surface =0;
SdaiSurface_curve::SdaiSurface_curve( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_curve;

    STEPattribute * a = new STEPattribute (*a_173curve_3d, (STEPentityH *) &_curve_3d);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_174associated_geometry,  &_associated_geometry);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_175master_representation,  &_master_representation);
    a -> set_null ();
    attributes.push (a);
}
SdaiSurface_curve::SdaiSurface_curve (SdaiSurface_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSurface_curve::~SdaiSurface_curve () {  }
SdaiSurface_curve::SdaiSurface_curve (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_curve;

    STEPattribute * a = new STEPattribute (*a_173curve_3d, (STEPentityH *) &_curve_3d);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_174associated_geometry,  &_associated_geometry);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_175master_representation,  &_master_representation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiSurface_curve::Curve_3d() const 
	{ return (SdaiCurveH) _curve_3d; }

void 
SdaiSurface_curve::Curve_3d (SdaiCurveH x)
	{ _curve_3d = x; }

const SdaiPcurve_or_surfacesH 
SdaiSurface_curve::Associated_geometry() const 
	{ return (SdaiPcurve_or_surfacesH) &_associated_geometry; }

void 
SdaiSurface_curve::Associated_geometry (SdaiPcurve_or_surfacesH x)
	{ _associated_geometry.ShallowCopy (*x); }

const sdaiPreferred_surface_curve_representation  
SdaiSurface_curve::Master_representation() const 
	{ return (sdaiPreferred_surface_curve_representation) _master_representation; }

void 
SdaiSurface_curve::Master_representation (sdaiPreferred_surface_curve_representation x)
	{ _master_representation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_curve 


/////////	 ENTITY action_request_status 

EntityDescriptor *config_control_designe_action_request_status =0;
AttrDescriptor *a_177status =0;
AttrDescriptor *a_178assigned_request =0;
SdaiAction_request_status::SdaiAction_request_status( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_status;

    STEPattribute * a = new STEPattribute (*a_177status,  &_status);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_178assigned_request, (STEPentityH *) &_assigned_request);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_request_status::SdaiAction_request_status (SdaiAction_request_status& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction_request_status::~SdaiAction_request_status () {  }
SdaiAction_request_status::SdaiAction_request_status( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action_request_status;

    STEPattribute * a = new STEPattribute (*a_177status,  &_status);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_178assigned_request, (STEPentityH *) &_assigned_request);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAction_request_status::Status() const
	{ return (const SdaiLabel) _status; }

void 
SdaiAction_request_status::Status (const char * x)
	{ _status = x; }

SdaiVersioned_action_requestH 
SdaiAction_request_status::Assigned_request() const 
	{ return (SdaiVersioned_action_requestH) _assigned_request; }

void 
SdaiAction_request_status::Assigned_request (SdaiVersioned_action_requestH x)
	{ _assigned_request = x; }

/////////	 END_ENTITY action_request_status 


/////////	 ENTITY composite_curve_segment 

EntityDescriptor *config_control_designe_composite_curve_segment =0;
AttrDescriptor *a_179transition =0;
AttrDescriptor *a_180same_sense =0;
AttrDescriptor *a_181parent_curve =0;
InverseAttrDescriptor *a_182Iusing_curves =0;
SdaiComposite_curve_segment::SdaiComposite_curve_segment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_composite_curve_segment;

    STEPattribute * a = new STEPattribute (*a_179transition,  &_transition);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_180same_sense,  &_same_sense);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_181parent_curve, (STEPentityH *) &_parent_curve);
    a -> set_null ();
    attributes.push (a);
}
SdaiComposite_curve_segment::SdaiComposite_curve_segment (SdaiComposite_curve_segment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiComposite_curve_segment::~SdaiComposite_curve_segment () {  }
SdaiComposite_curve_segment::SdaiComposite_curve_segment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_composite_curve_segment;

    STEPattribute * a = new STEPattribute (*a_179transition,  &_transition);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_180same_sense,  &_same_sense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_181parent_curve, (STEPentityH *) &_parent_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const sdaiTransition_code  
SdaiComposite_curve_segment::Transition() const 
	{ return (sdaiTransition_code) _transition; }

void 
SdaiComposite_curve_segment::Transition (sdaiTransition_code x)
	{ _transition.put (x); }

const BOOLEAN 
SdaiComposite_curve_segment::Same_sense() const 
	{ return (LOGICAL) _same_sense; }

void 
SdaiComposite_curve_segment::Same_sense (BOOLEAN x)
	{ _same_sense.put (x); }

SdaiCurveH 
SdaiComposite_curve_segment::Parent_curve() const 
	{ return (SdaiCurveH) _parent_curve; }

void 
SdaiComposite_curve_segment::Parent_curve (SdaiCurveH x)
	{ _parent_curve = x; }

const EntityAggregateH 
SdaiComposite_curve_segment::Using_curves() const 
	{ return (EntityAggregateH) &_using_curves; }

void 
SdaiComposite_curve_segment::Using_curves (EntityAggregateH x)
	{ _using_curves.ShallowCopy (*x); }

/////////	 END_ENTITY composite_curve_segment 


/////////	 ENTITY reparametrised_composite_curve_segment 

EntityDescriptor *config_control_designe_reparametrised_composite_curve_segment =0;
AttrDescriptor *a_183param_length =0;
SdaiReparametrised_composite_curve_segment::SdaiReparametrised_composite_curve_segment( ) 
{

	/*  parent: SdaiComposite_curve_segment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_reparametrised_composite_curve_segment;

    STEPattribute * a = new STEPattribute (*a_183param_length,  &_param_length);
    a -> set_null ();
    attributes.push (a);
}
SdaiReparametrised_composite_curve_segment::SdaiReparametrised_composite_curve_segment (SdaiReparametrised_composite_curve_segment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiReparametrised_composite_curve_segment::~SdaiReparametrised_composite_curve_segment () {  }
SdaiReparametrised_composite_curve_segment::SdaiReparametrised_composite_curve_segment (STEPentity *se ) : SdaiComposite_curve_segment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiComposite_curve_segment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_reparametrised_composite_curve_segment;

    STEPattribute * a = new STEPattribute (*a_183param_length,  &_param_length);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiParameter_value 
SdaiReparametrised_composite_curve_segment::Param_length() const 
	{ return (const SdaiParameter_value) _param_length; }

void 
SdaiReparametrised_composite_curve_segment::Param_length (SdaiParameter_value x)
	{ _param_length = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY reparametrised_composite_curve_segment 


/////////	 ENTITY representation_relationship 

EntityDescriptor *config_control_designe_representation_relationship =0;
AttrDescriptor *a_184name =0;
AttrDescriptor *a_185description =0;
AttrDescriptor *a_186rep_1 =0;
AttrDescriptor *a_187rep_2 =0;
SdaiRepresentation_relationship::SdaiRepresentation_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_relationship;

    STEPattribute * a = new STEPattribute (*a_184name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_185description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_186rep_1, (STEPentityH *) &_rep_1);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_187rep_2, (STEPentityH *) &_rep_2);
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_relationship::SdaiRepresentation_relationship (SdaiRepresentation_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRepresentation_relationship::~SdaiRepresentation_relationship () {  }
SdaiRepresentation_relationship::SdaiRepresentation_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_relationship;

    STEPattribute * a = new STEPattribute (*a_184name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_185description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_186rep_1, (STEPentityH *) &_rep_1);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_187rep_2, (STEPentityH *) &_rep_2);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiRepresentation_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiRepresentation_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiRepresentation_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiRepresentation_relationship::Description (const char * x)
	{ _description = x; }

SdaiRepresentationH 
SdaiRepresentation_relationship::Rep_1() const 
	{ return (SdaiRepresentationH) _rep_1; }

void 
SdaiRepresentation_relationship::Rep_1 (SdaiRepresentationH x)
	{ _rep_1 = x; }

SdaiRepresentationH 
SdaiRepresentation_relationship::Rep_2() const 
	{ return (SdaiRepresentationH) _rep_2; }

void 
SdaiRepresentation_relationship::Rep_2 (SdaiRepresentationH x)
	{ _rep_2 = x; }

/////////	 END_ENTITY representation_relationship 


/////////	 ENTITY representation_relationship_with_transformation 

EntityDescriptor *config_control_designe_representation_relationship_with_transformation =0;
AttrDescriptor *a_188transformation_operator =0;
SdaiRepresentation_relationship_with_transformation::SdaiRepresentation_relationship_with_transformation( ) 
{

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_representation_relationship_with_transformation;

    STEPattribute * a = new STEPattribute (*a_188transformation_operator,  &_transformation_operator);
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_relationship_with_transformation::SdaiRepresentation_relationship_with_transformation (SdaiRepresentation_relationship_with_transformation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRepresentation_relationship_with_transformation::~SdaiRepresentation_relationship_with_transformation () {  }
SdaiRepresentation_relationship_with_transformation::SdaiRepresentation_relationship_with_transformation (STEPentity *se ) : SdaiRepresentation_relationship(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_representation_relationship_with_transformation;

    STEPattribute * a = new STEPattribute (*a_188transformation_operator,  &_transformation_operator);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiTransformationH 
SdaiRepresentation_relationship_with_transformation::Transformation_operator() const 
	{ return (const SdaiTransformationH) &_transformation_operator; }

void 
SdaiRepresentation_relationship_with_transformation::Transformation_operator (SdaiTransformationH x)
	{ _transformation_operator = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY representation_relationship_with_transformation 


/////////	 ENTITY person_and_organization_role 

EntityDescriptor *config_control_designe_person_and_organization_role =0;
AttrDescriptor *a_189name =0;
SdaiPerson_and_organization_role::SdaiPerson_and_organization_role( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_role;

    STEPattribute * a = new STEPattribute (*a_189name,  &_name);
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson_and_organization_role::SdaiPerson_and_organization_role (SdaiPerson_and_organization_role& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPerson_and_organization_role::~SdaiPerson_and_organization_role () {  }
SdaiPerson_and_organization_role::SdaiPerson_and_organization_role( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization_role;

    STEPattribute * a = new STEPattribute (*a_189name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiPerson_and_organization_role::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiPerson_and_organization_role::Name (const char * x)
	{ _name = x; }

/////////	 END_ENTITY person_and_organization_role 


/////////	 ENTITY quasi_uniform_curve 

EntityDescriptor *config_control_designe_quasi_uniform_curve =0;
SdaiQuasi_uniform_curve::SdaiQuasi_uniform_curve( ) 
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_curve;
}
SdaiQuasi_uniform_curve::SdaiQuasi_uniform_curve (SdaiQuasi_uniform_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiQuasi_uniform_curve::~SdaiQuasi_uniform_curve () {  }
SdaiQuasi_uniform_curve::SdaiQuasi_uniform_curve (STEPentity *se ) : SdaiB_spline_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_quasi_uniform_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY quasi_uniform_curve 


/////////	 ENTITY swept_surface 

EntityDescriptor *config_control_designe_swept_surface =0;
AttrDescriptor *a_190swept_curve =0;
SdaiSwept_surface::SdaiSwept_surface( ) 
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_swept_surface;

    STEPattribute * a = new STEPattribute (*a_190swept_curve, (STEPentityH *) &_swept_curve);
    a -> set_null ();
    attributes.push (a);
}
SdaiSwept_surface::SdaiSwept_surface (SdaiSwept_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSwept_surface::~SdaiSwept_surface () {  }
SdaiSwept_surface::SdaiSwept_surface (STEPentity *se ) : SdaiSurface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_swept_surface;

    STEPattribute * a = new STEPattribute (*a_190swept_curve, (STEPentityH *) &_swept_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiSwept_surface::Swept_curve() const 
	{ return (SdaiCurveH) _swept_curve; }

void 
SdaiSwept_surface::Swept_curve (SdaiCurveH x)
	{ _swept_curve = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY swept_surface 


/////////	 ENTITY property_definition 

EntityDescriptor *config_control_designe_property_definition =0;
AttrDescriptor *a_191name =0;
AttrDescriptor *a_192description =0;
AttrDescriptor *a_193definition =0;
SdaiProperty_definition::SdaiProperty_definition( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition;

    STEPattribute * a = new STEPattribute (*a_191name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_192description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_193definition,  &_definition);
    a -> set_null ();
    attributes.push (a);
}
SdaiProperty_definition::SdaiProperty_definition (SdaiProperty_definition& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProperty_definition::~SdaiProperty_definition () {  }
SdaiProperty_definition::SdaiProperty_definition( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition;

    STEPattribute * a = new STEPattribute (*a_191name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_192description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_193definition,  &_definition);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiProperty_definition::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiProperty_definition::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiProperty_definition::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProperty_definition::Description (const char * x)
	{ _description = x; }

const SdaiCharacterized_definitionH 
SdaiProperty_definition::Definition() const 
	{ return (const SdaiCharacterized_definitionH) &_definition; }

void 
SdaiProperty_definition::Definition (SdaiCharacterized_definitionH x)
	{ _definition = x; }

/////////	 END_ENTITY property_definition 


/////////	 ENTITY global_uncertainty_assigned_context 

EntityDescriptor *config_control_designe_global_uncertainty_assigned_context =0;
AttrDescriptor *a_194uncertainty =0;
SdaiGlobal_uncertainty_assigned_context::SdaiGlobal_uncertainty_assigned_context( ) 
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_uncertainty_assigned_context;

    STEPattribute * a = new STEPattribute (*a_194uncertainty,  &_uncertainty);
    a -> set_null ();
    attributes.push (a);
}
SdaiGlobal_uncertainty_assigned_context::SdaiGlobal_uncertainty_assigned_context (SdaiGlobal_uncertainty_assigned_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGlobal_uncertainty_assigned_context::~SdaiGlobal_uncertainty_assigned_context () {  }
SdaiGlobal_uncertainty_assigned_context::SdaiGlobal_uncertainty_assigned_context (STEPentity *se ) : SdaiRepresentation_context(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_uncertainty_assigned_context;

    STEPattribute * a = new STEPattribute (*a_194uncertainty,  &_uncertainty);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiGlobal_uncertainty_assigned_context::Uncertainty() const 
	{ return (EntityAggregateH) &_uncertainty; }

void 
SdaiGlobal_uncertainty_assigned_context::Uncertainty (EntityAggregateH x)
	{ _uncertainty.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY global_uncertainty_assigned_context 


/////////	 ENTITY organization_relationship 

EntityDescriptor *config_control_designe_organization_relationship =0;
AttrDescriptor *a_195name =0;
AttrDescriptor *a_196description =0;
AttrDescriptor *a_197relating_organization =0;
AttrDescriptor *a_198related_organization =0;
SdaiOrganization_relationship::SdaiOrganization_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_organization_relationship;

    STEPattribute * a = new STEPattribute (*a_195name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_196description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_197relating_organization, (STEPentityH *) &_relating_organization);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_198related_organization, (STEPentityH *) &_related_organization);
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganization_relationship::SdaiOrganization_relationship (SdaiOrganization_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOrganization_relationship::~SdaiOrganization_relationship () {  }
SdaiOrganization_relationship::SdaiOrganization_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_organization_relationship;

    STEPattribute * a = new STEPattribute (*a_195name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_196description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_197relating_organization, (STEPentityH *) &_relating_organization);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_198related_organization, (STEPentityH *) &_related_organization);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiOrganization_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiOrganization_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiOrganization_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiOrganization_relationship::Description (const char * x)
	{ _description = x; }

SdaiOrganizationH 
SdaiOrganization_relationship::Relating_organization() const 
	{ return (SdaiOrganizationH) _relating_organization; }

void 
SdaiOrganization_relationship::Relating_organization (SdaiOrganizationH x)
	{ _relating_organization = x; }

SdaiOrganizationH 
SdaiOrganization_relationship::Related_organization() const 
	{ return (SdaiOrganizationH) _related_organization; }

void 
SdaiOrganization_relationship::Related_organization (SdaiOrganizationH x)
	{ _related_organization = x; }

/////////	 END_ENTITY organization_relationship 


/////////	 ENTITY parabola 

EntityDescriptor *config_control_designe_parabola =0;
AttrDescriptor *a_199focal_dist =0;
SdaiParabola::SdaiParabola( ) 
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parabola;

    STEPattribute * a = new STEPattribute (*a_199focal_dist,  &_focal_dist);
    a -> set_null ();
    attributes.push (a);
}
SdaiParabola::SdaiParabola (SdaiParabola& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiParabola::~SdaiParabola () {  }
SdaiParabola::SdaiParabola (STEPentity *se ) : SdaiConic(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parabola;

    STEPattribute * a = new STEPattribute (*a_199focal_dist,  &_focal_dist);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLength_measure 
SdaiParabola::Focal_dist() const 
	{ return (const SdaiLength_measure) _focal_dist; }

void 
SdaiParabola::Focal_dist (SdaiLength_measure x)
	{ _focal_dist = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY parabola 


/////////	 ENTITY rectangular_composite_surface 

EntityDescriptor *config_control_designe_rectangular_composite_surface =0;
AttrDescriptor *a_200segments =0;
AttrDescriptor *a_201Dn_u =0;
AttrDescriptor *a_202Dn_v =0;
SdaiRectangular_composite_surface::SdaiRectangular_composite_surface( ) 
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_composite_surface;

    STEPattribute * a = new STEPattribute (*a_200segments,  &_segments);
    a -> set_null ();
    attributes.push (a);
}
SdaiRectangular_composite_surface::SdaiRectangular_composite_surface (SdaiRectangular_composite_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRectangular_composite_surface::~SdaiRectangular_composite_surface () {  }
SdaiRectangular_composite_surface::SdaiRectangular_composite_surface (STEPentity *se ) : SdaiBounded_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_composite_surface;

    STEPattribute * a = new STEPattribute (*a_200segments,  &_segments);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const GenericAggregateH 
SdaiRectangular_composite_surface::Segments() const 
	{ return (GenericAggregateH) &_segments; }

void 
SdaiRectangular_composite_surface::Segments (GenericAggregateH x)
	{ _segments.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rectangular_composite_surface 


/////////	 ENTITY lot_effectivity 

EntityDescriptor *config_control_designe_lot_effectivity =0;
AttrDescriptor *a_203effectivity_lot_id =0;
AttrDescriptor *a_204effectivity_lot_size =0;
SdaiLot_effectivity::SdaiLot_effectivity( ) 
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_lot_effectivity;

    STEPattribute * a = new STEPattribute (*a_203effectivity_lot_id,  &_effectivity_lot_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_204effectivity_lot_size, (STEPentityH *) &_effectivity_lot_size);
    a -> set_null ();
    attributes.push (a);
}
SdaiLot_effectivity::SdaiLot_effectivity (SdaiLot_effectivity& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiLot_effectivity::~SdaiLot_effectivity () {  }
SdaiLot_effectivity::SdaiLot_effectivity (STEPentity *se ) : SdaiEffectivity(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_lot_effectivity;

    STEPattribute * a = new STEPattribute (*a_203effectivity_lot_id,  &_effectivity_lot_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_204effectivity_lot_size, (STEPentityH *) &_effectivity_lot_size);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiLot_effectivity::Effectivity_lot_id() const
	{ return (const SdaiIdentifier) _effectivity_lot_id; }

void 
SdaiLot_effectivity::Effectivity_lot_id (const char * x)
	{ _effectivity_lot_id = x; }

SdaiMeasure_with_unitH 
SdaiLot_effectivity::Effectivity_lot_size() const 
	{ return (SdaiMeasure_with_unitH) _effectivity_lot_size; }

void 
SdaiLot_effectivity::Effectivity_lot_size (SdaiMeasure_with_unitH x)
	{ _effectivity_lot_size = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY lot_effectivity 


/////////	 ENTITY surface_of_linear_extrusion 

EntityDescriptor *config_control_designe_surface_of_linear_extrusion =0;
AttrDescriptor *a_205extrusion_axis =0;
SdaiSurface_of_linear_extrusion::SdaiSurface_of_linear_extrusion( ) 
{

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_linear_extrusion;

    STEPattribute * a = new STEPattribute (*a_205extrusion_axis, (STEPentityH *) &_extrusion_axis);
    a -> set_null ();
    attributes.push (a);
}
SdaiSurface_of_linear_extrusion::SdaiSurface_of_linear_extrusion (SdaiSurface_of_linear_extrusion& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSurface_of_linear_extrusion::~SdaiSurface_of_linear_extrusion () {  }
SdaiSurface_of_linear_extrusion::SdaiSurface_of_linear_extrusion (STEPentity *se ) : SdaiSwept_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_linear_extrusion;

    STEPattribute * a = new STEPattribute (*a_205extrusion_axis, (STEPentityH *) &_extrusion_axis);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiVectorH 
SdaiSurface_of_linear_extrusion::Extrusion_axis() const 
	{ return (SdaiVectorH) _extrusion_axis; }

void 
SdaiSurface_of_linear_extrusion::Extrusion_axis (SdaiVectorH x)
	{ _extrusion_axis = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_of_linear_extrusion 


/////////	 ENTITY shell_based_surface_model 

EntityDescriptor *config_control_designe_shell_based_surface_model =0;
AttrDescriptor *a_206sbsm_boundary =0;
SdaiShell_based_surface_model::SdaiShell_based_surface_model( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_surface_model;

    STEPattribute * a = new STEPattribute (*a_206sbsm_boundary,  &_sbsm_boundary);
    a -> set_null ();
    attributes.push (a);
}
SdaiShell_based_surface_model::SdaiShell_based_surface_model (SdaiShell_based_surface_model& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShell_based_surface_model::~SdaiShell_based_surface_model () {  }
SdaiShell_based_surface_model::SdaiShell_based_surface_model (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_surface_model;

    STEPattribute * a = new STEPattribute (*a_206sbsm_boundary,  &_sbsm_boundary);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiShellsH 
SdaiShell_based_surface_model::Sbsm_boundary() const 
	{ return (SdaiShellsH) &_sbsm_boundary; }

void 
SdaiShell_based_surface_model::Sbsm_boundary (SdaiShellsH x)
	{ _sbsm_boundary.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shell_based_surface_model 


/////////	 ENTITY uniform_curve 

EntityDescriptor *config_control_designe_uniform_curve =0;
SdaiUniform_curve::SdaiUniform_curve( ) 
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_curve;
}
SdaiUniform_curve::SdaiUniform_curve (SdaiUniform_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiUniform_curve::~SdaiUniform_curve () {  }
SdaiUniform_curve::SdaiUniform_curve (STEPentity *se ) : SdaiB_spline_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_uniform_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY uniform_curve 


/////////	 ENTITY bezier_curve 

EntityDescriptor *config_control_designe_bezier_curve =0;
SdaiBezier_curve::SdaiBezier_curve( ) 
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_curve;
}
SdaiBezier_curve::SdaiBezier_curve (SdaiBezier_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiBezier_curve::~SdaiBezier_curve () {  }
SdaiBezier_curve::SdaiBezier_curve (STEPentity *se ) : SdaiB_spline_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bezier_curve 


/////////	 ENTITY loop 

EntityDescriptor *config_control_designe_loop =0;
SdaiLoop::SdaiLoop( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_loop;
}
SdaiLoop::SdaiLoop (SdaiLoop& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiLoop::~SdaiLoop () {  }
SdaiLoop::SdaiLoop (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_loop;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY loop 


/////////	 ENTITY edge_loop 

EntityDescriptor *config_control_designe_edge_loop =0;
AttrDescriptor *a_207Dne =0;
SdaiEdge_loop::SdaiEdge_loop( ) 
{

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiPath  */
    AppendMultInstance(new SdaiPath(this)); 

    eDesc = config_control_designe_edge_loop;
}
SdaiEdge_loop::SdaiEdge_loop (SdaiEdge_loop& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEdge_loop::~SdaiEdge_loop () {  }
SdaiEdge_loop::SdaiEdge_loop (STEPentity *se ) : SdaiLoop(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiPath  */
    se->AppendMultInstance(new SdaiPath(se)); 

    eDesc = config_control_designe_edge_loop;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

const EntityAggregateH 
SdaiEdge_loop::Edge_list() const 
	{ return (EntityAggregateH) &_edge_list; }

void 
SdaiEdge_loop::Edge_list (EntityAggregateH x)
	{ _edge_list.ShallowCopy (*x); }

#endif

/////////	 END_ENTITY edge_loop 


/////////	 ENTITY date 

EntityDescriptor *config_control_designe_date =0;
AttrDescriptor *a_208year_component =0;
SdaiDate::SdaiDate( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date;

    STEPattribute * a = new STEPattribute (*a_208year_component,  &_year_component);
    a -> set_null ();
    attributes.push (a);
}
SdaiDate::SdaiDate (SdaiDate& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDate::~SdaiDate () {  }
SdaiDate::SdaiDate( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_date;

    STEPattribute * a = new STEPattribute (*a_208year_component,  &_year_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiYear_number 
SdaiDate::Year_component() const 
	{ return (const SdaiYear_number) _year_component; }

void 
SdaiDate::Year_component (SdaiYear_number x)
	{ _year_component = x; }

/////////	 END_ENTITY date 


/////////	 ENTITY calendar_date 

EntityDescriptor *config_control_designe_calendar_date =0;
AttrDescriptor *a_209day_component =0;
AttrDescriptor *a_210month_component =0;
SdaiCalendar_date::SdaiCalendar_date( ) 
{

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_calendar_date;

    STEPattribute * a = new STEPattribute (*a_209day_component,  &_day_component);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_210month_component,  &_month_component);
    a -> set_null ();
    attributes.push (a);
}
SdaiCalendar_date::SdaiCalendar_date (SdaiCalendar_date& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCalendar_date::~SdaiCalendar_date () {  }
SdaiCalendar_date::SdaiCalendar_date (STEPentity *se ) : SdaiDate(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_calendar_date;

    STEPattribute * a = new STEPattribute (*a_209day_component,  &_day_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_210month_component,  &_month_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiDay_in_month_number 
SdaiCalendar_date::Day_component() const 
	{ return (const SdaiDay_in_month_number) _day_component; }

void 
SdaiCalendar_date::Day_component (SdaiDay_in_month_number x)
	{ _day_component = x; }

const SdaiMonth_in_year_number 
SdaiCalendar_date::Month_component() const 
	{ return (const SdaiMonth_in_year_number) _month_component; }

void 
SdaiCalendar_date::Month_component (SdaiMonth_in_year_number x)
	{ _month_component = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY calendar_date 


/////////	 ENTITY toroidal_surface 

EntityDescriptor *config_control_designe_toroidal_surface =0;
AttrDescriptor *a_211major_radius =0;
AttrDescriptor *a_212minor_radius =0;
SdaiToroidal_surface::SdaiToroidal_surface( ) 
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_toroidal_surface;

    STEPattribute * a = new STEPattribute (*a_211major_radius,  &_major_radius);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_212minor_radius,  &_minor_radius);
    a -> set_null ();
    attributes.push (a);
}
SdaiToroidal_surface::SdaiToroidal_surface (SdaiToroidal_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiToroidal_surface::~SdaiToroidal_surface () {  }
SdaiToroidal_surface::SdaiToroidal_surface (STEPentity *se ) : SdaiElementary_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_toroidal_surface;

    STEPattribute * a = new STEPattribute (*a_211major_radius,  &_major_radius);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_212minor_radius,  &_minor_radius);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPositive_length_measure 
SdaiToroidal_surface::Major_radius() const 
	{ return (const SdaiPositive_length_measure) _major_radius; }

void 
SdaiToroidal_surface::Major_radius (SdaiPositive_length_measure x)
	{ _major_radius = x; }

const SdaiPositive_length_measure 
SdaiToroidal_surface::Minor_radius() const 
	{ return (const SdaiPositive_length_measure) _minor_radius; }

void 
SdaiToroidal_surface::Minor_radius (SdaiPositive_length_measure x)
	{ _minor_radius = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY toroidal_surface 


/////////	 ENTITY promissory_usage_occurrence 

EntityDescriptor *config_control_designe_promissory_usage_occurrence =0;
SdaiPromissory_usage_occurrence::SdaiPromissory_usage_occurrence( ) 
{

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_promissory_usage_occurrence;
}
SdaiPromissory_usage_occurrence::SdaiPromissory_usage_occurrence (SdaiPromissory_usage_occurrence& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPromissory_usage_occurrence::~SdaiPromissory_usage_occurrence () {  }
SdaiPromissory_usage_occurrence::SdaiPromissory_usage_occurrence (STEPentity *se ) : SdaiAssembly_component_usage(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAssembly_component_usage  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_promissory_usage_occurrence;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY promissory_usage_occurrence 


/////////	 ENTITY approval_assignment 

EntityDescriptor *config_control_designe_approval_assignment =0;
AttrDescriptor *a_213assigned_approval =0;
SdaiApproval_assignment::SdaiApproval_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_assignment;

    STEPattribute * a = new STEPattribute (*a_213assigned_approval, (STEPentityH *) &_assigned_approval);
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_assignment::SdaiApproval_assignment (SdaiApproval_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApproval_assignment::~SdaiApproval_assignment () {  }
SdaiApproval_assignment::SdaiApproval_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_assignment;

    STEPattribute * a = new STEPattribute (*a_213assigned_approval, (STEPentityH *) &_assigned_approval);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiApprovalH 
SdaiApproval_assignment::Assigned_approval() const 
	{ return (SdaiApprovalH) _assigned_approval; }

void 
SdaiApproval_assignment::Assigned_approval (SdaiApprovalH x)
	{ _assigned_approval = x; }

/////////	 END_ENTITY approval_assignment 


/////////	 ENTITY configuration_item 

EntityDescriptor *config_control_designe_configuration_item =0;
AttrDescriptor *a_214id =0;
AttrDescriptor *a_215name =0;
AttrDescriptor *a_216description =0;
AttrDescriptor *a_217item_concept =0;
AttrDescriptor *a_218purpose =0;
SdaiConfiguration_item::SdaiConfiguration_item( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_item;

    STEPattribute * a = new STEPattribute (*a_214id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_215name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_216description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_217item_concept, (STEPentityH *) &_item_concept);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_218purpose,  &_purpose);
    a -> set_null ();
    attributes.push (a);
}
SdaiConfiguration_item::SdaiConfiguration_item (SdaiConfiguration_item& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConfiguration_item::~SdaiConfiguration_item () {  }
SdaiConfiguration_item::SdaiConfiguration_item( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_item;

    STEPattribute * a = new STEPattribute (*a_214id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_215name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_216description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_217item_concept, (STEPentityH *) &_item_concept);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_218purpose,  &_purpose);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiConfiguration_item::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiConfiguration_item::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiConfiguration_item::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiConfiguration_item::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiConfiguration_item::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiConfiguration_item::Description (const char * x)
	{ _description = x; }

SdaiProduct_conceptH 
SdaiConfiguration_item::Item_concept() const 
	{ return (SdaiProduct_conceptH) _item_concept; }

void 
SdaiConfiguration_item::Item_concept (SdaiProduct_conceptH x)
	{ _item_concept = x; }

const SdaiLabel 
SdaiConfiguration_item::Purpose() const
	{ return (const SdaiLabel) _purpose; }

void 
SdaiConfiguration_item::Purpose (const char * x)
	{ _purpose = x; }

/////////	 END_ENTITY configuration_item 


/////////	 ENTITY contract_assignment 

EntityDescriptor *config_control_designe_contract_assignment =0;
AttrDescriptor *a_219assigned_contract =0;
SdaiContract_assignment::SdaiContract_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_assignment;

    STEPattribute * a = new STEPattribute (*a_219assigned_contract, (STEPentityH *) &_assigned_contract);
    a -> set_null ();
    attributes.push (a);
}
SdaiContract_assignment::SdaiContract_assignment (SdaiContract_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiContract_assignment::~SdaiContract_assignment () {  }
SdaiContract_assignment::SdaiContract_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_assignment;

    STEPattribute * a = new STEPattribute (*a_219assigned_contract, (STEPentityH *) &_assigned_contract);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiContractH 
SdaiContract_assignment::Assigned_contract() const 
	{ return (SdaiContractH) _assigned_contract; }

void 
SdaiContract_assignment::Assigned_contract (SdaiContractH x)
	{ _assigned_contract = x; }

/////////	 END_ENTITY contract_assignment 


/////////	 ENTITY vector 

EntityDescriptor *config_control_designe_vector =0;
AttrDescriptor *a_220orientation =0;
AttrDescriptor *a_221magnitude =0;
SdaiVector::SdaiVector( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vector;

    STEPattribute * a = new STEPattribute (*a_220orientation, (STEPentityH *) &_orientation);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_221magnitude,  &_magnitude);
    a -> set_null ();
    attributes.push (a);
}
SdaiVector::SdaiVector (SdaiVector& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVector::~SdaiVector () {  }
SdaiVector::SdaiVector (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vector;

    STEPattribute * a = new STEPattribute (*a_220orientation, (STEPentityH *) &_orientation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_221magnitude,  &_magnitude);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDirectionH 
SdaiVector::Orientation() const 
	{ return (SdaiDirectionH) _orientation; }

void 
SdaiVector::Orientation (SdaiDirectionH x)
	{ _orientation = x; }

const SdaiLength_measure 
SdaiVector::Magnitude() const 
	{ return (const SdaiLength_measure) _magnitude; }

void 
SdaiVector::Magnitude (SdaiLength_measure x)
	{ _magnitude = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vector 


/////////	 ENTITY intersection_curve 

EntityDescriptor *config_control_designe_intersection_curve =0;
SdaiIntersection_curve::SdaiIntersection_curve( ) 
{

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_intersection_curve;
}
SdaiIntersection_curve::SdaiIntersection_curve (SdaiIntersection_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiIntersection_curve::~SdaiIntersection_curve () {  }
SdaiIntersection_curve::SdaiIntersection_curve (STEPentity *se ) : SdaiSurface_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_intersection_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY intersection_curve 


/////////	 ENTITY trimmed_curve 

EntityDescriptor *config_control_designe_trimmed_curve =0;
AttrDescriptor *a_222basis_curve =0;
AttrDescriptor *a_223trim_1 =0;
AttrDescriptor *a_224trim_2 =0;
AttrDescriptor *a_225sense_agreement =0;
AttrDescriptor *a_226master_representation =0;
SdaiTrimmed_curve::SdaiTrimmed_curve( ) 
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_trimmed_curve;

    STEPattribute * a = new STEPattribute (*a_222basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_223trim_1,  &_trim_1);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_224trim_2,  &_trim_2);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_225sense_agreement,  &_sense_agreement);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_226master_representation,  &_master_representation);
    a -> set_null ();
    attributes.push (a);
}
SdaiTrimmed_curve::SdaiTrimmed_curve (SdaiTrimmed_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiTrimmed_curve::~SdaiTrimmed_curve () {  }
SdaiTrimmed_curve::SdaiTrimmed_curve (STEPentity *se ) : SdaiBounded_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_trimmed_curve;

    STEPattribute * a = new STEPattribute (*a_222basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_223trim_1,  &_trim_1);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_224trim_2,  &_trim_2);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_225sense_agreement,  &_sense_agreement);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_226master_representation,  &_master_representation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiTrimmed_curve::Basis_curve() const 
	{ return (SdaiCurveH) _basis_curve; }

void 
SdaiTrimmed_curve::Basis_curve (SdaiCurveH x)
	{ _basis_curve = x; }

const SdaiTrimming_selectsH 
SdaiTrimmed_curve::Trim_1() const 
	{ return (SdaiTrimming_selectsH) &_trim_1; }

void 
SdaiTrimmed_curve::Trim_1 (SdaiTrimming_selectsH x)
	{ _trim_1.ShallowCopy (*x); }

const SdaiTrimming_selectsH 
SdaiTrimmed_curve::Trim_2() const 
	{ return (SdaiTrimming_selectsH) &_trim_2; }

void 
SdaiTrimmed_curve::Trim_2 (SdaiTrimming_selectsH x)
	{ _trim_2.ShallowCopy (*x); }

const BOOLEAN 
SdaiTrimmed_curve::Sense_agreement() const 
	{ return (LOGICAL) _sense_agreement; }

void 
SdaiTrimmed_curve::Sense_agreement (BOOLEAN x)
	{ _sense_agreement.put (x); }

const sdaiTrimming_preference  
SdaiTrimmed_curve::Master_representation() const 
	{ return (sdaiTrimming_preference) _master_representation; }

void 
SdaiTrimmed_curve::Master_representation (sdaiTrimming_preference x)
	{ _master_representation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY trimmed_curve 


/////////	 ENTITY product_definition_context 

EntityDescriptor *config_control_designe_product_definition_context =0;
AttrDescriptor *a_227life_cycle_stage =0;
SdaiProduct_definition_context::SdaiProduct_definition_context( ) 
{

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_context;

    STEPattribute * a = new STEPattribute (*a_227life_cycle_stage,  &_life_cycle_stage);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_context::SdaiProduct_definition_context (SdaiProduct_definition_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_context::~SdaiProduct_definition_context () {  }
SdaiProduct_definition_context::SdaiProduct_definition_context (STEPentity *se ) : SdaiApplication_context_element(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_context;

    STEPattribute * a = new STEPattribute (*a_227life_cycle_stage,  &_life_cycle_stage);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiProduct_definition_context::Life_cycle_stage() const
	{ return (const SdaiLabel) _life_cycle_stage; }

void 
SdaiProduct_definition_context::Life_cycle_stage (const char * x)
	{ _life_cycle_stage = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_context 


/////////	 ENTITY item_defined_transformation 

EntityDescriptor *config_control_designe_item_defined_transformation =0;
AttrDescriptor *a_228name =0;
AttrDescriptor *a_229description =0;
AttrDescriptor *a_230transform_item_1 =0;
AttrDescriptor *a_231transform_item_2 =0;
SdaiItem_defined_transformation::SdaiItem_defined_transformation( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_item_defined_transformation;

    STEPattribute * a = new STEPattribute (*a_228name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_229description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_230transform_item_1, (STEPentityH *) &_transform_item_1);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_231transform_item_2, (STEPentityH *) &_transform_item_2);
    a -> set_null ();
    attributes.push (a);
}
SdaiItem_defined_transformation::SdaiItem_defined_transformation (SdaiItem_defined_transformation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiItem_defined_transformation::~SdaiItem_defined_transformation () {  }
SdaiItem_defined_transformation::SdaiItem_defined_transformation( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_item_defined_transformation;

    STEPattribute * a = new STEPattribute (*a_228name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_229description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_230transform_item_1, (STEPentityH *) &_transform_item_1);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_231transform_item_2, (STEPentityH *) &_transform_item_2);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiItem_defined_transformation::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiItem_defined_transformation::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiItem_defined_transformation::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiItem_defined_transformation::Description (const char * x)
	{ _description = x; }

SdaiRepresentation_itemH 
SdaiItem_defined_transformation::Transform_item_1() const 
	{ return (SdaiRepresentation_itemH) _transform_item_1; }

void 
SdaiItem_defined_transformation::Transform_item_1 (SdaiRepresentation_itemH x)
	{ _transform_item_1 = x; }

SdaiRepresentation_itemH 
SdaiItem_defined_transformation::Transform_item_2() const 
	{ return (SdaiRepresentation_itemH) _transform_item_2; }

void 
SdaiItem_defined_transformation::Transform_item_2 (SdaiRepresentation_itemH x)
	{ _transform_item_2 = x; }

/////////	 END_ENTITY item_defined_transformation 


/////////	 ENTITY action_method 

EntityDescriptor *config_control_designe_action_method =0;
AttrDescriptor *a_232name =0;
AttrDescriptor *a_233description =0;
AttrDescriptor *a_234consequence =0;
AttrDescriptor *a_235purpose =0;
SdaiAction_method::SdaiAction_method( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_method;

    STEPattribute * a = new STEPattribute (*a_232name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_233description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_234consequence,  &_consequence);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_235purpose,  &_purpose);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_method::SdaiAction_method (SdaiAction_method& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction_method::~SdaiAction_method () {  }
SdaiAction_method::SdaiAction_method( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action_method;

    STEPattribute * a = new STEPattribute (*a_232name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_233description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_234consequence,  &_consequence);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_235purpose,  &_purpose);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAction_method::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiAction_method::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiAction_method::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiAction_method::Description (const char * x)
	{ _description = x; }

const SdaiText 
SdaiAction_method::Consequence() const
	{ return (const SdaiText) _consequence; }

void 
SdaiAction_method::Consequence (const char * x)
	{ _consequence = x; }

const SdaiText 
SdaiAction_method::Purpose() const
	{ return (const SdaiText) _purpose; }

void 
SdaiAction_method::Purpose (const char * x)
	{ _purpose = x; }

/////////	 END_ENTITY action_method 


/////////	 ENTITY product_category_relationship 

EntityDescriptor *config_control_designe_product_category_relationship =0;
AttrDescriptor *a_236name =0;
AttrDescriptor *a_237description =0;
AttrDescriptor *a_238category =0;
AttrDescriptor *a_239sub_category =0;
SdaiProduct_category_relationship::SdaiProduct_category_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category_relationship;

    STEPattribute * a = new STEPattribute (*a_236name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_237description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_238category, (STEPentityH *) &_category);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_239sub_category, (STEPentityH *) &_sub_category);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_category_relationship::SdaiProduct_category_relationship (SdaiProduct_category_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_category_relationship::~SdaiProduct_category_relationship () {  }
SdaiProduct_category_relationship::SdaiProduct_category_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_product_category_relationship;

    STEPattribute * a = new STEPattribute (*a_236name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_237description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_238category, (STEPentityH *) &_category);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_239sub_category, (STEPentityH *) &_sub_category);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiProduct_category_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiProduct_category_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiProduct_category_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProduct_category_relationship::Description (const char * x)
	{ _description = x; }

SdaiProduct_categoryH 
SdaiProduct_category_relationship::Category() const 
	{ return (SdaiProduct_categoryH) _category; }

void 
SdaiProduct_category_relationship::Category (SdaiProduct_categoryH x)
	{ _category = x; }

SdaiProduct_categoryH 
SdaiProduct_category_relationship::Sub_category() const 
	{ return (SdaiProduct_categoryH) _sub_category; }

void 
SdaiProduct_category_relationship::Sub_category (SdaiProduct_categoryH x)
	{ _sub_category = x; }

/////////	 END_ENTITY product_category_relationship 


/////////	 ENTITY plane_angle_measure_with_unit 

EntityDescriptor *config_control_designe_plane_angle_measure_with_unit =0;
SdaiPlane_angle_measure_with_unit::SdaiPlane_angle_measure_with_unit( ) 
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_measure_with_unit;
}
SdaiPlane_angle_measure_with_unit::SdaiPlane_angle_measure_with_unit (SdaiPlane_angle_measure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPlane_angle_measure_with_unit::~SdaiPlane_angle_measure_with_unit () {  }
SdaiPlane_angle_measure_with_unit::SdaiPlane_angle_measure_with_unit (STEPentity *se ) : SdaiMeasure_with_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane_angle_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY plane_angle_measure_with_unit 


/////////	 ENTITY vertex 

EntityDescriptor *config_control_designe_vertex =0;
SdaiVertex::SdaiVertex( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex;
}
SdaiVertex::SdaiVertex (SdaiVertex& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVertex::~SdaiVertex () {  }
SdaiVertex::SdaiVertex (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vertex 


/////////	 ENTITY representation_map 

EntityDescriptor *config_control_designe_representation_map =0;
AttrDescriptor *a_240mapping_origin =0;
AttrDescriptor *a_241mapped_representation =0;
InverseAttrDescriptor *a_242Imap_usage =0;
SdaiRepresentation_map::SdaiRepresentation_map( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_map;

    STEPattribute * a = new STEPattribute (*a_240mapping_origin, (STEPentityH *) &_mapping_origin);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_241mapped_representation, (STEPentityH *) &_mapped_representation);
    a -> set_null ();
    attributes.push (a);
}
SdaiRepresentation_map::SdaiRepresentation_map (SdaiRepresentation_map& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRepresentation_map::~SdaiRepresentation_map () {  }
SdaiRepresentation_map::SdaiRepresentation_map( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_representation_map;

    STEPattribute * a = new STEPattribute (*a_240mapping_origin, (STEPentityH *) &_mapping_origin);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_241mapped_representation, (STEPentityH *) &_mapped_representation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiRepresentation_itemH 
SdaiRepresentation_map::Mapping_origin() const 
	{ return (SdaiRepresentation_itemH) _mapping_origin; }

void 
SdaiRepresentation_map::Mapping_origin (SdaiRepresentation_itemH x)
	{ _mapping_origin = x; }

SdaiRepresentationH 
SdaiRepresentation_map::Mapped_representation() const 
	{ return (SdaiRepresentationH) _mapped_representation; }

void 
SdaiRepresentation_map::Mapped_representation (SdaiRepresentationH x)
	{ _mapped_representation = x; }

const EntityAggregateH 
SdaiRepresentation_map::Map_usage() const 
	{ return (EntityAggregateH) &_map_usage; }

void 
SdaiRepresentation_map::Map_usage (EntityAggregateH x)
	{ _map_usage.ShallowCopy (*x); }

/////////	 END_ENTITY representation_map 


/////////	 ENTITY product_definition_effectivity 

EntityDescriptor *config_control_designe_product_definition_effectivity =0;
AttrDescriptor *a_243usage =0;
SdaiProduct_definition_effectivity::SdaiProduct_definition_effectivity( ) 
{

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_effectivity;

    STEPattribute * a = new STEPattribute (*a_243usage, (STEPentityH *) &_usage);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_effectivity::SdaiProduct_definition_effectivity (SdaiProduct_definition_effectivity& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_effectivity::~SdaiProduct_definition_effectivity () {  }
SdaiProduct_definition_effectivity::SdaiProduct_definition_effectivity (STEPentity *se ) : SdaiEffectivity(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiEffectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_effectivity;

    STEPattribute * a = new STEPattribute (*a_243usage, (STEPentityH *) &_usage);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiProduct_definition_relationshipH 
SdaiProduct_definition_effectivity::Usage() const 
	{ return (SdaiProduct_definition_relationshipH) _usage; }

void 
SdaiProduct_definition_effectivity::Usage (SdaiProduct_definition_relationshipH x)
	{ _usage = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_effectivity 


/////////	 ENTITY configuration_effectivity 

EntityDescriptor *config_control_designe_configuration_effectivity =0;
AttrDescriptor *a_244configuration =0;
SdaiConfiguration_effectivity::SdaiConfiguration_effectivity( ) 
{

	/*  parent: SdaiProduct_definition_effectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_configuration_effectivity;

    STEPattribute * a = new STEPattribute (*a_244configuration, (STEPentityH *) &_configuration);
    a -> set_null ();
    attributes.push (a);
}
SdaiConfiguration_effectivity::SdaiConfiguration_effectivity (SdaiConfiguration_effectivity& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConfiguration_effectivity::~SdaiConfiguration_effectivity () {  }
SdaiConfiguration_effectivity::SdaiConfiguration_effectivity (STEPentity *se ) : SdaiProduct_definition_effectivity(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition_effectivity  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_configuration_effectivity;

    STEPattribute * a = new STEPattribute (*a_244configuration, (STEPentityH *) &_configuration);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiConfiguration_designH 
SdaiConfiguration_effectivity::Configuration() const 
	{ return (SdaiConfiguration_designH) _configuration; }

void 
SdaiConfiguration_effectivity::Configuration (SdaiConfiguration_designH x)
	{ _configuration = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY configuration_effectivity 


/////////	 ENTITY ellipse 

EntityDescriptor *config_control_designe_ellipse =0;
AttrDescriptor *a_245semi_axis_1 =0;
AttrDescriptor *a_246semi_axis_2 =0;
SdaiEllipse::SdaiEllipse( ) 
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ellipse;

    STEPattribute * a = new STEPattribute (*a_245semi_axis_1,  &_semi_axis_1);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_246semi_axis_2,  &_semi_axis_2);
    a -> set_null ();
    attributes.push (a);
}
SdaiEllipse::SdaiEllipse (SdaiEllipse& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEllipse::~SdaiEllipse () {  }
SdaiEllipse::SdaiEllipse (STEPentity *se ) : SdaiConic(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ellipse;

    STEPattribute * a = new STEPattribute (*a_245semi_axis_1,  &_semi_axis_1);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_246semi_axis_2,  &_semi_axis_2);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPositive_length_measure 
SdaiEllipse::Semi_axis_1() const 
	{ return (const SdaiPositive_length_measure) _semi_axis_1; }

void 
SdaiEllipse::Semi_axis_1 (SdaiPositive_length_measure x)
	{ _semi_axis_1 = x; }

const SdaiPositive_length_measure 
SdaiEllipse::Semi_axis_2() const 
	{ return (const SdaiPositive_length_measure) _semi_axis_2; }

void 
SdaiEllipse::Semi_axis_2 (SdaiPositive_length_measure x)
	{ _semi_axis_2 = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY ellipse 


/////////	 ENTITY context_dependent_unit 

EntityDescriptor *config_control_designe_context_dependent_unit =0;
AttrDescriptor *a_247name =0;
SdaiContext_dependent_unit::SdaiContext_dependent_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_context_dependent_unit;

    STEPattribute * a = new STEPattribute (*a_247name,  &_name);
    a -> set_null ();
    attributes.push (a);
}
SdaiContext_dependent_unit::SdaiContext_dependent_unit (SdaiContext_dependent_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiContext_dependent_unit::~SdaiContext_dependent_unit () {  }
SdaiContext_dependent_unit::SdaiContext_dependent_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_context_dependent_unit;

    STEPattribute * a = new STEPattribute (*a_247name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiContext_dependent_unit::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiContext_dependent_unit::Name (const char * x)
	{ _name = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY context_dependent_unit 


/////////	 ENTITY alternate_product_relationship 

EntityDescriptor *config_control_designe_alternate_product_relationship =0;
AttrDescriptor *a_248name =0;
AttrDescriptor *a_249description =0;
AttrDescriptor *a_250alternate =0;
AttrDescriptor *a_251base =0;
AttrDescriptor *a_252basis =0;
SdaiAlternate_product_relationship::SdaiAlternate_product_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_alternate_product_relationship;

    STEPattribute * a = new STEPattribute (*a_248name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_249description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_250alternate, (STEPentityH *) &_alternate);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_251base, (STEPentityH *) &_base);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_252basis,  &_basis);
    a -> set_null ();
    attributes.push (a);
}
SdaiAlternate_product_relationship::SdaiAlternate_product_relationship (SdaiAlternate_product_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAlternate_product_relationship::~SdaiAlternate_product_relationship () {  }
SdaiAlternate_product_relationship::SdaiAlternate_product_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_alternate_product_relationship;

    STEPattribute * a = new STEPattribute (*a_248name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_249description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_250alternate, (STEPentityH *) &_alternate);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_251base, (STEPentityH *) &_base);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_252basis,  &_basis);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAlternate_product_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiAlternate_product_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiAlternate_product_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiAlternate_product_relationship::Description (const char * x)
	{ _description = x; }

SdaiProductH 
SdaiAlternate_product_relationship::Alternate() const 
	{ return (SdaiProductH) _alternate; }

void 
SdaiAlternate_product_relationship::Alternate (SdaiProductH x)
	{ _alternate = x; }

SdaiProductH 
SdaiAlternate_product_relationship::Base() const 
	{ return (SdaiProductH) _base; }

void 
SdaiAlternate_product_relationship::Base (SdaiProductH x)
	{ _base = x; }

const SdaiText 
SdaiAlternate_product_relationship::Basis() const
	{ return (const SdaiText) _basis; }

void 
SdaiAlternate_product_relationship::Basis (const char * x)
	{ _basis = x; }

/////////	 END_ENTITY alternate_product_relationship 


/////////	 ENTITY document_type 

EntityDescriptor *config_control_designe_document_type =0;
AttrDescriptor *a_253product_data_type =0;
SdaiDocument_type::SdaiDocument_type( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_type;

    STEPattribute * a = new STEPattribute (*a_253product_data_type,  &_product_data_type);
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_type::SdaiDocument_type (SdaiDocument_type& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDocument_type::~SdaiDocument_type () {  }
SdaiDocument_type::SdaiDocument_type( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_document_type;

    STEPattribute * a = new STEPattribute (*a_253product_data_type,  &_product_data_type);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiDocument_type::Product_data_type() const
	{ return (const SdaiLabel) _product_data_type; }

void 
SdaiDocument_type::Product_data_type (const char * x)
	{ _product_data_type = x; }

/////////	 END_ENTITY document_type 


/////////	 ENTITY document_reference 

EntityDescriptor *config_control_designe_document_reference =0;
AttrDescriptor *a_254assigned_document =0;
AttrDescriptor *a_255source =0;
SdaiDocument_reference::SdaiDocument_reference( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_reference;

    STEPattribute * a = new STEPattribute (*a_254assigned_document, (STEPentityH *) &_assigned_document);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_255source,  &_source);
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_reference::SdaiDocument_reference (SdaiDocument_reference& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDocument_reference::~SdaiDocument_reference () {  }
SdaiDocument_reference::SdaiDocument_reference( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_document_reference;

    STEPattribute * a = new STEPattribute (*a_254assigned_document, (STEPentityH *) &_assigned_document);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_255source,  &_source);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDocumentH 
SdaiDocument_reference::Assigned_document() const 
	{ return (SdaiDocumentH) _assigned_document; }

void 
SdaiDocument_reference::Assigned_document (SdaiDocumentH x)
	{ _assigned_document = x; }

const SdaiLabel 
SdaiDocument_reference::Source() const
	{ return (const SdaiLabel) _source; }

void 
SdaiDocument_reference::Source (const char * x)
	{ _source = x; }

/////////	 END_ENTITY document_reference 


/////////	 ENTITY mechanical_context 

EntityDescriptor *config_control_designe_mechanical_context =0;
SdaiMechanical_context::SdaiMechanical_context( ) 
{

	/*  parent: SdaiProduct_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mechanical_context;
}
SdaiMechanical_context::SdaiMechanical_context (SdaiMechanical_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiMechanical_context::~SdaiMechanical_context () {  }
SdaiMechanical_context::SdaiMechanical_context (STEPentity *se ) : SdaiProduct_context(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mechanical_context;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mechanical_context 


/////////	 ENTITY shell_based_wireframe_model 

EntityDescriptor *config_control_designe_shell_based_wireframe_model =0;
AttrDescriptor *a_256sbwm_boundary =0;
SdaiShell_based_wireframe_model::SdaiShell_based_wireframe_model( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_model;

    STEPattribute * a = new STEPattribute (*a_256sbwm_boundary,  &_sbwm_boundary);
    a -> set_null ();
    attributes.push (a);
}
SdaiShell_based_wireframe_model::SdaiShell_based_wireframe_model (SdaiShell_based_wireframe_model& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShell_based_wireframe_model::~SdaiShell_based_wireframe_model () {  }
SdaiShell_based_wireframe_model::SdaiShell_based_wireframe_model (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_model;

    STEPattribute * a = new STEPattribute (*a_256sbwm_boundary,  &_sbwm_boundary);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiShellsH 
SdaiShell_based_wireframe_model::Sbwm_boundary() const 
	{ return (SdaiShellsH) &_sbwm_boundary; }

void 
SdaiShell_based_wireframe_model::Sbwm_boundary (SdaiShellsH x)
	{ _sbwm_boundary.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shell_based_wireframe_model 


/////////	 ENTITY contract 

EntityDescriptor *config_control_designe_contract =0;
AttrDescriptor *a_257name =0;
AttrDescriptor *a_258purpose =0;
AttrDescriptor *a_259kind =0;
SdaiContract::SdaiContract( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_contract;

    STEPattribute * a = new STEPattribute (*a_257name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_258purpose,  &_purpose);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_259kind, (STEPentityH *) &_kind);
    a -> set_null ();
    attributes.push (a);
}
SdaiContract::SdaiContract (SdaiContract& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiContract::~SdaiContract () {  }
SdaiContract::SdaiContract( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_contract;

    STEPattribute * a = new STEPattribute (*a_257name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_258purpose,  &_purpose);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_259kind, (STEPentityH *) &_kind);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiContract::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiContract::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiContract::Purpose() const
	{ return (const SdaiText) _purpose; }

void 
SdaiContract::Purpose (const char * x)
	{ _purpose = x; }

SdaiContract_typeH 
SdaiContract::Kind() const 
	{ return (SdaiContract_typeH) _kind; }

void 
SdaiContract::Kind (SdaiContract_typeH x)
	{ _kind = x; }

/////////	 END_ENTITY contract 


/////////	 ENTITY dimensional_exponents 

EntityDescriptor *config_control_designe_dimensional_exponents =0;
AttrDescriptor *a_260length_exponent =0;
AttrDescriptor *a_261mass_exponent =0;
AttrDescriptor *a_262time_exponent =0;
AttrDescriptor *a_263electric_current_exponent =0;
AttrDescriptor *a_264thermodynamic_temperature_exponent =0;
AttrDescriptor *a_265amount_of_substance_exponent =0;
AttrDescriptor *a_266luminous_intensity_exponent =0;
SdaiDimensional_exponents::SdaiDimensional_exponents( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_dimensional_exponents;

    STEPattribute * a = new STEPattribute (*a_260length_exponent,  &_length_exponent);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_261mass_exponent,  &_mass_exponent);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_262time_exponent,  &_time_exponent);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_263electric_current_exponent,  &_electric_current_exponent);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_264thermodynamic_temperature_exponent,  &_thermodynamic_temperature_exponent);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_265amount_of_substance_exponent,  &_amount_of_substance_exponent);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_266luminous_intensity_exponent,  &_luminous_intensity_exponent);
    a -> set_null ();
    attributes.push (a);
}
SdaiDimensional_exponents::SdaiDimensional_exponents (SdaiDimensional_exponents& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDimensional_exponents::~SdaiDimensional_exponents () {  }
SdaiDimensional_exponents::SdaiDimensional_exponents( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_dimensional_exponents;

    STEPattribute * a = new STEPattribute (*a_260length_exponent,  &_length_exponent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_261mass_exponent,  &_mass_exponent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_262time_exponent,  &_time_exponent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_263electric_current_exponent,  &_electric_current_exponent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_264thermodynamic_temperature_exponent,  &_thermodynamic_temperature_exponent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_265amount_of_substance_exponent,  &_amount_of_substance_exponent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_266luminous_intensity_exponent,  &_luminous_intensity_exponent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiReal 
SdaiDimensional_exponents::Length_exponent() const 
	{ return (const SdaiReal) _length_exponent; }

void 
SdaiDimensional_exponents::Length_exponent (SdaiReal x)
	{ _length_exponent = x; }

const SdaiReal 
SdaiDimensional_exponents::Mass_exponent() const 
	{ return (const SdaiReal) _mass_exponent; }

void 
SdaiDimensional_exponents::Mass_exponent (SdaiReal x)
	{ _mass_exponent = x; }

const SdaiReal 
SdaiDimensional_exponents::Time_exponent() const 
	{ return (const SdaiReal) _time_exponent; }

void 
SdaiDimensional_exponents::Time_exponent (SdaiReal x)
	{ _time_exponent = x; }

const SdaiReal 
SdaiDimensional_exponents::Electric_current_exponent() const 
	{ return (const SdaiReal) _electric_current_exponent; }

void 
SdaiDimensional_exponents::Electric_current_exponent (SdaiReal x)
	{ _electric_current_exponent = x; }

const SdaiReal 
SdaiDimensional_exponents::Thermodynamic_temperature_exponent() const 
	{ return (const SdaiReal) _thermodynamic_temperature_exponent; }

void 
SdaiDimensional_exponents::Thermodynamic_temperature_exponent (SdaiReal x)
	{ _thermodynamic_temperature_exponent = x; }

const SdaiReal 
SdaiDimensional_exponents::Amount_of_substance_exponent() const 
	{ return (const SdaiReal) _amount_of_substance_exponent; }

void 
SdaiDimensional_exponents::Amount_of_substance_exponent (SdaiReal x)
	{ _amount_of_substance_exponent = x; }

const SdaiReal 
SdaiDimensional_exponents::Luminous_intensity_exponent() const 
	{ return (const SdaiReal) _luminous_intensity_exponent; }

void 
SdaiDimensional_exponents::Luminous_intensity_exponent (SdaiReal x)
	{ _luminous_intensity_exponent = x; }

/////////	 END_ENTITY dimensional_exponents 


/////////	 ENTITY start_request 

EntityDescriptor *config_control_designe_start_request =0;
AttrDescriptor *a_267items =0;
SdaiStart_request::SdaiStart_request( ) 
{

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_request;

    STEPattribute * a = new STEPattribute (*a_267items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiStart_request::SdaiStart_request (SdaiStart_request& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiStart_request::~SdaiStart_request () {  }
SdaiStart_request::SdaiStart_request (STEPentity *se ) : SdaiAction_request_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAction_request_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_request;

    STEPattribute * a = new STEPattribute (*a_267items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiStart_request_itemsH 
SdaiStart_request::Items() const 
	{ return (SdaiStart_request_itemsH) &_items; }

void 
SdaiStart_request::Items (SdaiStart_request_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY start_request 


/////////	 ENTITY cc_design_specification_reference 

EntityDescriptor *config_control_designe_cc_design_specification_reference =0;
AttrDescriptor *a_268items =0;
SdaiCc_design_specification_reference::SdaiCc_design_specification_reference( ) 
{

	/*  parent: SdaiDocument_reference  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_specification_reference;

    STEPattribute * a = new STEPattribute (*a_268items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_specification_reference::SdaiCc_design_specification_reference (SdaiCc_design_specification_reference& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCc_design_specification_reference::~SdaiCc_design_specification_reference () {  }
SdaiCc_design_specification_reference::SdaiCc_design_specification_reference (STEPentity *se ) : SdaiDocument_reference(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiDocument_reference  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_specification_reference;

    STEPattribute * a = new STEPattribute (*a_268items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiSpecified_itemsH 
SdaiCc_design_specification_reference::Items() const 
	{ return (SdaiSpecified_itemsH) &_items; }

void 
SdaiCc_design_specification_reference::Items (SdaiSpecified_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_specification_reference 


/////////	 ENTITY supplied_part_relationship 

EntityDescriptor *config_control_designe_supplied_part_relationship =0;
SdaiSupplied_part_relationship::SdaiSupplied_part_relationship( ) 
{

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_supplied_part_relationship;
}
SdaiSupplied_part_relationship::SdaiSupplied_part_relationship (SdaiSupplied_part_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSupplied_part_relationship::~SdaiSupplied_part_relationship () {  }
SdaiSupplied_part_relationship::SdaiSupplied_part_relationship (STEPentity *se ) : SdaiProduct_definition_relationship(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_supplied_part_relationship;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY supplied_part_relationship 


/////////	 ENTITY context_dependent_shape_representation 

EntityDescriptor *config_control_designe_context_dependent_shape_representation =0;
AttrDescriptor *a_269representation_relation =0;
AttrDescriptor *a_270represented_product_relation =0;
SdaiContext_dependent_shape_representation::SdaiContext_dependent_shape_representation( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_context_dependent_shape_representation;

    STEPattribute * a = new STEPattribute (*a_269representation_relation, (STEPentityH *) &_representation_relation);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_270represented_product_relation, (STEPentityH *) &_represented_product_relation);
    a -> set_null ();
    attributes.push (a);
}
SdaiContext_dependent_shape_representation::SdaiContext_dependent_shape_representation (SdaiContext_dependent_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiContext_dependent_shape_representation::~SdaiContext_dependent_shape_representation () {  }
SdaiContext_dependent_shape_representation::SdaiContext_dependent_shape_representation( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_context_dependent_shape_representation;

    STEPattribute * a = new STEPattribute (*a_269representation_relation, (STEPentityH *) &_representation_relation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_270represented_product_relation, (STEPentityH *) &_represented_product_relation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiShape_representation_relationshipH 
SdaiContext_dependent_shape_representation::Representation_relation() const 
	{ return (SdaiShape_representation_relationshipH) _representation_relation; }

void 
SdaiContext_dependent_shape_representation::Representation_relation (SdaiShape_representation_relationshipH x)
	{ _representation_relation = x; }

SdaiProduct_definition_shapeH 
SdaiContext_dependent_shape_representation::Represented_product_relation() const 
	{ return (SdaiProduct_definition_shapeH) _represented_product_relation; }

void 
SdaiContext_dependent_shape_representation::Represented_product_relation (SdaiProduct_definition_shapeH x)
	{ _represented_product_relation = x; }

/////////	 END_ENTITY context_dependent_shape_representation 


/////////	 ENTITY ordinal_date 

EntityDescriptor *config_control_designe_ordinal_date =0;
AttrDescriptor *a_271day_component =0;
SdaiOrdinal_date::SdaiOrdinal_date( ) 
{

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ordinal_date;

    STEPattribute * a = new STEPattribute (*a_271day_component,  &_day_component);
    a -> set_null ();
    attributes.push (a);
}
SdaiOrdinal_date::SdaiOrdinal_date (SdaiOrdinal_date& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOrdinal_date::~SdaiOrdinal_date () {  }
SdaiOrdinal_date::SdaiOrdinal_date (STEPentity *se ) : SdaiDate(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_ordinal_date;

    STEPattribute * a = new STEPattribute (*a_271day_component,  &_day_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiDay_in_year_number 
SdaiOrdinal_date::Day_component() const 
	{ return (const SdaiDay_in_year_number) _day_component; }

void 
SdaiOrdinal_date::Day_component (SdaiDay_in_year_number x)
	{ _day_component = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY ordinal_date 


/////////	 ENTITY face_outer_bound 

EntityDescriptor *config_control_designe_face_outer_bound =0;
SdaiFace_outer_bound::SdaiFace_outer_bound( ) 
{

	/*  parent: SdaiFace_bound  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_outer_bound;
}
SdaiFace_outer_bound::SdaiFace_outer_bound (SdaiFace_outer_bound& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiFace_outer_bound::~SdaiFace_outer_bound () {  }
SdaiFace_outer_bound::SdaiFace_outer_bound (STEPentity *se ) : SdaiFace_bound(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiFace_bound  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face_outer_bound;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY face_outer_bound 


/////////	 ENTITY mass_measure_with_unit 

EntityDescriptor *config_control_designe_mass_measure_with_unit =0;
SdaiMass_measure_with_unit::SdaiMass_measure_with_unit( ) 
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_measure_with_unit;
}
SdaiMass_measure_with_unit::SdaiMass_measure_with_unit (SdaiMass_measure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiMass_measure_with_unit::~SdaiMass_measure_with_unit () {  }
SdaiMass_measure_with_unit::SdaiMass_measure_with_unit (STEPentity *se ) : SdaiMeasure_with_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mass_measure_with_unit 


/////////	 ENTITY brep_with_voids 

EntityDescriptor *config_control_designe_brep_with_voids =0;
AttrDescriptor *a_272voids =0;
SdaiBrep_with_voids::SdaiBrep_with_voids( ) 
{

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_brep_with_voids;

    STEPattribute * a = new STEPattribute (*a_272voids,  &_voids);
    a -> set_null ();
    attributes.push (a);
}
SdaiBrep_with_voids::SdaiBrep_with_voids (SdaiBrep_with_voids& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiBrep_with_voids::~SdaiBrep_with_voids () {  }
SdaiBrep_with_voids::SdaiBrep_with_voids (STEPentity *se ) : SdaiManifold_solid_brep(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiManifold_solid_brep  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_brep_with_voids;

    STEPattribute * a = new STEPattribute (*a_272voids,  &_voids);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiBrep_with_voids::Voids() const 
	{ return (EntityAggregateH) &_voids; }

void 
SdaiBrep_with_voids::Voids (EntityAggregateH x)
	{ _voids.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY brep_with_voids 


/////////	 ENTITY week_of_year_and_day_date 

EntityDescriptor *config_control_designe_week_of_year_and_day_date =0;
AttrDescriptor *a_273week_component =0;
AttrDescriptor *a_274day_component =0;
SdaiWeek_of_year_and_day_date::SdaiWeek_of_year_and_day_date( ) 
{

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_week_of_year_and_day_date;

    STEPattribute * a = new STEPattribute (*a_273week_component,  &_week_component);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_274day_component,  &_day_component);
    a -> set_null ();
    attributes.push (a);
}
SdaiWeek_of_year_and_day_date::SdaiWeek_of_year_and_day_date (SdaiWeek_of_year_and_day_date& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiWeek_of_year_and_day_date::~SdaiWeek_of_year_and_day_date () {  }
SdaiWeek_of_year_and_day_date::SdaiWeek_of_year_and_day_date (STEPentity *se ) : SdaiDate(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiDate  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_week_of_year_and_day_date;

    STEPattribute * a = new STEPattribute (*a_273week_component,  &_week_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_274day_component,  &_day_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiWeek_in_year_number 
SdaiWeek_of_year_and_day_date::Week_component() const 
	{ return (const SdaiWeek_in_year_number) _week_component; }

void 
SdaiWeek_of_year_and_day_date::Week_component (SdaiWeek_in_year_number x)
	{ _week_component = x; }

const SdaiDay_in_week_number 
SdaiWeek_of_year_and_day_date::Day_component() const 
	{ return (const SdaiDay_in_week_number) _day_component; }

void 
SdaiWeek_of_year_and_day_date::Day_component (SdaiDay_in_week_number x)
	{ _day_component = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY week_of_year_and_day_date 


/////////	 ENTITY point_on_curve 

EntityDescriptor *config_control_designe_point_on_curve =0;
AttrDescriptor *a_275basis_curve =0;
AttrDescriptor *a_276point_parameter =0;
SdaiPoint_on_curve::SdaiPoint_on_curve( ) 
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_curve;

    STEPattribute * a = new STEPattribute (*a_275basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_276point_parameter,  &_point_parameter);
    a -> set_null ();
    attributes.push (a);
}
SdaiPoint_on_curve::SdaiPoint_on_curve (SdaiPoint_on_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPoint_on_curve::~SdaiPoint_on_curve () {  }
SdaiPoint_on_curve::SdaiPoint_on_curve (STEPentity *se ) : SdaiPoint(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_on_curve;

    STEPattribute * a = new STEPattribute (*a_275basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_276point_parameter,  &_point_parameter);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiPoint_on_curve::Basis_curve() const 
	{ return (SdaiCurveH) _basis_curve; }

void 
SdaiPoint_on_curve::Basis_curve (SdaiCurveH x)
	{ _basis_curve = x; }

const SdaiParameter_value 
SdaiPoint_on_curve::Point_parameter() const 
	{ return (const SdaiParameter_value) _point_parameter; }

void 
SdaiPoint_on_curve::Point_parameter (SdaiParameter_value x)
	{ _point_parameter = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point_on_curve 


/////////	 ENTITY shell_based_wireframe_shape_representation 

EntityDescriptor *config_control_designe_shell_based_wireframe_shape_representation =0;
SdaiShell_based_wireframe_shape_representation::SdaiShell_based_wireframe_shape_representation( ) 
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_shape_representation;
}
SdaiShell_based_wireframe_shape_representation::SdaiShell_based_wireframe_shape_representation (SdaiShell_based_wireframe_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShell_based_wireframe_shape_representation::~SdaiShell_based_wireframe_shape_representation () {  }
SdaiShell_based_wireframe_shape_representation::SdaiShell_based_wireframe_shape_representation (STEPentity *se ) : SdaiShape_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shell_based_wireframe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shell_based_wireframe_shape_representation 


/////////	 ENTITY face 

EntityDescriptor *config_control_designe_face =0;
AttrDescriptor *a_277bounds =0;
SdaiFace::SdaiFace( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face;

    STEPattribute * a = new STEPattribute (*a_277bounds,  &_bounds);
    a -> set_null ();
    attributes.push (a);
}
SdaiFace::SdaiFace (SdaiFace& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiFace::~SdaiFace () {  }
SdaiFace::SdaiFace (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_face;

    STEPattribute * a = new STEPattribute (*a_277bounds,  &_bounds);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiFace::Bounds() const 
	{ return (EntityAggregateH) &_bounds; }

void 
SdaiFace::Bounds (EntityAggregateH x)
	{ _bounds.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY face 


/////////	 ENTITY face_surface 

EntityDescriptor *config_control_designe_face_surface =0;
AttrDescriptor *a_278face_geometry =0;
AttrDescriptor *a_279same_sense =0;
SdaiFace_surface::SdaiFace_surface( ) 
{

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    AppendMultInstance(new SdaiGeometric_representation_item(this)); 

    eDesc = config_control_designe_face_surface;

    STEPattribute * a = new STEPattribute (*a_278face_geometry, (STEPentityH *) &_face_geometry);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_279same_sense,  &_same_sense);
    a -> set_null ();
    attributes.push (a);
}
SdaiFace_surface::SdaiFace_surface (SdaiFace_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiFace_surface::~SdaiFace_surface () {  }
SdaiFace_surface::SdaiFace_surface (STEPentity *se ) : SdaiFace(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    se->AppendMultInstance(new SdaiGeometric_representation_item(se)); 

    eDesc = config_control_designe_face_surface;

    STEPattribute * a = new STEPattribute (*a_278face_geometry, (STEPentityH *) &_face_geometry);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_279same_sense,  &_same_sense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiFace_surface::Face_geometry() const 
	{ return (SdaiSurfaceH) _face_geometry; }

void 
SdaiFace_surface::Face_geometry (SdaiSurfaceH x)
	{ _face_geometry = x; }

const BOOLEAN 
SdaiFace_surface::Same_sense() const 
	{ return (LOGICAL) _same_sense; }

void 
SdaiFace_surface::Same_sense (BOOLEAN x)
	{ _same_sense.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY face_surface 


/////////	 ENTITY oriented_face 

EntityDescriptor *config_control_designe_oriented_face =0;
AttrDescriptor *a_280face_element =0;
AttrDescriptor *a_281orientation =0;
AttrDescriptor *a_282Dface_bounds =0;
SdaiOriented_face::SdaiOriented_face( ) 
{

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_face;

    STEPattribute * a = new STEPattribute (*a_280face_element, (STEPentityH *) &_face_element);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_281orientation,  &_orientation);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("bounds");
}
SdaiOriented_face::SdaiOriented_face (SdaiOriented_face& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOriented_face::~SdaiOriented_face () {  }
SdaiOriented_face::SdaiOriented_face (STEPentity *se ) : SdaiFace(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiFace  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_face;

    STEPattribute * a = new STEPattribute (*a_280face_element, (STEPentityH *) &_face_element);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_281orientation,  &_orientation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("bounds");
}

SdaiFaceH 
SdaiOriented_face::Face_element() const 
	{ return (SdaiFaceH) _face_element; }

void 
SdaiOriented_face::Face_element (SdaiFaceH x)
	{ _face_element = x; }

const BOOLEAN 
SdaiOriented_face::Orientation() const 
	{ return (LOGICAL) _orientation; }

void 
SdaiOriented_face::Orientation (BOOLEAN x)
	{ _orientation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_face 


/////////	 ENTITY surface_of_revolution 

EntityDescriptor *config_control_designe_surface_of_revolution =0;
AttrDescriptor *a_283axis_position =0;
AttrDescriptor *a_284Daxis_line =0;
SdaiSurface_of_revolution::SdaiSurface_of_revolution( ) 
{

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_revolution;

    STEPattribute * a = new STEPattribute (*a_283axis_position, (STEPentityH *) &_axis_position);
    a -> set_null ();
    attributes.push (a);
}
SdaiSurface_of_revolution::SdaiSurface_of_revolution (SdaiSurface_of_revolution& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSurface_of_revolution::~SdaiSurface_of_revolution () {  }
SdaiSurface_of_revolution::SdaiSurface_of_revolution (STEPentity *se ) : SdaiSwept_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSwept_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_of_revolution;

    STEPattribute * a = new STEPattribute (*a_283axis_position, (STEPentityH *) &_axis_position);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiAxis1_placementH 
SdaiSurface_of_revolution::Axis_position() const 
	{ return (SdaiAxis1_placementH) _axis_position; }

void 
SdaiSurface_of_revolution::Axis_position (SdaiAxis1_placementH x)
	{ _axis_position = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_of_revolution 


/////////	 ENTITY advanced_brep_shape_representation 

EntityDescriptor *config_control_designe_advanced_brep_shape_representation =0;
SdaiAdvanced_brep_shape_representation::SdaiAdvanced_brep_shape_representation( ) 
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_brep_shape_representation;
}
SdaiAdvanced_brep_shape_representation::SdaiAdvanced_brep_shape_representation (SdaiAdvanced_brep_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAdvanced_brep_shape_representation::~SdaiAdvanced_brep_shape_representation () {  }
SdaiAdvanced_brep_shape_representation::SdaiAdvanced_brep_shape_representation (STEPentity *se ) : SdaiShape_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_brep_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY advanced_brep_shape_representation 


/////////	 ENTITY edge_curve 

EntityDescriptor *config_control_designe_edge_curve =0;
AttrDescriptor *a_285edge_geometry =0;
AttrDescriptor *a_286same_sense =0;
SdaiEdge_curve::SdaiEdge_curve( ) 
{

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    AppendMultInstance(new SdaiGeometric_representation_item(this)); 

    eDesc = config_control_designe_edge_curve;

    STEPattribute * a = new STEPattribute (*a_285edge_geometry, (STEPentityH *) &_edge_geometry);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_286same_sense,  &_same_sense);
    a -> set_null ();
    attributes.push (a);
}
SdaiEdge_curve::SdaiEdge_curve (SdaiEdge_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEdge_curve::~SdaiEdge_curve () {  }
SdaiEdge_curve::SdaiEdge_curve (STEPentity *se ) : SdaiEdge(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiEdge  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    se->AppendMultInstance(new SdaiGeometric_representation_item(se)); 

    eDesc = config_control_designe_edge_curve;

    STEPattribute * a = new STEPattribute (*a_285edge_geometry, (STEPentityH *) &_edge_geometry);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_286same_sense,  &_same_sense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiEdge_curve::Edge_geometry() const 
	{ return (SdaiCurveH) _edge_geometry; }

void 
SdaiEdge_curve::Edge_geometry (SdaiCurveH x)
	{ _edge_geometry = x; }

const BOOLEAN 
SdaiEdge_curve::Same_sense() const 
	{ return (LOGICAL) _same_sense; }

void 
SdaiEdge_curve::Same_sense (BOOLEAN x)
	{ _same_sense.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY edge_curve 


/////////	 ENTITY point_replica 

EntityDescriptor *config_control_designe_point_replica =0;
AttrDescriptor *a_287parent_pt =0;
AttrDescriptor *a_288transformation =0;
SdaiPoint_replica::SdaiPoint_replica( ) 
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_replica;

    STEPattribute * a = new STEPattribute (*a_287parent_pt, (STEPentityH *) &_parent_pt);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_288transformation, (STEPentityH *) &_transformation);
    a -> set_null ();
    attributes.push (a);
}
SdaiPoint_replica::SdaiPoint_replica (SdaiPoint_replica& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPoint_replica::~SdaiPoint_replica () {  }
SdaiPoint_replica::SdaiPoint_replica (STEPentity *se ) : SdaiPoint(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_point_replica;

    STEPattribute * a = new STEPattribute (*a_287parent_pt, (STEPentityH *) &_parent_pt);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_288transformation, (STEPentityH *) &_transformation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiPointH 
SdaiPoint_replica::Parent_pt() const 
	{ return (SdaiPointH) _parent_pt; }

void 
SdaiPoint_replica::Parent_pt (SdaiPointH x)
	{ _parent_pt = x; }

SdaiCartesian_transformation_operatorH 
SdaiPoint_replica::Transformation() const 
	{ return (SdaiCartesian_transformation_operatorH) _transformation; }

void 
SdaiPoint_replica::Transformation (SdaiCartesian_transformation_operatorH x)
	{ _transformation = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY point_replica 


/////////	 ENTITY product 

EntityDescriptor *config_control_designe_product =0;
AttrDescriptor *a_289id =0;
AttrDescriptor *a_290name =0;
AttrDescriptor *a_291description =0;
AttrDescriptor *a_292frame_of_reference =0;
SdaiProduct::SdaiProduct( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product;

    STEPattribute * a = new STEPattribute (*a_289id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_290name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_291description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_292frame_of_reference,  &_frame_of_reference);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct::SdaiProduct (SdaiProduct& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct::~SdaiProduct () {  }
SdaiProduct::SdaiProduct( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_product;

    STEPattribute * a = new STEPattribute (*a_289id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_290name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_291description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_292frame_of_reference,  &_frame_of_reference);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiProduct::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiProduct::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiProduct::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiProduct::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiProduct::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProduct::Description (const char * x)
	{ _description = x; }

const EntityAggregateH 
SdaiProduct::Frame_of_reference() const 
	{ return (EntityAggregateH) &_frame_of_reference; }

void 
SdaiProduct::Frame_of_reference (EntityAggregateH x)
	{ _frame_of_reference.ShallowCopy (*x); }

/////////	 END_ENTITY product 


/////////	 ENTITY shape_aspect_relationship 

EntityDescriptor *config_control_designe_shape_aspect_relationship =0;
AttrDescriptor *a_293name =0;
AttrDescriptor *a_294description =0;
AttrDescriptor *a_295relating_shape_aspect =0;
AttrDescriptor *a_296related_shape_aspect =0;
SdaiShape_aspect_relationship::SdaiShape_aspect_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect_relationship;

    STEPattribute * a = new STEPattribute (*a_293name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_294description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_295relating_shape_aspect, (STEPentityH *) &_relating_shape_aspect);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_296related_shape_aspect, (STEPentityH *) &_related_shape_aspect);
    a -> set_null ();
    attributes.push (a);
}
SdaiShape_aspect_relationship::SdaiShape_aspect_relationship (SdaiShape_aspect_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShape_aspect_relationship::~SdaiShape_aspect_relationship () {  }
SdaiShape_aspect_relationship::SdaiShape_aspect_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect_relationship;

    STEPattribute * a = new STEPattribute (*a_293name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_294description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_295relating_shape_aspect, (STEPentityH *) &_relating_shape_aspect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_296related_shape_aspect, (STEPentityH *) &_related_shape_aspect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiShape_aspect_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiShape_aspect_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiShape_aspect_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiShape_aspect_relationship::Description (const char * x)
	{ _description = x; }

SdaiShape_aspectH 
SdaiShape_aspect_relationship::Relating_shape_aspect() const 
	{ return (SdaiShape_aspectH) _relating_shape_aspect; }

void 
SdaiShape_aspect_relationship::Relating_shape_aspect (SdaiShape_aspectH x)
	{ _relating_shape_aspect = x; }

SdaiShape_aspectH 
SdaiShape_aspect_relationship::Related_shape_aspect() const 
	{ return (SdaiShape_aspectH) _related_shape_aspect; }

void 
SdaiShape_aspect_relationship::Related_shape_aspect (SdaiShape_aspectH x)
	{ _related_shape_aspect = x; }

/////////	 END_ENTITY shape_aspect_relationship 


/////////	 ENTITY rectangular_trimmed_surface 

EntityDescriptor *config_control_designe_rectangular_trimmed_surface =0;
AttrDescriptor *a_297basis_surface =0;
AttrDescriptor *a_298u1 =0;
AttrDescriptor *a_299u2 =0;
AttrDescriptor *a_300v1 =0;
AttrDescriptor *a_301v2 =0;
AttrDescriptor *a_302usense =0;
AttrDescriptor *a_303vsense =0;
SdaiRectangular_trimmed_surface::SdaiRectangular_trimmed_surface( ) 
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_trimmed_surface;

    STEPattribute * a = new STEPattribute (*a_297basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_298u1,  &_u1);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_299u2,  &_u2);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_300v1,  &_v1);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_301v2,  &_v2);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_302usense,  &_usense);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_303vsense,  &_vsense);
    a -> set_null ();
    attributes.push (a);
}
SdaiRectangular_trimmed_surface::SdaiRectangular_trimmed_surface (SdaiRectangular_trimmed_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRectangular_trimmed_surface::~SdaiRectangular_trimmed_surface () {  }
SdaiRectangular_trimmed_surface::SdaiRectangular_trimmed_surface (STEPentity *se ) : SdaiBounded_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rectangular_trimmed_surface;

    STEPattribute * a = new STEPattribute (*a_297basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_298u1,  &_u1);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_299u2,  &_u2);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_300v1,  &_v1);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_301v2,  &_v2);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_302usense,  &_usense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_303vsense,  &_vsense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiRectangular_trimmed_surface::Basis_surface() const 
	{ return (SdaiSurfaceH) _basis_surface; }

void 
SdaiRectangular_trimmed_surface::Basis_surface (SdaiSurfaceH x)
	{ _basis_surface = x; }

const SdaiParameter_value 
SdaiRectangular_trimmed_surface::U1() const 
	{ return (const SdaiParameter_value) _u1; }

void 
SdaiRectangular_trimmed_surface::U1 (SdaiParameter_value x)
	{ _u1 = x; }

const SdaiParameter_value 
SdaiRectangular_trimmed_surface::U2() const 
	{ return (const SdaiParameter_value) _u2; }

void 
SdaiRectangular_trimmed_surface::U2 (SdaiParameter_value x)
	{ _u2 = x; }

const SdaiParameter_value 
SdaiRectangular_trimmed_surface::V1() const 
	{ return (const SdaiParameter_value) _v1; }

void 
SdaiRectangular_trimmed_surface::V1 (SdaiParameter_value x)
	{ _v1 = x; }

const SdaiParameter_value 
SdaiRectangular_trimmed_surface::V2() const 
	{ return (const SdaiParameter_value) _v2; }

void 
SdaiRectangular_trimmed_surface::V2 (SdaiParameter_value x)
	{ _v2 = x; }

const BOOLEAN 
SdaiRectangular_trimmed_surface::Usense() const 
	{ return (LOGICAL) _usense; }

void 
SdaiRectangular_trimmed_surface::Usense (BOOLEAN x)
	{ _usense.put (x); }

const BOOLEAN 
SdaiRectangular_trimmed_surface::Vsense() const 
	{ return (LOGICAL) _vsense; }

void 
SdaiRectangular_trimmed_surface::Vsense (BOOLEAN x)
	{ _vsense.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rectangular_trimmed_surface 


/////////	 ENTITY plane 

EntityDescriptor *config_control_designe_plane =0;
SdaiPlane::SdaiPlane( ) 
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane;
}
SdaiPlane::SdaiPlane (SdaiPlane& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPlane::~SdaiPlane () {  }
SdaiPlane::SdaiPlane (STEPentity *se ) : SdaiElementary_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_plane;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY plane 


/////////	 ENTITY action_assignment 

EntityDescriptor *config_control_designe_action_assignment =0;
AttrDescriptor *a_304assigned_action =0;
SdaiAction_assignment::SdaiAction_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action_assignment;

    STEPattribute * a = new STEPattribute (*a_304assigned_action, (STEPentityH *) &_assigned_action);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction_assignment::SdaiAction_assignment (SdaiAction_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction_assignment::~SdaiAction_assignment () {  }
SdaiAction_assignment::SdaiAction_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action_assignment;

    STEPattribute * a = new STEPattribute (*a_304assigned_action, (STEPentityH *) &_assigned_action);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiActionH 
SdaiAction_assignment::Assigned_action() const 
	{ return (SdaiActionH) _assigned_action; }

void 
SdaiAction_assignment::Assigned_action (SdaiActionH x)
	{ _assigned_action = x; }

/////////	 END_ENTITY action_assignment 


/////////	 ENTITY change 

EntityDescriptor *config_control_designe_change =0;
AttrDescriptor *a_305items =0;
SdaiChange::SdaiChange( ) 
{

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change;

    STEPattribute * a = new STEPattribute (*a_305items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiChange::SdaiChange (SdaiChange& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiChange::~SdaiChange () {  }
SdaiChange::SdaiChange (STEPentity *se ) : SdaiAction_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_change;

    STEPattribute * a = new STEPattribute (*a_305items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiWork_itemsH 
SdaiChange::Items() const 
	{ return (SdaiWork_itemsH) &_items; }

void 
SdaiChange::Items (SdaiWork_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY change 


/////////	 ENTITY circle 

EntityDescriptor *config_control_designe_circle =0;
AttrDescriptor *a_306radius =0;
SdaiCircle::SdaiCircle( ) 
{

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_circle;

    STEPattribute * a = new STEPattribute (*a_306radius,  &_radius);
    a -> set_null ();
    attributes.push (a);
}
SdaiCircle::SdaiCircle (SdaiCircle& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCircle::~SdaiCircle () {  }
SdaiCircle::SdaiCircle (STEPentity *se ) : SdaiConic(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiConic  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_circle;

    STEPattribute * a = new STEPattribute (*a_306radius,  &_radius);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPositive_length_measure 
SdaiCircle::Radius() const 
	{ return (const SdaiPositive_length_measure) _radius; }

void 
SdaiCircle::Radius (SdaiPositive_length_measure x)
	{ _radius = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY circle 


/////////	 ENTITY line 

EntityDescriptor *config_control_designe_line =0;
AttrDescriptor *a_307pnt =0;
AttrDescriptor *a_308dir =0;
SdaiLine::SdaiLine( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_line;

    STEPattribute * a = new STEPattribute (*a_307pnt, (STEPentityH *) &_pnt);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_308dir, (STEPentityH *) &_dir);
    a -> set_null ();
    attributes.push (a);
}
SdaiLine::SdaiLine (SdaiLine& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiLine::~SdaiLine () {  }
SdaiLine::SdaiLine (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_line;

    STEPattribute * a = new STEPattribute (*a_307pnt, (STEPentityH *) &_pnt);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_308dir, (STEPentityH *) &_dir);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCartesian_pointH 
SdaiLine::Pnt() const 
	{ return (SdaiCartesian_pointH) _pnt; }

void 
SdaiLine::Pnt (SdaiCartesian_pointH x)
	{ _pnt = x; }

SdaiVectorH 
SdaiLine::Dir() const 
	{ return (SdaiVectorH) _dir; }

void 
SdaiLine::Dir (SdaiVectorH x)
	{ _dir = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY line 


/////////	 ENTITY property_definition_representation 

EntityDescriptor *config_control_designe_property_definition_representation =0;
AttrDescriptor *a_309definition =0;
AttrDescriptor *a_310used_representation =0;
SdaiProperty_definition_representation::SdaiProperty_definition_representation( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition_representation;

    STEPattribute * a = new STEPattribute (*a_309definition, (STEPentityH *) &_definition);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_310used_representation, (STEPentityH *) &_used_representation);
    a -> set_null ();
    attributes.push (a);
}
SdaiProperty_definition_representation::SdaiProperty_definition_representation (SdaiProperty_definition_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProperty_definition_representation::~SdaiProperty_definition_representation () {  }
SdaiProperty_definition_representation::SdaiProperty_definition_representation( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_property_definition_representation;

    STEPattribute * a = new STEPattribute (*a_309definition, (STEPentityH *) &_definition);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_310used_representation, (STEPentityH *) &_used_representation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiProperty_definitionH 
SdaiProperty_definition_representation::Definition() const 
	{ return (SdaiProperty_definitionH) _definition; }

void 
SdaiProperty_definition_representation::Definition (SdaiProperty_definitionH x)
	{ _definition = x; }

SdaiRepresentationH 
SdaiProperty_definition_representation::Used_representation() const 
	{ return (SdaiRepresentationH) _used_representation; }

void 
SdaiProperty_definition_representation::Used_representation (SdaiRepresentationH x)
	{ _used_representation = x; }

/////////	 END_ENTITY property_definition_representation 


/////////	 ENTITY geometric_set 

EntityDescriptor *config_control_designe_geometric_set =0;
AttrDescriptor *a_311elements =0;
SdaiGeometric_set::SdaiGeometric_set( ) 
{

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_set;

    STEPattribute * a = new STEPattribute (*a_311elements,  &_elements);
    a -> set_null ();
    attributes.push (a);
}
SdaiGeometric_set::SdaiGeometric_set (SdaiGeometric_set& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGeometric_set::~SdaiGeometric_set () {  }
SdaiGeometric_set::SdaiGeometric_set (STEPentity *se ) : SdaiGeometric_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_set;

    STEPattribute * a = new STEPattribute (*a_311elements,  &_elements);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiGeometric_set_selectsH 
SdaiGeometric_set::Elements() const 
	{ return (SdaiGeometric_set_selectsH) &_elements; }

void 
SdaiGeometric_set::Elements (SdaiGeometric_set_selectsH x)
	{ _elements.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_set 


/////////	 ENTITY geometric_curve_set 

EntityDescriptor *config_control_designe_geometric_curve_set =0;
SdaiGeometric_curve_set::SdaiGeometric_curve_set( ) 
{

	/*  parent: SdaiGeometric_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_curve_set;
}
SdaiGeometric_curve_set::SdaiGeometric_curve_set (SdaiGeometric_curve_set& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGeometric_curve_set::~SdaiGeometric_curve_set () {  }
SdaiGeometric_curve_set::SdaiGeometric_curve_set (STEPentity *se ) : SdaiGeometric_set(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiGeometric_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometric_curve_set;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometric_curve_set 


/////////	 ENTITY personal_address 

EntityDescriptor *config_control_designe_personal_address =0;
AttrDescriptor *a_312people =0;
AttrDescriptor *a_313description =0;
SdaiPersonal_address::SdaiPersonal_address( ) 
{

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_personal_address;

    STEPattribute * a = new STEPattribute (*a_312people,  &_people);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_313description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiPersonal_address::SdaiPersonal_address (SdaiPersonal_address& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPersonal_address::~SdaiPersonal_address () {  }
SdaiPersonal_address::SdaiPersonal_address (STEPentity *se ) : SdaiAddress(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAddress  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_personal_address;

    STEPattribute * a = new STEPattribute (*a_312people,  &_people);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_313description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiPersonal_address::People() const 
	{ return (EntityAggregateH) &_people; }

void 
SdaiPersonal_address::People (EntityAggregateH x)
	{ _people.ShallowCopy (*x); }

const SdaiText 
SdaiPersonal_address::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiPersonal_address::Description (const char * x)
	{ _description = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY personal_address 


/////////	 ENTITY document_relationship 

EntityDescriptor *config_control_designe_document_relationship =0;
AttrDescriptor *a_314name =0;
AttrDescriptor *a_315description =0;
AttrDescriptor *a_316relating_document =0;
AttrDescriptor *a_317related_document =0;
SdaiDocument_relationship::SdaiDocument_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_relationship;

    STEPattribute * a = new STEPattribute (*a_314name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_315description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_316relating_document, (STEPentityH *) &_relating_document);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_317related_document, (STEPentityH *) &_related_document);
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_relationship::SdaiDocument_relationship (SdaiDocument_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDocument_relationship::~SdaiDocument_relationship () {  }
SdaiDocument_relationship::SdaiDocument_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_document_relationship;

    STEPattribute * a = new STEPattribute (*a_314name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_315description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_316relating_document, (STEPentityH *) &_relating_document);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_317related_document, (STEPentityH *) &_related_document);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiDocument_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiDocument_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiDocument_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiDocument_relationship::Description (const char * x)
	{ _description = x; }

SdaiDocumentH 
SdaiDocument_relationship::Relating_document() const 
	{ return (SdaiDocumentH) _relating_document; }

void 
SdaiDocument_relationship::Relating_document (SdaiDocumentH x)
	{ _relating_document = x; }

SdaiDocumentH 
SdaiDocument_relationship::Related_document() const 
	{ return (SdaiDocumentH) _related_document; }

void 
SdaiDocument_relationship::Related_document (SdaiDocumentH x)
	{ _related_document = x; }

/////////	 END_ENTITY document_relationship 


/////////	 ENTITY pcurve 

EntityDescriptor *config_control_designe_pcurve =0;
AttrDescriptor *a_318basis_surface =0;
AttrDescriptor *a_319reference_to_curve =0;
SdaiPcurve::SdaiPcurve( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_pcurve;

    STEPattribute * a = new STEPattribute (*a_318basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_319reference_to_curve, (STEPentityH *) &_reference_to_curve);
    a -> set_null ();
    attributes.push (a);
}
SdaiPcurve::SdaiPcurve (SdaiPcurve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPcurve::~SdaiPcurve () {  }
SdaiPcurve::SdaiPcurve (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_pcurve;

    STEPattribute * a = new STEPattribute (*a_318basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_319reference_to_curve, (STEPentityH *) &_reference_to_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiPcurve::Basis_surface() const 
	{ return (SdaiSurfaceH) _basis_surface; }

void 
SdaiPcurve::Basis_surface (SdaiSurfaceH x)
	{ _basis_surface = x; }

SdaiDefinitional_representationH 
SdaiPcurve::Reference_to_curve() const 
	{ return (SdaiDefinitional_representationH) _reference_to_curve; }

void 
SdaiPcurve::Reference_to_curve (SdaiDefinitional_representationH x)
	{ _reference_to_curve = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY pcurve 


/////////	 ENTITY outer_boundary_curve 

EntityDescriptor *config_control_designe_outer_boundary_curve =0;
SdaiOuter_boundary_curve::SdaiOuter_boundary_curve( ) 
{

	/*  parent: SdaiBoundary_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_outer_boundary_curve;
}
SdaiOuter_boundary_curve::SdaiOuter_boundary_curve (SdaiOuter_boundary_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOuter_boundary_curve::~SdaiOuter_boundary_curve () {  }
SdaiOuter_boundary_curve::SdaiOuter_boundary_curve (STEPentity *se ) : SdaiBoundary_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBoundary_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_outer_boundary_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY outer_boundary_curve 


/////////	 ENTITY shape_representation_relationship 

EntityDescriptor *config_control_designe_shape_representation_relationship =0;
SdaiShape_representation_relationship::SdaiShape_representation_relationship( ) 
{

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation_relationship;
}
SdaiShape_representation_relationship::SdaiShape_representation_relationship (SdaiShape_representation_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShape_representation_relationship::~SdaiShape_representation_relationship () {  }
SdaiShape_representation_relationship::SdaiShape_representation_relationship (STEPentity *se ) : SdaiRepresentation_relationship(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_representation_relationship;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shape_representation_relationship 


/////////	 ENTITY assembly_component_usage_substitute 

EntityDescriptor *config_control_designe_assembly_component_usage_substitute =0;
AttrDescriptor *a_320name =0;
AttrDescriptor *a_321description =0;
AttrDescriptor *a_322base =0;
AttrDescriptor *a_323substitute =0;
SdaiAssembly_component_usage_substitute::SdaiAssembly_component_usage_substitute( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_assembly_component_usage_substitute;

    STEPattribute * a = new STEPattribute (*a_320name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_321description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_322base, (STEPentityH *) &_base);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_323substitute, (STEPentityH *) &_substitute);
    a -> set_null ();
    attributes.push (a);
}
SdaiAssembly_component_usage_substitute::SdaiAssembly_component_usage_substitute (SdaiAssembly_component_usage_substitute& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAssembly_component_usage_substitute::~SdaiAssembly_component_usage_substitute () {  }
SdaiAssembly_component_usage_substitute::SdaiAssembly_component_usage_substitute( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_assembly_component_usage_substitute;

    STEPattribute * a = new STEPattribute (*a_320name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_321description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_322base, (STEPentityH *) &_base);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_323substitute, (STEPentityH *) &_substitute);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAssembly_component_usage_substitute::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiAssembly_component_usage_substitute::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiAssembly_component_usage_substitute::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiAssembly_component_usage_substitute::Description (const char * x)
	{ _description = x; }

SdaiAssembly_component_usageH 
SdaiAssembly_component_usage_substitute::Base() const 
	{ return (SdaiAssembly_component_usageH) _base; }

void 
SdaiAssembly_component_usage_substitute::Base (SdaiAssembly_component_usageH x)
	{ _base = x; }

SdaiAssembly_component_usageH 
SdaiAssembly_component_usage_substitute::Substitute() const 
	{ return (SdaiAssembly_component_usageH) _substitute; }

void 
SdaiAssembly_component_usage_substitute::Substitute (SdaiAssembly_component_usageH x)
	{ _substitute = x; }

/////////	 END_ENTITY assembly_component_usage_substitute 


/////////	 ENTITY degenerate_pcurve 

EntityDescriptor *config_control_designe_degenerate_pcurve =0;
AttrDescriptor *a_324basis_surface =0;
AttrDescriptor *a_325reference_to_curve =0;
SdaiDegenerate_pcurve::SdaiDegenerate_pcurve( ) 
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_degenerate_pcurve;

    STEPattribute * a = new STEPattribute (*a_324basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_325reference_to_curve, (STEPentityH *) &_reference_to_curve);
    a -> set_null ();
    attributes.push (a);
}
SdaiDegenerate_pcurve::SdaiDegenerate_pcurve (SdaiDegenerate_pcurve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDegenerate_pcurve::~SdaiDegenerate_pcurve () {  }
SdaiDegenerate_pcurve::SdaiDegenerate_pcurve (STEPentity *se ) : SdaiPoint(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_degenerate_pcurve;

    STEPattribute * a = new STEPattribute (*a_324basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_325reference_to_curve, (STEPentityH *) &_reference_to_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiDegenerate_pcurve::Basis_surface() const 
	{ return (SdaiSurfaceH) _basis_surface; }

void 
SdaiDegenerate_pcurve::Basis_surface (SdaiSurfaceH x)
	{ _basis_surface = x; }

SdaiDefinitional_representationH 
SdaiDegenerate_pcurve::Reference_to_curve() const 
	{ return (SdaiDefinitional_representationH) _reference_to_curve; }

void 
SdaiDegenerate_pcurve::Reference_to_curve (SdaiDefinitional_representationH x)
	{ _reference_to_curve = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY degenerate_pcurve 


/////////	 ENTITY evaluated_degenerate_pcurve 

EntityDescriptor *config_control_designe_evaluated_degenerate_pcurve =0;
AttrDescriptor *a_326equivalent_point =0;
SdaiEvaluated_degenerate_pcurve::SdaiEvaluated_degenerate_pcurve( ) 
{

	/*  parent: SdaiDegenerate_pcurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_evaluated_degenerate_pcurve;

    STEPattribute * a = new STEPattribute (*a_326equivalent_point, (STEPentityH *) &_equivalent_point);
    a -> set_null ();
    attributes.push (a);
}
SdaiEvaluated_degenerate_pcurve::SdaiEvaluated_degenerate_pcurve (SdaiEvaluated_degenerate_pcurve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEvaluated_degenerate_pcurve::~SdaiEvaluated_degenerate_pcurve () {  }
SdaiEvaluated_degenerate_pcurve::SdaiEvaluated_degenerate_pcurve (STEPentity *se ) : SdaiDegenerate_pcurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiDegenerate_pcurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_evaluated_degenerate_pcurve;

    STEPattribute * a = new STEPattribute (*a_326equivalent_point, (STEPentityH *) &_equivalent_point);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCartesian_pointH 
SdaiEvaluated_degenerate_pcurve::Equivalent_point() const 
	{ return (SdaiCartesian_pointH) _equivalent_point; }

void 
SdaiEvaluated_degenerate_pcurve::Equivalent_point (SdaiCartesian_pointH x)
	{ _equivalent_point = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY evaluated_degenerate_pcurve 


/////////	 ENTITY solid_angle_measure_with_unit 

EntityDescriptor *config_control_designe_solid_angle_measure_with_unit =0;
SdaiSolid_angle_measure_with_unit::SdaiSolid_angle_measure_with_unit( ) 
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_measure_with_unit;
}
SdaiSolid_angle_measure_with_unit::SdaiSolid_angle_measure_with_unit (SdaiSolid_angle_measure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSolid_angle_measure_with_unit::~SdaiSolid_angle_measure_with_unit () {  }
SdaiSolid_angle_measure_with_unit::SdaiSolid_angle_measure_with_unit (STEPentity *se ) : SdaiMeasure_with_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_solid_angle_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY solid_angle_measure_with_unit 


/////////	 ENTITY connected_edge_set 

EntityDescriptor *config_control_designe_connected_edge_set =0;
AttrDescriptor *a_327ces_edges =0;
SdaiConnected_edge_set::SdaiConnected_edge_set( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_edge_set;

    STEPattribute * a = new STEPattribute (*a_327ces_edges,  &_ces_edges);
    a -> set_null ();
    attributes.push (a);
}
SdaiConnected_edge_set::SdaiConnected_edge_set (SdaiConnected_edge_set& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConnected_edge_set::~SdaiConnected_edge_set () {  }
SdaiConnected_edge_set::SdaiConnected_edge_set (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_connected_edge_set;

    STEPattribute * a = new STEPattribute (*a_327ces_edges,  &_ces_edges);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiConnected_edge_set::Ces_edges() const 
	{ return (EntityAggregateH) &_ces_edges; }

void 
SdaiConnected_edge_set::Ces_edges (EntityAggregateH x)
	{ _ces_edges.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY connected_edge_set 


/////////	 ENTITY action 

EntityDescriptor *config_control_designe_action =0;
AttrDescriptor *a_328name =0;
AttrDescriptor *a_329description =0;
AttrDescriptor *a_330chosen_method =0;
SdaiAction::SdaiAction( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_action;

    STEPattribute * a = new STEPattribute (*a_328name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_329description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_330chosen_method, (STEPentityH *) &_chosen_method);
    a -> set_null ();
    attributes.push (a);
}
SdaiAction::SdaiAction (SdaiAction& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAction::~SdaiAction () {  }
SdaiAction::SdaiAction( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_action;

    STEPattribute * a = new STEPattribute (*a_328name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_329description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_330chosen_method, (STEPentityH *) &_chosen_method);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiAction::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiAction::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiAction::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiAction::Description (const char * x)
	{ _description = x; }

SdaiAction_methodH 
SdaiAction::Chosen_method() const 
	{ return (SdaiAction_methodH) _chosen_method; }

void 
SdaiAction::Chosen_method (SdaiAction_methodH x)
	{ _chosen_method = x; }

/////////	 END_ENTITY action 


/////////	 ENTITY executed_action 

EntityDescriptor *config_control_designe_executed_action =0;
SdaiExecuted_action::SdaiExecuted_action( ) 
{

	/*  parent: SdaiAction  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_executed_action;
}
SdaiExecuted_action::SdaiExecuted_action (SdaiExecuted_action& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiExecuted_action::~SdaiExecuted_action () {  }
SdaiExecuted_action::SdaiExecuted_action (STEPentity *se ) : SdaiAction(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAction  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_executed_action;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY executed_action 


/////////	 ENTITY directed_action 

EntityDescriptor *config_control_designe_directed_action =0;
AttrDescriptor *a_331directive =0;
SdaiDirected_action::SdaiDirected_action( ) 
{

	/*  parent: SdaiExecuted_action  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_directed_action;

    STEPattribute * a = new STEPattribute (*a_331directive, (STEPentityH *) &_directive);
    a -> set_null ();
    attributes.push (a);
}
SdaiDirected_action::SdaiDirected_action (SdaiDirected_action& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDirected_action::~SdaiDirected_action () {  }
SdaiDirected_action::SdaiDirected_action (STEPentity *se ) : SdaiExecuted_action(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiExecuted_action  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_directed_action;

    STEPattribute * a = new STEPattribute (*a_331directive, (STEPentityH *) &_directive);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiAction_directiveH 
SdaiDirected_action::Directive() const 
	{ return (SdaiAction_directiveH) _directive; }

void 
SdaiDirected_action::Directive (SdaiAction_directiveH x)
	{ _directive = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY directed_action 


/////////	 ENTITY organizational_project 

EntityDescriptor *config_control_designe_organizational_project =0;
AttrDescriptor *a_332name =0;
AttrDescriptor *a_333description =0;
AttrDescriptor *a_334responsible_organizations =0;
SdaiOrganizational_project::SdaiOrganizational_project( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_organizational_project;

    STEPattribute * a = new STEPattribute (*a_332name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_333description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_334responsible_organizations,  &_responsible_organizations);
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganizational_project::SdaiOrganizational_project (SdaiOrganizational_project& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOrganizational_project::~SdaiOrganizational_project () {  }
SdaiOrganizational_project::SdaiOrganizational_project( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_organizational_project;

    STEPattribute * a = new STEPattribute (*a_332name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_333description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_334responsible_organizations,  &_responsible_organizations);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiOrganizational_project::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiOrganizational_project::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiOrganizational_project::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiOrganizational_project::Description (const char * x)
	{ _description = x; }

const EntityAggregateH 
SdaiOrganizational_project::Responsible_organizations() const 
	{ return (EntityAggregateH) &_responsible_organizations; }

void 
SdaiOrganizational_project::Responsible_organizations (EntityAggregateH x)
	{ _responsible_organizations.ShallowCopy (*x); }

/////////	 END_ENTITY organizational_project 


/////////	 ENTITY date_time_role 

EntityDescriptor *config_control_designe_date_time_role =0;
AttrDescriptor *a_335name =0;
SdaiDate_time_role::SdaiDate_time_role( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date_time_role;

    STEPattribute * a = new STEPattribute (*a_335name,  &_name);
    a -> set_null ();
    attributes.push (a);
}
SdaiDate_time_role::SdaiDate_time_role (SdaiDate_time_role& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDate_time_role::~SdaiDate_time_role () {  }
SdaiDate_time_role::SdaiDate_time_role( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_date_time_role;

    STEPattribute * a = new STEPattribute (*a_335name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiDate_time_role::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiDate_time_role::Name (const char * x)
	{ _name = x; }

/////////	 END_ENTITY date_time_role 


/////////	 ENTITY curve_bounded_surface 

EntityDescriptor *config_control_designe_curve_bounded_surface =0;
AttrDescriptor *a_336basis_surface =0;
AttrDescriptor *a_337boundaries =0;
AttrDescriptor *a_338implicit_outer =0;
SdaiCurve_bounded_surface::SdaiCurve_bounded_surface( ) 
{

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_bounded_surface;

    STEPattribute * a = new STEPattribute (*a_336basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_337boundaries,  &_boundaries);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_338implicit_outer,  &_implicit_outer);
    a -> set_null ();
    attributes.push (a);
}
SdaiCurve_bounded_surface::SdaiCurve_bounded_surface (SdaiCurve_bounded_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCurve_bounded_surface::~SdaiCurve_bounded_surface () {  }
SdaiCurve_bounded_surface::SdaiCurve_bounded_surface (STEPentity *se ) : SdaiBounded_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_curve_bounded_surface;

    STEPattribute * a = new STEPattribute (*a_336basis_surface, (STEPentityH *) &_basis_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_337boundaries,  &_boundaries);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_338implicit_outer,  &_implicit_outer);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiCurve_bounded_surface::Basis_surface() const 
	{ return (SdaiSurfaceH) _basis_surface; }

void 
SdaiCurve_bounded_surface::Basis_surface (SdaiSurfaceH x)
	{ _basis_surface = x; }

const EntityAggregateH 
SdaiCurve_bounded_surface::Boundaries() const 
	{ return (EntityAggregateH) &_boundaries; }

void 
SdaiCurve_bounded_surface::Boundaries (EntityAggregateH x)
	{ _boundaries.ShallowCopy (*x); }

const BOOLEAN 
SdaiCurve_bounded_surface::Implicit_outer() const 
	{ return (LOGICAL) _implicit_outer; }

void 
SdaiCurve_bounded_surface::Implicit_outer (BOOLEAN x)
	{ _implicit_outer.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY curve_bounded_surface 


/////////	 ENTITY closed_shell 

EntityDescriptor *config_control_designe_closed_shell =0;
SdaiClosed_shell::SdaiClosed_shell( ) 
{

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_closed_shell;
}
SdaiClosed_shell::SdaiClosed_shell (SdaiClosed_shell& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiClosed_shell::~SdaiClosed_shell () {  }
SdaiClosed_shell::SdaiClosed_shell (STEPentity *se ) : SdaiConnected_face_set(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiConnected_face_set  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_closed_shell;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY closed_shell 


/////////	 ENTITY design_make_from_relationship 

EntityDescriptor *config_control_designe_design_make_from_relationship =0;
SdaiDesign_make_from_relationship::SdaiDesign_make_from_relationship( ) 
{

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_make_from_relationship;
}
SdaiDesign_make_from_relationship::SdaiDesign_make_from_relationship (SdaiDesign_make_from_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDesign_make_from_relationship::~SdaiDesign_make_from_relationship () {  }
SdaiDesign_make_from_relationship::SdaiDesign_make_from_relationship (STEPentity *se ) : SdaiProduct_definition_relationship(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition_relationship  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_make_from_relationship;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY design_make_from_relationship 


/////////	 ENTITY definitional_representation 

EntityDescriptor *config_control_designe_definitional_representation =0;
SdaiDefinitional_representation::SdaiDefinitional_representation( ) 
{

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_definitional_representation;
}
SdaiDefinitional_representation::SdaiDefinitional_representation (SdaiDefinitional_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDefinitional_representation::~SdaiDefinitional_representation () {  }
SdaiDefinitional_representation::SdaiDefinitional_representation (STEPentity *se ) : SdaiRepresentation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_definitional_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY definitional_representation 


/////////	 ENTITY product_definition_shape 

EntityDescriptor *config_control_designe_product_definition_shape =0;
SdaiProduct_definition_shape::SdaiProduct_definition_shape( ) 
{

	/*  parent: SdaiProperty_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_shape;
}
SdaiProduct_definition_shape::SdaiProduct_definition_shape (SdaiProduct_definition_shape& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_shape::~SdaiProduct_definition_shape () {  }
SdaiProduct_definition_shape::SdaiProduct_definition_shape (STEPentity *se ) : SdaiProperty_definition(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProperty_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_shape;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_shape 


/////////	 ENTITY si_unit 

EntityDescriptor *config_control_designe_si_unit =0;
AttrDescriptor *a_339prefix =0;
AttrDescriptor *a_340name =0;
AttrDescriptor *a_341Dnamed_unit_dimensions =0;
SdaiSi_unit::SdaiSi_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_si_unit;

    STEPattribute * a = new STEPattribute (*a_339prefix,  &_prefix);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_340name,  &_name);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("dimensions");
}
SdaiSi_unit::SdaiSi_unit (SdaiSi_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSi_unit::~SdaiSi_unit () {  }
SdaiSi_unit::SdaiSi_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_si_unit;

    STEPattribute * a = new STEPattribute (*a_339prefix,  &_prefix);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_340name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("dimensions");
}

const sdaiSi_prefix  
SdaiSi_unit::Prefix() const 
	{ return (sdaiSi_prefix) _prefix; }

void 
SdaiSi_unit::Prefix (sdaiSi_prefix x)
	{ _prefix.put (x); }

const sdaiSi_unit_name  
SdaiSi_unit::Name() const 
	{ return (sdaiSi_unit_name) _name; }

void 
SdaiSi_unit::Name (sdaiSi_unit_name x)
	{ _name.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY si_unit 


/////////	 ENTITY bezier_surface 

EntityDescriptor *config_control_designe_bezier_surface =0;
SdaiBezier_surface::SdaiBezier_surface( ) 
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_surface;
}
SdaiBezier_surface::SdaiBezier_surface (SdaiBezier_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiBezier_surface::~SdaiBezier_surface () {  }
SdaiBezier_surface::SdaiBezier_surface (STEPentity *se ) : SdaiB_spline_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_bezier_surface;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY bezier_surface 


/////////	 ENTITY certification_assignment 

EntityDescriptor *config_control_designe_certification_assignment =0;
AttrDescriptor *a_342assigned_certification =0;
SdaiCertification_assignment::SdaiCertification_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_assignment;

    STEPattribute * a = new STEPattribute (*a_342assigned_certification, (STEPentityH *) &_assigned_certification);
    a -> set_null ();
    attributes.push (a);
}
SdaiCertification_assignment::SdaiCertification_assignment (SdaiCertification_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCertification_assignment::~SdaiCertification_assignment () {  }
SdaiCertification_assignment::SdaiCertification_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_assignment;

    STEPattribute * a = new STEPattribute (*a_342assigned_certification, (STEPentityH *) &_assigned_certification);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCertificationH 
SdaiCertification_assignment::Assigned_certification() const 
	{ return (SdaiCertificationH) _assigned_certification; }

void 
SdaiCertification_assignment::Assigned_certification (SdaiCertificationH x)
	{ _assigned_certification = x; }

/////////	 END_ENTITY certification_assignment 


/////////	 ENTITY start_work 

EntityDescriptor *config_control_designe_start_work =0;
AttrDescriptor *a_343items =0;
SdaiStart_work::SdaiStart_work( ) 
{

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_work;

    STEPattribute * a = new STEPattribute (*a_343items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiStart_work::SdaiStart_work (SdaiStart_work& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiStart_work::~SdaiStart_work () {  }
SdaiStart_work::SdaiStart_work (STEPentity *se ) : SdaiAction_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiAction_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_start_work;

    STEPattribute * a = new STEPattribute (*a_343items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiWork_itemsH 
SdaiStart_work::Items() const 
	{ return (SdaiWork_itemsH) &_items; }

void 
SdaiStart_work::Items (SdaiWork_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY start_work 


/////////	 ENTITY contract_type 

EntityDescriptor *config_control_designe_contract_type =0;
AttrDescriptor *a_344description =0;
SdaiContract_type::SdaiContract_type( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_type;

    STEPattribute * a = new STEPattribute (*a_344description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiContract_type::SdaiContract_type (SdaiContract_type& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiContract_type::~SdaiContract_type () {  }
SdaiContract_type::SdaiContract_type( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_contract_type;

    STEPattribute * a = new STEPattribute (*a_344description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiContract_type::Description() const
	{ return (const SdaiLabel) _description; }

void 
SdaiContract_type::Description (const char * x)
	{ _description = x; }

/////////	 END_ENTITY contract_type 


/////////	 ENTITY b_spline_curve_with_knots 

EntityDescriptor *config_control_designe_b_spline_curve_with_knots =0;
AttrDescriptor *a_345knot_multiplicities =0;
AttrDescriptor *a_346knots =0;
AttrDescriptor *a_347knot_spec =0;
AttrDescriptor *a_348Dupper_index_on_knots =0;
SdaiB_spline_curve_with_knots::SdaiB_spline_curve_with_knots( ) 
{

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve_with_knots;

    STEPattribute * a = new STEPattribute (*a_345knot_multiplicities,  &_knot_multiplicities);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_346knots,  &_knots);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_347knot_spec,  &_knot_spec);
    a -> set_null ();
    attributes.push (a);
}
SdaiB_spline_curve_with_knots::SdaiB_spline_curve_with_knots (SdaiB_spline_curve_with_knots& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiB_spline_curve_with_knots::~SdaiB_spline_curve_with_knots () {  }
SdaiB_spline_curve_with_knots::SdaiB_spline_curve_with_knots (STEPentity *se ) : SdaiB_spline_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_curve_with_knots;

    STEPattribute * a = new STEPattribute (*a_345knot_multiplicities,  &_knot_multiplicities);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_346knots,  &_knots);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_347knot_spec,  &_knot_spec);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const IntAggregateH 
SdaiB_spline_curve_with_knots::Knot_multiplicities() const 
	{ return (IntAggregateH) &_knot_multiplicities; }

void 
SdaiB_spline_curve_with_knots::Knot_multiplicities (IntAggregateH x)
	{ _knot_multiplicities.ShallowCopy (*x); }

const RealAggregateH 
SdaiB_spline_curve_with_knots::Knots() const 
	{ return (RealAggregateH) &_knots; }

void 
SdaiB_spline_curve_with_knots::Knots (RealAggregateH x)
	{ _knots.ShallowCopy (*x); }

const sdaiKnot_type  
SdaiB_spline_curve_with_knots::Knot_spec() const 
	{ return (sdaiKnot_type) _knot_spec; }

void 
SdaiB_spline_curve_with_knots::Knot_spec (sdaiKnot_type x)
	{ _knot_spec.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_curve_with_knots 


/////////	 ENTITY cc_design_approval 

EntityDescriptor *config_control_designe_cc_design_approval =0;
AttrDescriptor *a_349items =0;
SdaiCc_design_approval::SdaiCc_design_approval( ) 
{

	/*  parent: SdaiApproval_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_approval;

    STEPattribute * a = new STEPattribute (*a_349items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_approval::SdaiCc_design_approval (SdaiCc_design_approval& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCc_design_approval::~SdaiCc_design_approval () {  }
SdaiCc_design_approval::SdaiCc_design_approval (STEPentity *se ) : SdaiApproval_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiApproval_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_approval;

    STEPattribute * a = new STEPattribute (*a_349items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiApproved_itemsH 
SdaiCc_design_approval::Items() const 
	{ return (SdaiApproved_itemsH) &_items; }

void 
SdaiCc_design_approval::Items (SdaiApproved_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_approval 


/////////	 ENTITY edge_based_wireframe_shape_representation 

EntityDescriptor *config_control_designe_edge_based_wireframe_shape_representation =0;
SdaiEdge_based_wireframe_shape_representation::SdaiEdge_based_wireframe_shape_representation( ) 
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_shape_representation;
}
SdaiEdge_based_wireframe_shape_representation::SdaiEdge_based_wireframe_shape_representation (SdaiEdge_based_wireframe_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiEdge_based_wireframe_shape_representation::~SdaiEdge_based_wireframe_shape_representation () {  }
SdaiEdge_based_wireframe_shape_representation::SdaiEdge_based_wireframe_shape_representation (STEPentity *se ) : SdaiShape_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_edge_based_wireframe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY edge_based_wireframe_shape_representation 


/////////	 ENTITY geometrically_bounded_wireframe_shape_representation 

EntityDescriptor *config_control_designe_geometrically_bounded_wireframe_shape_representation =0;
SdaiGeometrically_bounded_wireframe_shape_representation::SdaiGeometrically_bounded_wireframe_shape_representation( ) 
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_wireframe_shape_representation;
}
SdaiGeometrically_bounded_wireframe_shape_representation::SdaiGeometrically_bounded_wireframe_shape_representation (SdaiGeometrically_bounded_wireframe_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGeometrically_bounded_wireframe_shape_representation::~SdaiGeometrically_bounded_wireframe_shape_representation () {  }
SdaiGeometrically_bounded_wireframe_shape_representation::SdaiGeometrically_bounded_wireframe_shape_representation (STEPentity *se ) : SdaiShape_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_geometrically_bounded_wireframe_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY geometrically_bounded_wireframe_shape_representation 


/////////	 ENTITY product_concept 

EntityDescriptor *config_control_designe_product_concept =0;
AttrDescriptor *a_350id =0;
AttrDescriptor *a_351name =0;
AttrDescriptor *a_352description =0;
AttrDescriptor *a_353market_context =0;
SdaiProduct_concept::SdaiProduct_concept( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_concept;

    STEPattribute * a = new STEPattribute (*a_350id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_351name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_352description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_353market_context, (STEPentityH *) &_market_context);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_concept::SdaiProduct_concept (SdaiProduct_concept& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_concept::~SdaiProduct_concept () {  }
SdaiProduct_concept::SdaiProduct_concept( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_product_concept;

    STEPattribute * a = new STEPattribute (*a_350id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_351name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_352description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_353market_context, (STEPentityH *) &_market_context);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiProduct_concept::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiProduct_concept::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiProduct_concept::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiProduct_concept::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiProduct_concept::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProduct_concept::Description (const char * x)
	{ _description = x; }

SdaiProduct_concept_contextH 
SdaiProduct_concept::Market_context() const 
	{ return (SdaiProduct_concept_contextH) _market_context; }

void 
SdaiProduct_concept::Market_context (SdaiProduct_concept_contextH x)
	{ _market_context = x; }

/////////	 END_ENTITY product_concept 


/////////	 ENTITY cc_design_contract 

EntityDescriptor *config_control_designe_cc_design_contract =0;
AttrDescriptor *a_354items =0;
SdaiCc_design_contract::SdaiCc_design_contract( ) 
{

	/*  parent: SdaiContract_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_contract;

    STEPattribute * a = new STEPattribute (*a_354items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_contract::SdaiCc_design_contract (SdaiCc_design_contract& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCc_design_contract::~SdaiCc_design_contract () {  }
SdaiCc_design_contract::SdaiCc_design_contract (STEPentity *se ) : SdaiContract_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiContract_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_contract;

    STEPattribute * a = new STEPattribute (*a_354items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiContracted_itemsH 
SdaiCc_design_contract::Items() const 
	{ return (SdaiContracted_itemsH) &_items; }

void 
SdaiCc_design_contract::Items (SdaiContracted_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_contract 


/////////	 ENTITY seam_curve 

EntityDescriptor *config_control_designe_seam_curve =0;
SdaiSeam_curve::SdaiSeam_curve( ) 
{

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_seam_curve;
}
SdaiSeam_curve::SdaiSeam_curve (SdaiSeam_curve& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSeam_curve::~SdaiSeam_curve () {  }
SdaiSeam_curve::SdaiSeam_curve (STEPentity *se ) : SdaiSurface_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSurface_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_seam_curve;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY seam_curve 


/////////	 ENTITY axis2_placement_3d 

EntityDescriptor *config_control_designe_axis2_placement_3d =0;
AttrDescriptor *a_355axis =0;
AttrDescriptor *a_356ref_direction =0;
AttrDescriptor *a_357Dp =0;
SdaiAxis2_placement_3d::SdaiAxis2_placement_3d( ) 
{

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_3d;

    STEPattribute * a = new STEPattribute (*a_355axis, (STEPentityH *) &_axis);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_356ref_direction, (STEPentityH *) &_ref_direction);
    a -> set_null ();
    attributes.push (a);
}
SdaiAxis2_placement_3d::SdaiAxis2_placement_3d (SdaiAxis2_placement_3d& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAxis2_placement_3d::~SdaiAxis2_placement_3d () {  }
SdaiAxis2_placement_3d::SdaiAxis2_placement_3d (STEPentity *se ) : SdaiPlacement(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPlacement  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_axis2_placement_3d;

    STEPattribute * a = new STEPattribute (*a_355axis, (STEPentityH *) &_axis);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_356ref_direction, (STEPentityH *) &_ref_direction);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDirectionH 
SdaiAxis2_placement_3d::Axis() const 
	{ return (SdaiDirectionH) _axis; }

void 
SdaiAxis2_placement_3d::Axis (SdaiDirectionH x)
	{ _axis = x; }

SdaiDirectionH 
SdaiAxis2_placement_3d::Ref_direction() const 
	{ return (SdaiDirectionH) _ref_direction; }

void 
SdaiAxis2_placement_3d::Ref_direction (SdaiDirectionH x)
	{ _ref_direction = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY axis2_placement_3d 


/////////	 ENTITY rational_b_spline_surface 

EntityDescriptor *config_control_designe_rational_b_spline_surface =0;
AttrDescriptor *a_358weights_data =0;
AttrDescriptor *a_359Dweights =0;
SdaiRational_b_spline_surface::SdaiRational_b_spline_surface( ) 
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_surface;

    STEPattribute * a = new STEPattribute (*a_358weights_data,  &_weights_data);
    a -> set_null ();
    attributes.push (a);
}
SdaiRational_b_spline_surface::SdaiRational_b_spline_surface (SdaiRational_b_spline_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiRational_b_spline_surface::~SdaiRational_b_spline_surface () {  }
SdaiRational_b_spline_surface::SdaiRational_b_spline_surface (STEPentity *se ) : SdaiB_spline_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_rational_b_spline_surface;

    STEPattribute * a = new STEPattribute (*a_358weights_data,  &_weights_data);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const GenericAggregateH 
SdaiRational_b_spline_surface::Weights_data() const 
	{ return (GenericAggregateH) &_weights_data; }

void 
SdaiRational_b_spline_surface::Weights_data (GenericAggregateH x)
	{ _weights_data.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY rational_b_spline_surface 


/////////	 ENTITY configuration_design 

EntityDescriptor *config_control_designe_configuration_design =0;
AttrDescriptor *a_360configuration =0;
AttrDescriptor *a_361design =0;
SdaiConfiguration_design::SdaiConfiguration_design( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_design;

    STEPattribute * a = new STEPattribute (*a_360configuration, (STEPentityH *) &_configuration);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_361design, (STEPentityH *) &_design);
    a -> set_null ();
    attributes.push (a);
}
SdaiConfiguration_design::SdaiConfiguration_design (SdaiConfiguration_design& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConfiguration_design::~SdaiConfiguration_design () {  }
SdaiConfiguration_design::SdaiConfiguration_design( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_configuration_design;

    STEPattribute * a = new STEPattribute (*a_360configuration, (STEPentityH *) &_configuration);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_361design, (STEPentityH *) &_design);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiConfiguration_itemH 
SdaiConfiguration_design::Configuration() const 
	{ return (SdaiConfiguration_itemH) _configuration; }

void 
SdaiConfiguration_design::Configuration (SdaiConfiguration_itemH x)
	{ _configuration = x; }

SdaiProduct_definition_formationH 
SdaiConfiguration_design::Design() const 
	{ return (SdaiProduct_definition_formationH) _design; }

void 
SdaiConfiguration_design::Design (SdaiProduct_definition_formationH x)
	{ _design = x; }

/////////	 END_ENTITY configuration_design 


/////////	 ENTITY design_context 

EntityDescriptor *config_control_designe_design_context =0;
SdaiDesign_context::SdaiDesign_context( ) 
{

	/*  parent: SdaiProduct_definition_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_context;
}
SdaiDesign_context::SdaiDesign_context (SdaiDesign_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDesign_context::~SdaiDesign_context () {  }
SdaiDesign_context::SdaiDesign_context (STEPentity *se ) : SdaiProduct_definition_context(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_design_context;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY design_context 


/////////	 ENTITY product_definition 

EntityDescriptor *config_control_designe_product_definition =0;
AttrDescriptor *a_362id =0;
AttrDescriptor *a_363description =0;
AttrDescriptor *a_364formation =0;
AttrDescriptor *a_365frame_of_reference =0;
SdaiProduct_definition::SdaiProduct_definition( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition;

    STEPattribute * a = new STEPattribute (*a_362id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_363description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_364formation, (STEPentityH *) &_formation);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_365frame_of_reference, (STEPentityH *) &_frame_of_reference);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition::SdaiProduct_definition (SdaiProduct_definition& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition::~SdaiProduct_definition () {  }
SdaiProduct_definition::SdaiProduct_definition( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_product_definition;

    STEPattribute * a = new STEPattribute (*a_362id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_363description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_364formation, (STEPentityH *) &_formation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_365frame_of_reference, (STEPentityH *) &_frame_of_reference);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiProduct_definition::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiProduct_definition::Id (const char * x)
	{ _id = x; }

const SdaiText 
SdaiProduct_definition::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiProduct_definition::Description (const char * x)
	{ _description = x; }

SdaiProduct_definition_formationH 
SdaiProduct_definition::Formation() const 
	{ return (SdaiProduct_definition_formationH) _formation; }

void 
SdaiProduct_definition::Formation (SdaiProduct_definition_formationH x)
	{ _formation = x; }

SdaiProduct_definition_contextH 
SdaiProduct_definition::Frame_of_reference() const 
	{ return (SdaiProduct_definition_contextH) _frame_of_reference; }

void 
SdaiProduct_definition::Frame_of_reference (SdaiProduct_definition_contextH x)
	{ _frame_of_reference = x; }

/////////	 END_ENTITY product_definition 


/////////	 ENTITY product_definition_with_associated_documents 

EntityDescriptor *config_control_designe_product_definition_with_associated_documents =0;
AttrDescriptor *a_366documentation_ids =0;
SdaiProduct_definition_with_associated_documents::SdaiProduct_definition_with_associated_documents( ) 
{

	/*  parent: SdaiProduct_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_with_associated_documents;

    STEPattribute * a = new STEPattribute (*a_366documentation_ids,  &_documentation_ids);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_definition_with_associated_documents::SdaiProduct_definition_with_associated_documents (SdaiProduct_definition_with_associated_documents& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_definition_with_associated_documents::~SdaiProduct_definition_with_associated_documents () {  }
SdaiProduct_definition_with_associated_documents::SdaiProduct_definition_with_associated_documents (STEPentity *se ) : SdaiProduct_definition(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProduct_definition  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_definition_with_associated_documents;

    STEPattribute * a = new STEPattribute (*a_366documentation_ids,  &_documentation_ids);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiProduct_definition_with_associated_documents::Documentation_ids() const 
	{ return (EntityAggregateH) &_documentation_ids; }

void 
SdaiProduct_definition_with_associated_documents::Documentation_ids (EntityAggregateH x)
	{ _documentation_ids.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_definition_with_associated_documents 


/////////	 ENTITY organization 

EntityDescriptor *config_control_designe_organization =0;
AttrDescriptor *a_367id =0;
AttrDescriptor *a_368name =0;
AttrDescriptor *a_369description =0;
SdaiOrganization::SdaiOrganization( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_organization;

    STEPattribute * a = new STEPattribute (*a_367id,  &_id);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_368name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_369description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiOrganization::SdaiOrganization (SdaiOrganization& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOrganization::~SdaiOrganization () {  }
SdaiOrganization::SdaiOrganization( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_organization;

    STEPattribute * a = new STEPattribute (*a_367id,  &_id);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_368name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_369description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiIdentifier 
SdaiOrganization::Id() const
	{ return (const SdaiIdentifier) _id; }

void 
SdaiOrganization::Id (const char * x)
	{ _id = x; }

const SdaiLabel 
SdaiOrganization::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiOrganization::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiOrganization::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiOrganization::Description (const char * x)
	{ _description = x; }

/////////	 END_ENTITY organization 


/////////	 ENTITY cc_design_certification 

EntityDescriptor *config_control_designe_cc_design_certification =0;
AttrDescriptor *a_370items =0;
SdaiCc_design_certification::SdaiCc_design_certification( ) 
{

	/*  parent: SdaiCertification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_certification;

    STEPattribute * a = new STEPattribute (*a_370items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_certification::SdaiCc_design_certification (SdaiCc_design_certification& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCc_design_certification::~SdaiCc_design_certification () {  }
SdaiCc_design_certification::SdaiCc_design_certification (STEPentity *se ) : SdaiCertification_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCertification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_certification;

    STEPattribute * a = new STEPattribute (*a_370items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiCertified_itemsH 
SdaiCc_design_certification::Items() const 
	{ return (SdaiCertified_itemsH) &_items; }

void 
SdaiCc_design_certification::Items (SdaiCertified_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_certification 


/////////	 ENTITY b_spline_surface_with_knots 

EntityDescriptor *config_control_designe_b_spline_surface_with_knots =0;
AttrDescriptor *a_371u_multiplicities =0;
AttrDescriptor *a_372v_multiplicities =0;
AttrDescriptor *a_373u_knots =0;
AttrDescriptor *a_374v_knots =0;
AttrDescriptor *a_375knot_spec =0;
AttrDescriptor *a_376Dknot_u_upper =0;
AttrDescriptor *a_377Dknot_v_upper =0;
SdaiB_spline_surface_with_knots::SdaiB_spline_surface_with_knots( ) 
{

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface_with_knots;

    STEPattribute * a = new STEPattribute (*a_371u_multiplicities,  &_u_multiplicities);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_372v_multiplicities,  &_v_multiplicities);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_373u_knots,  &_u_knots);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_374v_knots,  &_v_knots);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_375knot_spec,  &_knot_spec);
    a -> set_null ();
    attributes.push (a);
}
SdaiB_spline_surface_with_knots::SdaiB_spline_surface_with_knots (SdaiB_spline_surface_with_knots& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiB_spline_surface_with_knots::~SdaiB_spline_surface_with_knots () {  }
SdaiB_spline_surface_with_knots::SdaiB_spline_surface_with_knots (STEPentity *se ) : SdaiB_spline_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiB_spline_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_b_spline_surface_with_knots;

    STEPattribute * a = new STEPattribute (*a_371u_multiplicities,  &_u_multiplicities);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_372v_multiplicities,  &_v_multiplicities);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_373u_knots,  &_u_knots);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_374v_knots,  &_v_knots);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_375knot_spec,  &_knot_spec);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const IntAggregateH 
SdaiB_spline_surface_with_knots::U_multiplicities() const 
	{ return (IntAggregateH) &_u_multiplicities; }

void 
SdaiB_spline_surface_with_knots::U_multiplicities (IntAggregateH x)
	{ _u_multiplicities.ShallowCopy (*x); }

const IntAggregateH 
SdaiB_spline_surface_with_knots::V_multiplicities() const 
	{ return (IntAggregateH) &_v_multiplicities; }

void 
SdaiB_spline_surface_with_knots::V_multiplicities (IntAggregateH x)
	{ _v_multiplicities.ShallowCopy (*x); }

const RealAggregateH 
SdaiB_spline_surface_with_knots::U_knots() const 
	{ return (RealAggregateH) &_u_knots; }

void 
SdaiB_spline_surface_with_knots::U_knots (RealAggregateH x)
	{ _u_knots.ShallowCopy (*x); }

const RealAggregateH 
SdaiB_spline_surface_with_knots::V_knots() const 
	{ return (RealAggregateH) &_v_knots; }

void 
SdaiB_spline_surface_with_knots::V_knots (RealAggregateH x)
	{ _v_knots.ShallowCopy (*x); }

const sdaiKnot_type  
SdaiB_spline_surface_with_knots::Knot_spec() const 
	{ return (sdaiKnot_type) _knot_spec; }

void 
SdaiB_spline_surface_with_knots::Knot_spec (sdaiKnot_type x)
	{ _knot_spec.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY b_spline_surface_with_knots 


/////////	 ENTITY certification_type 

EntityDescriptor *config_control_designe_certification_type =0;
AttrDescriptor *a_378description =0;
SdaiCertification_type::SdaiCertification_type( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_type;

    STEPattribute * a = new STEPattribute (*a_378description,  &_description);
    a -> set_null ();
    attributes.push (a);
}
SdaiCertification_type::SdaiCertification_type (SdaiCertification_type& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCertification_type::~SdaiCertification_type () {  }
SdaiCertification_type::SdaiCertification_type( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_certification_type;

    STEPattribute * a = new STEPattribute (*a_378description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiCertification_type::Description() const
	{ return (const SdaiLabel) _description; }

void 
SdaiCertification_type::Description (const char * x)
	{ _description = x; }

/////////	 END_ENTITY certification_type 


/////////	 ENTITY oriented_path 

EntityDescriptor *config_control_designe_oriented_path =0;
AttrDescriptor *a_379path_element =0;
AttrDescriptor *a_380orientation =0;
AttrDescriptor *a_381Dpath_edge_list =0;
SdaiOriented_path::SdaiOriented_path( ) 
{

	/*  parent: SdaiPath  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_path;

    STEPattribute * a = new STEPattribute (*a_379path_element, (STEPentityH *) &_path_element);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_380orientation,  &_orientation);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("edge_list");
}
SdaiOriented_path::SdaiOriented_path (SdaiOriented_path& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOriented_path::~SdaiOriented_path () {  }
SdaiOriented_path::SdaiOriented_path (STEPentity *se ) : SdaiPath(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPath  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_path;

    STEPattribute * a = new STEPattribute (*a_379path_element, (STEPentityH *) &_path_element);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_380orientation,  &_orientation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("edge_list");
}

SdaiPathH 
SdaiOriented_path::Path_element() const 
	{ return (SdaiPathH) _path_element; }

void 
SdaiOriented_path::Path_element (SdaiPathH x)
	{ _path_element = x; }

const BOOLEAN 
SdaiOriented_path::Orientation() const 
	{ return (LOGICAL) _orientation; }

void 
SdaiOriented_path::Orientation (BOOLEAN x)
	{ _orientation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_path 


/////////	 ENTITY security_classification 

EntityDescriptor *config_control_designe_security_classification =0;
AttrDescriptor *a_382name =0;
AttrDescriptor *a_383purpose =0;
AttrDescriptor *a_384security_level =0;
SdaiSecurity_classification::SdaiSecurity_classification( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification;

    STEPattribute * a = new STEPattribute (*a_382name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_383purpose,  &_purpose);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_384security_level, (STEPentityH *) &_security_level);
    a -> set_null ();
    attributes.push (a);
}
SdaiSecurity_classification::SdaiSecurity_classification (SdaiSecurity_classification& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSecurity_classification::~SdaiSecurity_classification () {  }
SdaiSecurity_classification::SdaiSecurity_classification( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification;

    STEPattribute * a = new STEPattribute (*a_382name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_383purpose,  &_purpose);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_384security_level, (STEPentityH *) &_security_level);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiSecurity_classification::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiSecurity_classification::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiSecurity_classification::Purpose() const
	{ return (const SdaiText) _purpose; }

void 
SdaiSecurity_classification::Purpose (const char * x)
	{ _purpose = x; }

SdaiSecurity_classification_levelH 
SdaiSecurity_classification::Security_level() const 
	{ return (SdaiSecurity_classification_levelH) _security_level; }

void 
SdaiSecurity_classification::Security_level (SdaiSecurity_classification_levelH x)
	{ _security_level = x; }

/////////	 END_ENTITY security_classification 


/////////	 ENTITY vertex_loop 

EntityDescriptor *config_control_designe_vertex_loop =0;
AttrDescriptor *a_385loop_vertex =0;
SdaiVertex_loop::SdaiVertex_loop( ) 
{

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_loop;

    STEPattribute * a = new STEPattribute (*a_385loop_vertex, (STEPentityH *) &_loop_vertex);
    a -> set_null ();
    attributes.push (a);
}
SdaiVertex_loop::SdaiVertex_loop (SdaiVertex_loop& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVertex_loop::~SdaiVertex_loop () {  }
SdaiVertex_loop::SdaiVertex_loop (STEPentity *se ) : SdaiLoop(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_loop;

    STEPattribute * a = new STEPattribute (*a_385loop_vertex, (STEPentityH *) &_loop_vertex);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiVertexH 
SdaiVertex_loop::Loop_vertex() const 
	{ return (SdaiVertexH) _loop_vertex; }

void 
SdaiVertex_loop::Loop_vertex (SdaiVertexH x)
	{ _loop_vertex = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vertex_loop 


/////////	 ENTITY approval_status 

EntityDescriptor *config_control_designe_approval_status =0;
AttrDescriptor *a_386name =0;
SdaiApproval_status::SdaiApproval_status( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_status;

    STEPattribute * a = new STEPattribute (*a_386name,  &_name);
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_status::SdaiApproval_status (SdaiApproval_status& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApproval_status::~SdaiApproval_status () {  }
SdaiApproval_status::SdaiApproval_status( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_status;

    STEPattribute * a = new STEPattribute (*a_386name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiApproval_status::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiApproval_status::Name (const char * x)
	{ _name = x; }

/////////	 END_ENTITY approval_status 


/////////	 ENTITY cartesian_point 

EntityDescriptor *config_control_designe_cartesian_point =0;
AttrDescriptor *a_387coordinates =0;
SdaiCartesian_point::SdaiCartesian_point( ) 
{

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_point;

    STEPattribute * a = new STEPattribute (*a_387coordinates,  &_coordinates);
    a -> set_null ();
    attributes.push (a);
}
SdaiCartesian_point::SdaiCartesian_point (SdaiCartesian_point& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCartesian_point::~SdaiCartesian_point () {  }
SdaiCartesian_point::SdaiCartesian_point (STEPentity *se ) : SdaiPoint(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiPoint  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_point;

    STEPattribute * a = new STEPattribute (*a_387coordinates,  &_coordinates);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const RealAggregateH 
SdaiCartesian_point::Coordinates() const 
	{ return (RealAggregateH) &_coordinates; }

void 
SdaiCartesian_point::Coordinates (RealAggregateH x)
	{ _coordinates.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cartesian_point 


/////////	 ENTITY date_and_time_assignment 

EntityDescriptor *config_control_designe_date_and_time_assignment =0;
AttrDescriptor *a_388assigned_date_and_time =0;
AttrDescriptor *a_389role =0;
SdaiDate_and_time_assignment::SdaiDate_and_time_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time_assignment;

    STEPattribute * a = new STEPattribute (*a_388assigned_date_and_time, (STEPentityH *) &_assigned_date_and_time);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_389role, (STEPentityH *) &_role);
    a -> set_null ();
    attributes.push (a);
}
SdaiDate_and_time_assignment::SdaiDate_and_time_assignment (SdaiDate_and_time_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDate_and_time_assignment::~SdaiDate_and_time_assignment () {  }
SdaiDate_and_time_assignment::SdaiDate_and_time_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_date_and_time_assignment;

    STEPattribute * a = new STEPattribute (*a_388assigned_date_and_time, (STEPentityH *) &_assigned_date_and_time);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_389role, (STEPentityH *) &_role);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDate_and_timeH 
SdaiDate_and_time_assignment::Assigned_date_and_time() const 
	{ return (SdaiDate_and_timeH) _assigned_date_and_time; }

void 
SdaiDate_and_time_assignment::Assigned_date_and_time (SdaiDate_and_timeH x)
	{ _assigned_date_and_time = x; }

SdaiDate_time_roleH 
SdaiDate_and_time_assignment::Role() const 
	{ return (SdaiDate_time_roleH) _role; }

void 
SdaiDate_and_time_assignment::Role (SdaiDate_time_roleH x)
	{ _role = x; }

/////////	 END_ENTITY date_and_time_assignment 


/////////	 ENTITY parametric_representation_context 

EntityDescriptor *config_control_designe_parametric_representation_context =0;
SdaiParametric_representation_context::SdaiParametric_representation_context( ) 
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parametric_representation_context;
}
SdaiParametric_representation_context::SdaiParametric_representation_context (SdaiParametric_representation_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiParametric_representation_context::~SdaiParametric_representation_context () {  }
SdaiParametric_representation_context::SdaiParametric_representation_context (STEPentity *se ) : SdaiRepresentation_context(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_parametric_representation_context;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY parametric_representation_context 


/////////	 ENTITY product_concept_context 

EntityDescriptor *config_control_designe_product_concept_context =0;
AttrDescriptor *a_390market_segment_type =0;
SdaiProduct_concept_context::SdaiProduct_concept_context( ) 
{

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_concept_context;

    STEPattribute * a = new STEPattribute (*a_390market_segment_type,  &_market_segment_type);
    a -> set_null ();
    attributes.push (a);
}
SdaiProduct_concept_context::SdaiProduct_concept_context (SdaiProduct_concept_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiProduct_concept_context::~SdaiProduct_concept_context () {  }
SdaiProduct_concept_context::SdaiProduct_concept_context (STEPentity *se ) : SdaiApplication_context_element(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiApplication_context_element  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_product_concept_context;

    STEPattribute * a = new STEPattribute (*a_390market_segment_type,  &_market_segment_type);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiProduct_concept_context::Market_segment_type() const
	{ return (const SdaiLabel) _market_segment_type; }

void 
SdaiProduct_concept_context::Market_segment_type (const char * x)
	{ _market_segment_type = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY product_concept_context 


/////////	 ENTITY cartesian_transformation_operator_2d 

EntityDescriptor *config_control_designe_cartesian_transformation_operator_2d =0;
AttrDescriptor *a_391Du =0;
SdaiCartesian_transformation_operator_2d::SdaiCartesian_transformation_operator_2d( ) 
{

	/*  parent: SdaiCartesian_transformation_operator  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_transformation_operator_2d;
    MakeDerived ("name");
}
SdaiCartesian_transformation_operator_2d::SdaiCartesian_transformation_operator_2d (SdaiCartesian_transformation_operator_2d& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCartesian_transformation_operator_2d::~SdaiCartesian_transformation_operator_2d () {  }
SdaiCartesian_transformation_operator_2d::SdaiCartesian_transformation_operator_2d (STEPentity *se ) : SdaiCartesian_transformation_operator(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCartesian_transformation_operator  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cartesian_transformation_operator_2d;
    MakeDerived ("name");
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cartesian_transformation_operator_2d 


/////////	 ENTITY surface_patch 

EntityDescriptor *config_control_designe_surface_patch =0;
AttrDescriptor *a_392parent_surface =0;
AttrDescriptor *a_393u_transition =0;
AttrDescriptor *a_394v_transition =0;
AttrDescriptor *a_395u_sense =0;
AttrDescriptor *a_396v_sense =0;
InverseAttrDescriptor *a_397Iusing_surfaces =0;
SdaiSurface_patch::SdaiSurface_patch( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_surface_patch;

    STEPattribute * a = new STEPattribute (*a_392parent_surface, (STEPentityH *) &_parent_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_393u_transition,  &_u_transition);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_394v_transition,  &_v_transition);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_395u_sense,  &_u_sense);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_396v_sense,  &_v_sense);
    a -> set_null ();
    attributes.push (a);
}
SdaiSurface_patch::SdaiSurface_patch (SdaiSurface_patch& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSurface_patch::~SdaiSurface_patch () {  }
SdaiSurface_patch::SdaiSurface_patch( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_surface_patch;

    STEPattribute * a = new STEPattribute (*a_392parent_surface, (STEPentityH *) &_parent_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_393u_transition,  &_u_transition);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_394v_transition,  &_v_transition);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_395u_sense,  &_u_sense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_396v_sense,  &_v_sense);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiBounded_surfaceH 
SdaiSurface_patch::Parent_surface() const 
	{ return (SdaiBounded_surfaceH) _parent_surface; }

void 
SdaiSurface_patch::Parent_surface (SdaiBounded_surfaceH x)
	{ _parent_surface = x; }

const sdaiTransition_code  
SdaiSurface_patch::U_transition() const 
	{ return (sdaiTransition_code) _u_transition; }

void 
SdaiSurface_patch::U_transition (sdaiTransition_code x)
	{ _u_transition.put (x); }

const sdaiTransition_code  
SdaiSurface_patch::V_transition() const 
	{ return (sdaiTransition_code) _v_transition; }

void 
SdaiSurface_patch::V_transition (sdaiTransition_code x)
	{ _v_transition.put (x); }

const BOOLEAN 
SdaiSurface_patch::U_sense() const 
	{ return (LOGICAL) _u_sense; }

void 
SdaiSurface_patch::U_sense (BOOLEAN x)
	{ _u_sense.put (x); }

const BOOLEAN 
SdaiSurface_patch::V_sense() const 
	{ return (LOGICAL) _v_sense; }

void 
SdaiSurface_patch::V_sense (BOOLEAN x)
	{ _v_sense.put (x); }

const EntityAggregateH 
SdaiSurface_patch::Using_surfaces() const 
	{ return (EntityAggregateH) &_using_surfaces; }

void 
SdaiSurface_patch::Using_surfaces (EntityAggregateH x)
	{ _using_surfaces.ShallowCopy (*x); }

/////////	 END_ENTITY surface_patch 


/////////	 ENTITY length_unit 

EntityDescriptor *config_control_designe_length_unit =0;
SdaiLength_unit::SdaiLength_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_unit;
}
SdaiLength_unit::SdaiLength_unit (SdaiLength_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiLength_unit::~SdaiLength_unit () {  }
SdaiLength_unit::SdaiLength_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_length_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY length_unit 


/////////	 ENTITY shape_aspect 

EntityDescriptor *config_control_designe_shape_aspect =0;
AttrDescriptor *a_398name =0;
AttrDescriptor *a_399description =0;
AttrDescriptor *a_400of_shape =0;
AttrDescriptor *a_401product_definitional =0;
SdaiShape_aspect::SdaiShape_aspect( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect;

    STEPattribute * a = new STEPattribute (*a_398name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_399description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_400of_shape, (STEPentityH *) &_of_shape);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_401product_definitional,  &_product_definitional);
    a -> set_null ();
    attributes.push (a);
}
SdaiShape_aspect::SdaiShape_aspect (SdaiShape_aspect& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShape_aspect::~SdaiShape_aspect () {  }
SdaiShape_aspect::SdaiShape_aspect( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_shape_aspect;

    STEPattribute * a = new STEPattribute (*a_398name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_399description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_400of_shape, (STEPentityH *) &_of_shape);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_401product_definitional,  &_product_definitional);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiShape_aspect::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiShape_aspect::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiShape_aspect::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiShape_aspect::Description (const char * x)
	{ _description = x; }

SdaiProduct_definition_shapeH 
SdaiShape_aspect::Of_shape() const 
	{ return (SdaiProduct_definition_shapeH) _of_shape; }

void 
SdaiShape_aspect::Of_shape (SdaiProduct_definition_shapeH x)
	{ _of_shape = x; }

const LOGICAL 
SdaiShape_aspect::Product_definitional() const 
	{ return (LOGICAL) _product_definitional; }

void 
SdaiShape_aspect::Product_definitional (LOGICAL x)
	{ _product_definitional.put (x); }

/////////	 END_ENTITY shape_aspect 


/////////	 ENTITY volume_measure_with_unit 

EntityDescriptor *config_control_designe_volume_measure_with_unit =0;
SdaiVolume_measure_with_unit::SdaiVolume_measure_with_unit( ) 
{

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_measure_with_unit;
}
SdaiVolume_measure_with_unit::SdaiVolume_measure_with_unit (SdaiVolume_measure_with_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVolume_measure_with_unit::~SdaiVolume_measure_with_unit () {  }
SdaiVolume_measure_with_unit::SdaiVolume_measure_with_unit (STEPentity *se ) : SdaiMeasure_with_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiMeasure_with_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_measure_with_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY volume_measure_with_unit 


/////////	 ENTITY advanced_face 

EntityDescriptor *config_control_designe_advanced_face =0;
SdaiAdvanced_face::SdaiAdvanced_face( ) 
{

	/*  parent: SdaiFace_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_face;
}
SdaiAdvanced_face::SdaiAdvanced_face (SdaiAdvanced_face& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiAdvanced_face::~SdaiAdvanced_face () {  }
SdaiAdvanced_face::SdaiAdvanced_face (STEPentity *se ) : SdaiFace_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiFace_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_advanced_face;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY advanced_face 


/////////	 ENTITY security_classification_level 

EntityDescriptor *config_control_designe_security_classification_level =0;
AttrDescriptor *a_402name =0;
SdaiSecurity_classification_level::SdaiSecurity_classification_level( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_level;

    STEPattribute * a = new STEPattribute (*a_402name,  &_name);
    a -> set_null ();
    attributes.push (a);
}
SdaiSecurity_classification_level::SdaiSecurity_classification_level (SdaiSecurity_classification_level& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSecurity_classification_level::~SdaiSecurity_classification_level () {  }
SdaiSecurity_classification_level::SdaiSecurity_classification_level( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_level;

    STEPattribute * a = new STEPattribute (*a_402name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiSecurity_classification_level::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiSecurity_classification_level::Name (const char * x)
	{ _name = x; }

/////////	 END_ENTITY security_classification_level 


/////////	 ENTITY approval_relationship 

EntityDescriptor *config_control_designe_approval_relationship =0;
AttrDescriptor *a_403name =0;
AttrDescriptor *a_404description =0;
AttrDescriptor *a_405relating_approval =0;
AttrDescriptor *a_406related_approval =0;
SdaiApproval_relationship::SdaiApproval_relationship( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_relationship;

    STEPattribute * a = new STEPattribute (*a_403name,  &_name);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_404description,  &_description);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_405relating_approval, (STEPentityH *) &_relating_approval);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_406related_approval, (STEPentityH *) &_related_approval);
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_relationship::SdaiApproval_relationship (SdaiApproval_relationship& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApproval_relationship::~SdaiApproval_relationship () {  }
SdaiApproval_relationship::SdaiApproval_relationship( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_relationship;

    STEPattribute * a = new STEPattribute (*a_403name,  &_name);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_404description,  &_description);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_405relating_approval, (STEPentityH *) &_relating_approval);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_406related_approval, (STEPentityH *) &_related_approval);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLabel 
SdaiApproval_relationship::Name() const
	{ return (const SdaiLabel) _name; }

void 
SdaiApproval_relationship::Name (const char * x)
	{ _name = x; }

const SdaiText 
SdaiApproval_relationship::Description() const
	{ return (const SdaiText) _description; }

void 
SdaiApproval_relationship::Description (const char * x)
	{ _description = x; }

SdaiApprovalH 
SdaiApproval_relationship::Relating_approval() const 
	{ return (SdaiApprovalH) _relating_approval; }

void 
SdaiApproval_relationship::Relating_approval (SdaiApprovalH x)
	{ _relating_approval = x; }

SdaiApprovalH 
SdaiApproval_relationship::Related_approval() const 
	{ return (SdaiApprovalH) _related_approval; }

void 
SdaiApproval_relationship::Related_approval (SdaiApprovalH x)
	{ _related_approval = x; }

/////////	 END_ENTITY approval_relationship 


/////////	 ENTITY polyline 

EntityDescriptor *config_control_designe_polyline =0;
AttrDescriptor *a_407points =0;
SdaiPolyline::SdaiPolyline( ) 
{

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_polyline;

    STEPattribute * a = new STEPattribute (*a_407points,  &_points);
    a -> set_null ();
    attributes.push (a);
}
SdaiPolyline::SdaiPolyline (SdaiPolyline& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPolyline::~SdaiPolyline () {  }
SdaiPolyline::SdaiPolyline (STEPentity *se ) : SdaiBounded_curve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiBounded_curve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_polyline;

    STEPattribute * a = new STEPattribute (*a_407points,  &_points);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiPolyline::Points() const 
	{ return (EntityAggregateH) &_points; }

void 
SdaiPolyline::Points (EntityAggregateH x)
	{ _points.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY polyline 


/////////	 ENTITY approval_person_organization 

EntityDescriptor *config_control_designe_approval_person_organization =0;
AttrDescriptor *a_408person_organization =0;
AttrDescriptor *a_409authorized_approval =0;
AttrDescriptor *a_410role =0;
SdaiApproval_person_organization::SdaiApproval_person_organization( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_person_organization;

    STEPattribute * a = new STEPattribute (*a_408person_organization,  &_person_organization);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_409authorized_approval, (STEPentityH *) &_authorized_approval);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_410role, (STEPentityH *) &_role);
    a -> set_null ();
    attributes.push (a);
}
SdaiApproval_person_organization::SdaiApproval_person_organization (SdaiApproval_person_organization& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiApproval_person_organization::~SdaiApproval_person_organization () {  }
SdaiApproval_person_organization::SdaiApproval_person_organization( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_approval_person_organization;

    STEPattribute * a = new STEPattribute (*a_408person_organization,  &_person_organization);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_409authorized_approval, (STEPentityH *) &_authorized_approval);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_410role, (STEPentityH *) &_role);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPerson_organization_selectH 
SdaiApproval_person_organization::Person_organization() const 
	{ return (const SdaiPerson_organization_selectH) &_person_organization; }

void 
SdaiApproval_person_organization::Person_organization (SdaiPerson_organization_selectH x)
	{ _person_organization = x; }

SdaiApprovalH 
SdaiApproval_person_organization::Authorized_approval() const 
	{ return (SdaiApprovalH) _authorized_approval; }

void 
SdaiApproval_person_organization::Authorized_approval (SdaiApprovalH x)
	{ _authorized_approval = x; }

SdaiApproval_roleH 
SdaiApproval_person_organization::Role() const 
	{ return (SdaiApproval_roleH) _role; }

void 
SdaiApproval_person_organization::Role (SdaiApproval_roleH x)
	{ _role = x; }

/////////	 END_ENTITY approval_person_organization 


/////////	 ENTITY surface_replica 

EntityDescriptor *config_control_designe_surface_replica =0;
AttrDescriptor *a_411parent_surface =0;
AttrDescriptor *a_412transformation =0;
SdaiSurface_replica::SdaiSurface_replica( ) 
{

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_replica;

    STEPattribute * a = new STEPattribute (*a_411parent_surface, (STEPentityH *) &_parent_surface);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_412transformation, (STEPentityH *) &_transformation);
    a -> set_null ();
    attributes.push (a);
}
SdaiSurface_replica::SdaiSurface_replica (SdaiSurface_replica& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSurface_replica::~SdaiSurface_replica () {  }
SdaiSurface_replica::SdaiSurface_replica (STEPentity *se ) : SdaiSurface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSurface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_surface_replica;

    STEPattribute * a = new STEPattribute (*a_411parent_surface, (STEPentityH *) &_parent_surface);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_412transformation, (STEPentityH *) &_transformation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSurfaceH 
SdaiSurface_replica::Parent_surface() const 
	{ return (SdaiSurfaceH) _parent_surface; }

void 
SdaiSurface_replica::Parent_surface (SdaiSurfaceH x)
	{ _parent_surface = x; }

SdaiCartesian_transformation_operator_3dH 
SdaiSurface_replica::Transformation() const 
	{ return (SdaiCartesian_transformation_operator_3dH) _transformation; }

void 
SdaiSurface_replica::Transformation (SdaiCartesian_transformation_operator_3dH x)
	{ _transformation = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY surface_replica 


/////////	 ENTITY security_classification_assignment 

EntityDescriptor *config_control_designe_security_classification_assignment =0;
AttrDescriptor *a_413assigned_security_classification =0;
SdaiSecurity_classification_assignment::SdaiSecurity_classification_assignment( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_assignment;

    STEPattribute * a = new STEPattribute (*a_413assigned_security_classification, (STEPentityH *) &_assigned_security_classification);
    a -> set_null ();
    attributes.push (a);
}
SdaiSecurity_classification_assignment::SdaiSecurity_classification_assignment (SdaiSecurity_classification_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiSecurity_classification_assignment::~SdaiSecurity_classification_assignment () {  }
SdaiSecurity_classification_assignment::SdaiSecurity_classification_assignment( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_security_classification_assignment;

    STEPattribute * a = new STEPattribute (*a_413assigned_security_classification, (STEPentityH *) &_assigned_security_classification);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiSecurity_classificationH 
SdaiSecurity_classification_assignment::Assigned_security_classification() const 
	{ return (SdaiSecurity_classificationH) _assigned_security_classification; }

void 
SdaiSecurity_classification_assignment::Assigned_security_classification (SdaiSecurity_classificationH x)
	{ _assigned_security_classification = x; }

/////////	 END_ENTITY security_classification_assignment 


/////////	 ENTITY cc_design_security_classification 

EntityDescriptor *config_control_designe_cc_design_security_classification =0;
AttrDescriptor *a_414items =0;
SdaiCc_design_security_classification::SdaiCc_design_security_classification( ) 
{

	/*  parent: SdaiSecurity_classification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_security_classification;

    STEPattribute * a = new STEPattribute (*a_414items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_security_classification::SdaiCc_design_security_classification (SdaiCc_design_security_classification& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCc_design_security_classification::~SdaiCc_design_security_classification () {  }
SdaiCc_design_security_classification::SdaiCc_design_security_classification (STEPentity *se ) : SdaiSecurity_classification_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiSecurity_classification_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_security_classification;

    STEPattribute * a = new STEPattribute (*a_414items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiClassified_itemsH 
SdaiCc_design_security_classification::Items() const 
	{ return (SdaiClassified_itemsH) &_items; }

void 
SdaiCc_design_security_classification::Items (SdaiClassified_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_security_classification 


/////////	 ENTITY faceted_brep_shape_representation 

EntityDescriptor *config_control_designe_faceted_brep_shape_representation =0;
SdaiFaceted_brep_shape_representation::SdaiFaceted_brep_shape_representation( ) 
{

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep_shape_representation;
}
SdaiFaceted_brep_shape_representation::SdaiFaceted_brep_shape_representation (SdaiFaceted_brep_shape_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiFaceted_brep_shape_representation::~SdaiFaceted_brep_shape_representation () {  }
SdaiFaceted_brep_shape_representation::SdaiFaceted_brep_shape_representation (STEPentity *se ) : SdaiShape_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiShape_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_faceted_brep_shape_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY faceted_brep_shape_representation 


/////////	 ENTITY document_usage_constraint 

EntityDescriptor *config_control_designe_document_usage_constraint =0;
AttrDescriptor *a_415source =0;
AttrDescriptor *a_416subject_element =0;
AttrDescriptor *a_417subject_element_value =0;
SdaiDocument_usage_constraint::SdaiDocument_usage_constraint( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_document_usage_constraint;

    STEPattribute * a = new STEPattribute (*a_415source, (STEPentityH *) &_source);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_416subject_element,  &_subject_element);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_417subject_element_value,  &_subject_element_value);
    a -> set_null ();
    attributes.push (a);
}
SdaiDocument_usage_constraint::SdaiDocument_usage_constraint (SdaiDocument_usage_constraint& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiDocument_usage_constraint::~SdaiDocument_usage_constraint () {  }
SdaiDocument_usage_constraint::SdaiDocument_usage_constraint( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_document_usage_constraint;

    STEPattribute * a = new STEPattribute (*a_415source, (STEPentityH *) &_source);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_416subject_element,  &_subject_element);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_417subject_element_value,  &_subject_element_value);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiDocumentH 
SdaiDocument_usage_constraint::Source() const 
	{ return (SdaiDocumentH) _source; }

void 
SdaiDocument_usage_constraint::Source (SdaiDocumentH x)
	{ _source = x; }

const SdaiLabel 
SdaiDocument_usage_constraint::Subject_element() const
	{ return (const SdaiLabel) _subject_element; }

void 
SdaiDocument_usage_constraint::Subject_element (const char * x)
	{ _subject_element = x; }

const SdaiText 
SdaiDocument_usage_constraint::Subject_element_value() const
	{ return (const SdaiText) _subject_element_value; }

void 
SdaiDocument_usage_constraint::Subject_element_value (const char * x)
	{ _subject_element_value = x; }

/////////	 END_ENTITY document_usage_constraint 


/////////	 ENTITY vertex_point 

EntityDescriptor *config_control_designe_vertex_point =0;
AttrDescriptor *a_418vertex_geometry =0;
SdaiVertex_point::SdaiVertex_point( ) 
{

	/*  parent: SdaiVertex  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    AppendMultInstance(new SdaiGeometric_representation_item(this)); 

    eDesc = config_control_designe_vertex_point;

    STEPattribute * a = new STEPattribute (*a_418vertex_geometry, (STEPentityH *) &_vertex_geometry);
    a -> set_null ();
    attributes.push (a);
}
SdaiVertex_point::SdaiVertex_point (SdaiVertex_point& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVertex_point::~SdaiVertex_point () {  }
SdaiVertex_point::SdaiVertex_point (STEPentity *se ) : SdaiVertex(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiVertex  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    se->AppendMultInstance(new SdaiGeometric_representation_item(se)); 

    eDesc = config_control_designe_vertex_point;

    STEPattribute * a = new STEPattribute (*a_418vertex_geometry, (STEPentityH *) &_vertex_geometry);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiPointH 
SdaiVertex_point::Vertex_geometry() const 
	{ return (SdaiPointH) _vertex_geometry; }

void 
SdaiVertex_point::Vertex_geometry (SdaiPointH x)
	{ _vertex_geometry = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY vertex_point 


/////////	 ENTITY cc_design_date_and_time_assignment 

EntityDescriptor *config_control_designe_cc_design_date_and_time_assignment =0;
AttrDescriptor *a_419items =0;
SdaiCc_design_date_and_time_assignment::SdaiCc_design_date_and_time_assignment( ) 
{

	/*  parent: SdaiDate_and_time_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_date_and_time_assignment;

    STEPattribute * a = new STEPattribute (*a_419items,  &_items);
    a -> set_null ();
    attributes.push (a);
}
SdaiCc_design_date_and_time_assignment::SdaiCc_design_date_and_time_assignment (SdaiCc_design_date_and_time_assignment& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCc_design_date_and_time_assignment::~SdaiCc_design_date_and_time_assignment () {  }
SdaiCc_design_date_and_time_assignment::SdaiCc_design_date_and_time_assignment (STEPentity *se ) : SdaiDate_and_time_assignment(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiDate_and_time_assignment  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cc_design_date_and_time_assignment;

    STEPattribute * a = new STEPattribute (*a_419items,  &_items);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiDate_time_itemsH 
SdaiCc_design_date_and_time_assignment::Items() const 
	{ return (SdaiDate_time_itemsH) &_items; }

void 
SdaiCc_design_date_and_time_assignment::Items (SdaiDate_time_itemsH x)
	{ _items.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cc_design_date_and_time_assignment 


/////////	 ENTITY oriented_closed_shell 

EntityDescriptor *config_control_designe_oriented_closed_shell =0;
AttrDescriptor *a_420closed_shell_element =0;
AttrDescriptor *a_421orientation =0;
AttrDescriptor *a_422Dconnected_face_set_cfs_faces =0;
SdaiOriented_closed_shell::SdaiOriented_closed_shell( ) 
{

	/*  parent: SdaiClosed_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_closed_shell;

    STEPattribute * a = new STEPattribute (*a_420closed_shell_element, (STEPentityH *) &_closed_shell_element);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_421orientation,  &_orientation);
    a -> set_null ();
    attributes.push (a);
    MakeDerived ("cfs_faces");
}
SdaiOriented_closed_shell::SdaiOriented_closed_shell (SdaiOriented_closed_shell& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOriented_closed_shell::~SdaiOriented_closed_shell () {  }
SdaiOriented_closed_shell::SdaiOriented_closed_shell (STEPentity *se ) : SdaiClosed_shell(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiClosed_shell  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_oriented_closed_shell;

    STEPattribute * a = new STEPattribute (*a_420closed_shell_element, (STEPentityH *) &_closed_shell_element);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_421orientation,  &_orientation);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
    MakeDerived ("cfs_faces");
}

SdaiClosed_shellH 
SdaiOriented_closed_shell::Closed_shell_element() const 
	{ return (SdaiClosed_shellH) _closed_shell_element; }

void 
SdaiOriented_closed_shell::Closed_shell_element (SdaiClosed_shellH x)
	{ _closed_shell_element = x; }

const BOOLEAN 
SdaiOriented_closed_shell::Orientation() const 
	{ return (LOGICAL) _orientation; }

void 
SdaiOriented_closed_shell::Orientation (BOOLEAN x)
	{ _orientation.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY oriented_closed_shell 


/////////	 ENTITY person_and_organization 

EntityDescriptor *config_control_designe_person_and_organization =0;
AttrDescriptor *a_423the_person =0;
AttrDescriptor *a_424the_organization =0;
SdaiPerson_and_organization::SdaiPerson_and_organization( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization;

    STEPattribute * a = new STEPattribute (*a_423the_person, (STEPentityH *) &_the_person);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_424the_organization, (STEPentityH *) &_the_organization);
    a -> set_null ();
    attributes.push (a);
}
SdaiPerson_and_organization::SdaiPerson_and_organization (SdaiPerson_and_organization& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPerson_and_organization::~SdaiPerson_and_organization () {  }
SdaiPerson_and_organization::SdaiPerson_and_organization( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_person_and_organization;

    STEPattribute * a = new STEPattribute (*a_423the_person, (STEPentityH *) &_the_person);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_424the_organization, (STEPentityH *) &_the_organization);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiPersonH 
SdaiPerson_and_organization::The_person() const 
	{ return (SdaiPersonH) _the_person; }

void 
SdaiPerson_and_organization::The_person (SdaiPersonH x)
	{ _the_person = x; }

SdaiOrganizationH 
SdaiPerson_and_organization::The_organization() const 
	{ return (SdaiOrganizationH) _the_organization; }

void 
SdaiPerson_and_organization::The_organization (SdaiOrganizationH x)
	{ _the_organization = x; }

/////////	 END_ENTITY person_and_organization 


/////////	 ENTITY cylindrical_surface 

EntityDescriptor *config_control_designe_cylindrical_surface =0;
AttrDescriptor *a_425radius =0;
SdaiCylindrical_surface::SdaiCylindrical_surface( ) 
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cylindrical_surface;

    STEPattribute * a = new STEPattribute (*a_425radius,  &_radius);
    a -> set_null ();
    attributes.push (a);
}
SdaiCylindrical_surface::SdaiCylindrical_surface (SdaiCylindrical_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiCylindrical_surface::~SdaiCylindrical_surface () {  }
SdaiCylindrical_surface::SdaiCylindrical_surface (STEPentity *se ) : SdaiElementary_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_cylindrical_surface;

    STEPattribute * a = new STEPattribute (*a_425radius,  &_radius);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiPositive_length_measure 
SdaiCylindrical_surface::Radius() const 
	{ return (const SdaiPositive_length_measure) _radius; }

void 
SdaiCylindrical_surface::Radius (SdaiPositive_length_measure x)
	{ _radius = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY cylindrical_surface 


/////////	 ENTITY local_time 

EntityDescriptor *config_control_designe_local_time =0;
AttrDescriptor *a_426hour_component =0;
AttrDescriptor *a_427minute_component =0;
AttrDescriptor *a_428second_component =0;
AttrDescriptor *a_429zone =0;
SdaiLocal_time::SdaiLocal_time( ) 
{

	/*  no SuperTypes */

    eDesc = config_control_designe_local_time;

    STEPattribute * a = new STEPattribute (*a_426hour_component,  &_hour_component);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_427minute_component,  &_minute_component);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_428second_component,  &_second_component);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_429zone, (STEPentityH *) &_zone);
    a -> set_null ();
    attributes.push (a);
}
SdaiLocal_time::SdaiLocal_time (SdaiLocal_time& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiLocal_time::~SdaiLocal_time () {  }
SdaiLocal_time::SdaiLocal_time( STEPentity *se ) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  no SuperTypes */

    eDesc = config_control_designe_local_time;

    STEPattribute * a = new STEPattribute (*a_426hour_component,  &_hour_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_427minute_component,  &_minute_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_428second_component,  &_second_component);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_429zone, (STEPentityH *) &_zone);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiHour_in_day 
SdaiLocal_time::Hour_component() const 
	{ return (const SdaiHour_in_day) _hour_component; }

void 
SdaiLocal_time::Hour_component (SdaiHour_in_day x)
	{ _hour_component = x; }

const SdaiMinute_in_hour 
SdaiLocal_time::Minute_component() const 
	{ return (const SdaiMinute_in_hour) _minute_component; }

void 
SdaiLocal_time::Minute_component (SdaiMinute_in_hour x)
	{ _minute_component = x; }

const SdaiSecond_in_minute 
SdaiLocal_time::Second_component() const 
	{ return (const SdaiSecond_in_minute) _second_component; }

void 
SdaiLocal_time::Second_component (SdaiSecond_in_minute x)
	{ _second_component = x; }

SdaiCoordinated_universal_time_offsetH 
SdaiLocal_time::Zone() const 
	{ return (SdaiCoordinated_universal_time_offsetH) _zone; }

void 
SdaiLocal_time::Zone (SdaiCoordinated_universal_time_offsetH x)
	{ _zone = x; }

/////////	 END_ENTITY local_time 


/////////	 ENTITY mass_unit 

EntityDescriptor *config_control_designe_mass_unit =0;
SdaiMass_unit::SdaiMass_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_unit;
}
SdaiMass_unit::SdaiMass_unit (SdaiMass_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiMass_unit::~SdaiMass_unit () {  }
SdaiMass_unit::SdaiMass_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mass_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mass_unit 


/////////	 ENTITY vertex_shell 

EntityDescriptor *config_control_designe_vertex_shell =0;
AttrDescriptor *a_430vertex_shell_extent =0;
SdaiVertex_shell::SdaiVertex_shell( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_shell;

    STEPattribute * a = new STEPattribute (*a_430vertex_shell_extent, (STEPentityH *) &_vertex_shell_extent);
    a -> set_null ();
    attributes.push (a);
}
SdaiVertex_shell::SdaiVertex_shell (SdaiVertex_shell& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVertex_shell::~SdaiVertex_shell () {  }
SdaiVertex_shell::SdaiVertex_shell (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_vertex_shell;

    STEPattribute * a = new STEPattribute (*a_430vertex_shell_extent, (STEPentityH *) &_vertex_shell_extent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiVertex_loopH 
SdaiVertex_shell::Vertex_shell_extent() const 
	{ return (SdaiVertex_loopH) _vertex_shell_extent; }

void 
SdaiVertex_shell::Vertex_shell_extent (SdaiVertex_loopH x)
	{ _vertex_shell_extent = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY vertex_shell 


/////////	 ENTITY poly_loop 

EntityDescriptor *config_control_designe_poly_loop =0;
AttrDescriptor *a_431polygon =0;
SdaiPoly_loop::SdaiPoly_loop( ) 
{

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    AppendMultInstance(new SdaiGeometric_representation_item(this)); 

    eDesc = config_control_designe_poly_loop;

    STEPattribute * a = new STEPattribute (*a_431polygon,  &_polygon);
    a -> set_null ();
    attributes.push (a);
}
SdaiPoly_loop::SdaiPoly_loop (SdaiPoly_loop& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiPoly_loop::~SdaiPoly_loop () {  }
SdaiPoly_loop::SdaiPoly_loop (STEPentity *se ) : SdaiLoop(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiLoop  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */
	/*  parent: SdaiGeometric_representation_item  */
    se->AppendMultInstance(new SdaiGeometric_representation_item(se)); 

    eDesc = config_control_designe_poly_loop;

    STEPattribute * a = new STEPattribute (*a_431polygon,  &_polygon);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiPoly_loop::Polygon() const 
	{ return (EntityAggregateH) &_polygon; }

void 
SdaiPoly_loop::Polygon (EntityAggregateH x)
	{ _polygon.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

#if 0

#endif

/////////	 END_ENTITY poly_loop 


/////////	 ENTITY wire_shell 

EntityDescriptor *config_control_designe_wire_shell =0;
AttrDescriptor *a_432wire_shell_extent =0;
SdaiWire_shell::SdaiWire_shell( ) 
{

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_wire_shell;

    STEPattribute * a = new STEPattribute (*a_432wire_shell_extent,  &_wire_shell_extent);
    a -> set_null ();
    attributes.push (a);
}
SdaiWire_shell::SdaiWire_shell (SdaiWire_shell& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiWire_shell::~SdaiWire_shell () {  }
SdaiWire_shell::SdaiWire_shell (STEPentity *se ) : SdaiTopological_representation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiTopological_representation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_wire_shell;

    STEPattribute * a = new STEPattribute (*a_432wire_shell_extent,  &_wire_shell_extent);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const EntityAggregateH 
SdaiWire_shell::Wire_shell_extent() const 
	{ return (EntityAggregateH) &_wire_shell_extent; }

void 
SdaiWire_shell::Wire_shell_extent (EntityAggregateH x)
	{ _wire_shell_extent.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY wire_shell 


/////////	 ENTITY area_unit 

EntityDescriptor *config_control_designe_area_unit =0;
SdaiArea_unit::SdaiArea_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_unit;
}
SdaiArea_unit::SdaiArea_unit (SdaiArea_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiArea_unit::~SdaiArea_unit () {  }
SdaiArea_unit::SdaiArea_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_area_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY area_unit 


/////////	 ENTITY mapped_item 

EntityDescriptor *config_control_designe_mapped_item =0;
AttrDescriptor *a_433mapping_source =0;
AttrDescriptor *a_434mapping_target =0;
SdaiMapped_item::SdaiMapped_item( ) 
{

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mapped_item;

    STEPattribute * a = new STEPattribute (*a_433mapping_source, (STEPentityH *) &_mapping_source);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_434mapping_target, (STEPentityH *) &_mapping_target);
    a -> set_null ();
    attributes.push (a);
}
SdaiMapped_item::SdaiMapped_item (SdaiMapped_item& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiMapped_item::~SdaiMapped_item () {  }
SdaiMapped_item::SdaiMapped_item (STEPentity *se ) : SdaiRepresentation_item(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_item  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_mapped_item;

    STEPattribute * a = new STEPattribute (*a_433mapping_source, (STEPentityH *) &_mapping_source);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_434mapping_target, (STEPentityH *) &_mapping_target);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiRepresentation_mapH 
SdaiMapped_item::Mapping_source() const 
	{ return (SdaiRepresentation_mapH) _mapping_source; }

void 
SdaiMapped_item::Mapping_source (SdaiRepresentation_mapH x)
	{ _mapping_source = x; }

SdaiRepresentation_itemH 
SdaiMapped_item::Mapping_target() const 
	{ return (SdaiRepresentation_itemH) _mapping_target; }

void 
SdaiMapped_item::Mapping_target (SdaiRepresentation_itemH x)
	{ _mapping_target = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY mapped_item 


/////////	 ENTITY offset_curve_2d 

EntityDescriptor *config_control_designe_offset_curve_2d =0;
AttrDescriptor *a_435basis_curve =0;
AttrDescriptor *a_436distance =0;
AttrDescriptor *a_437self_intersect =0;
SdaiOffset_curve_2d::SdaiOffset_curve_2d( ) 
{

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_curve_2d;

    STEPattribute * a = new STEPattribute (*a_435basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_436distance,  &_distance);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_437self_intersect,  &_self_intersect);
    a -> set_null ();
    attributes.push (a);
}
SdaiOffset_curve_2d::SdaiOffset_curve_2d (SdaiOffset_curve_2d& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiOffset_curve_2d::~SdaiOffset_curve_2d () {  }
SdaiOffset_curve_2d::SdaiOffset_curve_2d (STEPentity *se ) : SdaiCurve(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiCurve  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_offset_curve_2d;

    STEPattribute * a = new STEPattribute (*a_435basis_curve, (STEPentityH *) &_basis_curve);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_436distance,  &_distance);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_437self_intersect,  &_self_intersect);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

SdaiCurveH 
SdaiOffset_curve_2d::Basis_curve() const 
	{ return (SdaiCurveH) _basis_curve; }

void 
SdaiOffset_curve_2d::Basis_curve (SdaiCurveH x)
	{ _basis_curve = x; }

const SdaiLength_measure 
SdaiOffset_curve_2d::Distance() const 
	{ return (const SdaiLength_measure) _distance; }

void 
SdaiOffset_curve_2d::Distance (SdaiLength_measure x)
	{ _distance = x; }

const LOGICAL 
SdaiOffset_curve_2d::Self_intersect() const 
	{ return (LOGICAL) _self_intersect; }

void 
SdaiOffset_curve_2d::Self_intersect (LOGICAL x)
	{ _self_intersect.put (x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY offset_curve_2d 


/////////	 ENTITY shape_definition_representation 

EntityDescriptor *config_control_designe_shape_definition_representation =0;
SdaiShape_definition_representation::SdaiShape_definition_representation( ) 
{

	/*  parent: SdaiProperty_definition_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_definition_representation;
}
SdaiShape_definition_representation::SdaiShape_definition_representation (SdaiShape_definition_representation& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiShape_definition_representation::~SdaiShape_definition_representation () {  }
SdaiShape_definition_representation::SdaiShape_definition_representation (STEPentity *se ) : SdaiProperty_definition_representation(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiProperty_definition_representation  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_shape_definition_representation;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY shape_definition_representation 


/////////	 ENTITY volume_unit 

EntityDescriptor *config_control_designe_volume_unit =0;
SdaiVolume_unit::SdaiVolume_unit( ) 
{

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_unit;
}
SdaiVolume_unit::SdaiVolume_unit (SdaiVolume_unit& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiVolume_unit::~SdaiVolume_unit () {  }
SdaiVolume_unit::SdaiVolume_unit (STEPentity *se ) : SdaiNamed_unit(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiNamed_unit  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_volume_unit;
}
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY volume_unit 


/////////	 ENTITY conical_surface 

EntityDescriptor *config_control_designe_conical_surface =0;
AttrDescriptor *a_438radius =0;
AttrDescriptor *a_439semi_angle =0;
SdaiConical_surface::SdaiConical_surface( ) 
{

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conical_surface;

    STEPattribute * a = new STEPattribute (*a_438radius,  &_radius);
    a -> set_null ();
    attributes.push (a);

     a = new STEPattribute (*a_439semi_angle,  &_semi_angle);
    a -> set_null ();
    attributes.push (a);
}
SdaiConical_surface::SdaiConical_surface (SdaiConical_surface& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiConical_surface::~SdaiConical_surface () {  }
SdaiConical_surface::SdaiConical_surface (STEPentity *se ) : SdaiElementary_surface(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiElementary_surface  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_conical_surface;

    STEPattribute * a = new STEPattribute (*a_438radius,  &_radius);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);

     a = new STEPattribute (*a_439semi_angle,  &_semi_angle);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiLength_measure 
SdaiConical_surface::Radius() const 
	{ return (const SdaiLength_measure) _radius; }

void 
SdaiConical_surface::Radius (SdaiLength_measure x)
	{ _radius = x; }

const SdaiPlane_angle_measure 
SdaiConical_surface::Semi_angle() const 
	{ return (const SdaiPlane_angle_measure) _semi_angle; }

void 
SdaiConical_surface::Semi_angle (SdaiPlane_angle_measure x)
	{ _semi_angle = x; }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY conical_surface 


/////////	 ENTITY global_unit_assigned_context 

EntityDescriptor *config_control_designe_global_unit_assigned_context =0;
AttrDescriptor *a_440units =0;
SdaiGlobal_unit_assigned_context::SdaiGlobal_unit_assigned_context( ) 
{

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_unit_assigned_context;

    STEPattribute * a = new STEPattribute (*a_440units,  &_units);
    a -> set_null ();
    attributes.push (a);
}
SdaiGlobal_unit_assigned_context::SdaiGlobal_unit_assigned_context (SdaiGlobal_unit_assigned_context& e ) 
	{  CopyAs((STEPentityH) &e);	}
SdaiGlobal_unit_assigned_context::~SdaiGlobal_unit_assigned_context () {  }
SdaiGlobal_unit_assigned_context::SdaiGlobal_unit_assigned_context (STEPentity *se ) : SdaiRepresentation_context(se) 
{
	/* Set this to point to the head entity. */
    HeadEntity(se); 

	/*  parent: SdaiRepresentation_context  */
	/* Ignore the first parent since it is */
 	/* part of the main inheritance hierarchy */

    eDesc = config_control_designe_global_unit_assigned_context;

    STEPattribute * a = new STEPattribute (*a_440units,  &_units);
    a -> set_null ();
	/* Put attribute on this class' attributes List so the */
	/*access functions still work. */ 
    attributes.push (a);
	/* Put attribute on the attributes List for the */
	/* main inheritance heirarchy. */ 
    se->attributes.push (a);
}

const SdaiUnitsH 
SdaiGlobal_unit_assigned_context::Units() const 
	{ return (SdaiUnitsH) &_units; }

void 
SdaiGlobal_unit_assigned_context::Units (SdaiUnitsH x)
	{ _units.ShallowCopy (*x); }
	/* The first parent's access functions are */
	/* above or covered by inherited functions. */

/////////	 END_ENTITY global_unit_assigned_context 

#endif
