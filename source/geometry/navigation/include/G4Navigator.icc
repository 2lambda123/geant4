//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * The following disclaimer summarizes all the specific disclaimers *
// * of contributors to this software. The specific disclaimers,which *
// * govern, are listed with their locations in:                      *
// *   http://cern.ch/geant4/license                                  *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * This  code  implementation is the  intellectual property  of the *
// * GEANT4 collaboration.                                            *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//
// $Id: G4Navigator.icc,v 1.6 2004-11-19 14:21:42 japost Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
// 
// class G4Navigator Inline implementation
//
// ********************************************************************

// ********************************************************************
// GetCurrentLocalCoordinate
//
// Returns the local coordinate of the current track
// ********************************************************************
//
inline
G4ThreeVector G4Navigator::GetCurrentLocalCoordinate() const
{
  return fLastLocatedPointLocal;
}

// ********************************************************************
// ComputeLocalAxis
//
// Returns local direction of vector direction in world coord system
// ********************************************************************
//
inline
G4ThreeVector G4Navigator::ComputeLocalAxis(const G4ThreeVector& pVec) const
{
  return (fHistory.GetTopTransform().IsRotated())
         ? fHistory.GetTopTransform().TransformAxis(pVec) : pVec ;
}

// ********************************************************************
// ComputeLocalPoint
//
// Returns local coordinates of a point in the world coord system
// ********************************************************************
//
inline
G4ThreeVector
G4Navigator::ComputeLocalPoint(const G4ThreeVector& pGlobalPoint) const
{
  return ( fHistory.GetTopTransform().TransformPoint(pGlobalPoint) ) ;
}

// ********************************************************************
// GetWorldVolume
//
// Returns the current  world (`topmost') volume
// ********************************************************************
//
inline
G4VPhysicalVolume* G4Navigator::GetWorldVolume() const
{
  return fTopPhysical;
}

// ********************************************************************
// SetWorldVolume
//
// Sets the world (`topmost') volume
// ********************************************************************
//
inline
void G4Navigator::SetWorldVolume(G4VPhysicalVolume* pWorld)
{
  if ( !(pWorld->GetTranslation()==G4ThreeVector(0,0,0)) )
  {
    G4Exception ("G4Navigator::SetWorldVolume()", "InvalidSetup",
                 FatalException, "Volume must be centered on the origin.");
  }
  const G4RotationMatrix* rm = pWorld->GetRotation();
  if ( rm && (!rm->isIdentity()) )
  {
    G4Exception ("G4Navigator::SetWorldVolume()", "InvalidSetup",
                 FatalException, "Volume must not be rotated.");
  }
  fTopPhysical = pWorld;
  fHistory.SetFirstEntry(pWorld);
}

// ********************************************************************
// SetGeometrycallyLimitedStep
//
// Informs the navigator that the previous Step calculated
// by the geometry was taken in its entirety
// ********************************************************************
//
inline
void G4Navigator::SetGeometricallyLimitedStep()
{
  fWasLimitedByGeometry=true;
}

// ********************************************************************
// ResetStackAndState
//
// Resets stack and minimum of navigator state `machine'
// ********************************************************************
//
inline
void G4Navigator::ResetStackAndState()
{
  fHistory.Reset();
  ResetState();
}

// ********************************************************************
// VolumeType
// ********************************************************************
//
inline
EVolume G4Navigator::VolumeType(const G4VPhysicalVolume *pVol) const
{
  EVolume type;
  EAxis axis;
  G4int nReplicas;
  G4double width,offset;
  G4bool consuming;
  if ( pVol->IsReplicated() )
  {
    pVol->GetReplicationData(axis,nReplicas,width,offset,consuming);
    type = (consuming) ? kReplica : kParameterised;
  }
  else
  {
    type = kNormal;
  }
  return type;
}

// ********************************************************************
// CharacteriseDahghters
// ********************************************************************
//
inline
EVolume G4Navigator::CharacteriseDaughters(const G4LogicalVolume *pLog) const
{
  EVolume type;
  EAxis axis;
  G4int nReplicas;
  G4double width,offset;
  G4bool consuming;
  G4VPhysicalVolume *pVol;

  if ( pLog->GetNoDaughters()==1 )
  {
    pVol = pLog->GetDaughter(0);
    if (pVol->IsReplicated())
    {
      pVol->GetReplicationData(axis,nReplicas,width,offset,consuming);
      type = (consuming) ? kReplica : kParameterised;
    }
    else
    {
      type = kNormal;
    }
  }
  else
  {
    type = kNormal;
  }
  return type;
}

// ********************************************************************
// GetGlobalToLocalTransform
//
// Returns local to global transformation.
// I.e. transformation that will take point or axis in world coord system
// and return one in the local coord system
// ********************************************************************
//
inline
const G4AffineTransform& G4Navigator::GetGlobalToLocalTransform() const
{
  return fHistory.GetTopTransform();
}

// ********************************************************************
// GetLocalToGlobalTransform
//
// Returns global to local transformation 
// ********************************************************************
//
inline
const G4AffineTransform G4Navigator::GetLocalToGlobalTransform() const
{
  G4AffineTransform  tempTransform;
  tempTransform = fHistory.GetTopTransform().Inverse(); 
  return tempTransform;
}

// ********************************************************************
// NetTranslation
//
// Computes+returns the local->global translation of current volume
// ********************************************************************
//
inline
G4ThreeVector G4Navigator::NetTranslation() const
{
  G4AffineTransform tf(fHistory.GetTopTransform().Inverse());
  return tf.NetTranslation();
}

// ********************************************************************
// NetRotation
//
// Computes+returns the local->global rotation of current volume
// ********************************************************************
//
inline
G4RotationMatrix G4Navigator::NetRotation() const
{
  G4AffineTransform tf(fHistory.GetTopTransform().Inverse());
  return tf.NetRotation();
}

// ********************************************************************
// CreateGRSVolume
//
// `Touchable' creation method: caller has deletion responsibility
// ********************************************************************
//
inline
G4GRSVolume* G4Navigator::CreateGRSVolume() const
{
  G4AffineTransform tf(fHistory.GetTopTransform().Inverse());
  return new G4GRSVolume(fHistory.GetTopVolume(),
                         tf.NetRotation(),
                         tf.NetTranslation());
}

// ********************************************************************
// CreateGRSSolid
//
// `Touchable' creation method: caller has deletion responsibility
// ********************************************************************
//
inline
G4GRSSolid* G4Navigator::CreateGRSSolid() const
{
  G4AffineTransform tf(fHistory.GetTopTransform().Inverse());
  return new G4GRSSolid(fHistory.GetTopVolume()->GetLogicalVolume()->GetSolid(),
                        tf.NetRotation(),
                        tf.NetTranslation());
}

// ********************************************************************
// CreateTouchableHistory
//
// `Touchable' creation method: caller has deletion responsibility
// ********************************************************************
//
inline
G4TouchableHistory* G4Navigator::CreateTouchableHistory() const
{
  return new G4TouchableHistory(fHistory);
}

// ********************************************************************
// EnteredDaughterVolume
//
// To inform the caller if the track is entering a daughter volume
// ********************************************************************
//
inline
G4bool  G4Navigator::EnteredDaughterVolume()
{
  return fEnteredDaughter;
}

// ********************************************************************
// LocateGlobalPointAndUpdateTouchable
//
// Use direction
// ********************************************************************
//
inline
void G4Navigator::LocateGlobalPointAndUpdateTouchable(
                           const G4ThreeVector&       position,
                           const G4ThreeVector&       direction,
                                 G4VTouchable*        touchableToUpdate,
                           const G4bool               RelativeSearch  )
{
  G4VPhysicalVolume* pPhysVol;
  pPhysVol = LocateGlobalPointAndSetup( position, &direction, RelativeSearch);  
  touchableToUpdate->UpdateYourself( pPhysVol, &fHistory );
}

// ********************************************************************
// LocateGlobalPointAndUpdateTouchable
// ********************************************************************
//
inline
void G4Navigator::LocateGlobalPointAndUpdateTouchable(
                           const G4ThreeVector&       position,
                                 G4VTouchable*        touchableToUpdate,
                           const G4bool               RelativeSearch )
{
  G4VPhysicalVolume* pPhysVol;
  pPhysVol = LocateGlobalPointAndSetup( position, 0, RelativeSearch);  
  touchableToUpdate->UpdateYourself( pPhysVol, &fHistory );
}

// ********************************************************************
// GetVerboseLevel
// ********************************************************************
//
inline
G4int G4Navigator::GetVerboseLevel() const
{
  return fVerbose;
}

// ********************************************************************
// SetVerboseLevel
// ********************************************************************
//
inline
void  G4Navigator::SetVerboseLevel(G4int level)
{
  fVerbose = level;
  fnormalNav.SetVerboseLevel(level);
  fvoxelNav.SetVerboseLevel(level);
  fparamNav.SetVerboseLevel(level);
  freplicaNav.SetVerboseLevel(level);
}

// ********************************************************************
// CheckMode
// ********************************************************************
//
inline
void  G4Navigator::CheckMode(G4bool mode)
{
  fCheck = mode;
  fnormalNav.CheckMode(mode);
  fvoxelNav.CheckMode(mode);
  fparamNav.CheckMode(mode);
  freplicaNav.CheckMode(mode);
}

inline 
G4int G4Navigator::SeverityOfZeroStepping( G4int *noZeroSteps ) const 
    // Report on severity of error (in case Navigator is stuck
    //   and is returning zero steps.)
{
  G4int severity=0, noZeros= fNumberZeroSteps;
  if( noZeroSteps) *noZeroSteps = fNumberZeroSteps;

  if( noZeros >= fAbandonThreshold_NoZeroSteps ){
    severity = 10;
  }
  if( noZeros > 0 && noZeros < fActionThreshold_NoZeroSteps ){
    severity =  5 * noZeros / fActionThreshold_NoZeroSteps;
  }
  else if( noZeros == fActionThreshold_NoZeroSteps ){
    severity =  5; 
  }
  else if( noZeros >= fAbandonThreshold_NoZeroSteps - 2 ){
    severity =  9; 
  }
  else if( noZeros < fAbandonThreshold_NoZeroSteps - 2 ){
    severity =  5 + 4 * (noZeros-fAbandonThreshold_NoZeroSteps) / fActionThreshold_NoZeroSteps;
  }

  return severity;
}
 
