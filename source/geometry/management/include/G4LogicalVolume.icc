//
// ********************************************************************
// * DISCLAIMER                                                       *
// *                                                                  *
// * The following disclaimer summarizes all the specific disclaimers *
// * of contributors to this software. The specific disclaimers,which *
// * govern, are listed with their locations in:                      *
// *   http://cern.ch/geant4/license                                  *
// *                                                                  *
// * Neither the authors of this software system, nor their employing *
// * institutes,nor the agencies providing financial support for this *
// * work  make  any representation or  warranty, express or implied, *
// * regarding  this  software system or assume any liability for its *
// * use.                                                             *
// *                                                                  *
// * This  code  implementation is the  intellectual property  of the *
// * GEANT4 collaboration.                                            *
// * By copying,  distributing  or modifying the Program (or any work *
// * based  on  the Program)  you indicate  your  acceptance of  this *
// * statement, and all its terms.                                    *
// ********************************************************************
//
//
// $Id: G4LogicalVolume.icc,v 1.6 2001-07-11 09:59:17 gunter Exp $
// GEANT4 tag $Name: not supported by cvs2svn $
//
// 
// class G4LogicalVolume Inline Implementation file
//
// 10.20.97 - P. MoraDeFreitas : Added SetFastSimulation method.
// 05.11.98 - M. Verderi: Add Get/Set methods for fBiasWeight
// 09.11.98 - J. Apostolakis:  Changed MagneticField to FieldManager
// 12.02.99 - S.Giani: Added set/get methods for voxelization quality
// 18.04.01 - G.Cosmo: Migrated to STL vector

inline
G4String G4LogicalVolume::GetName() const
    {
	return fName;
    }
    
inline
void G4LogicalVolume::SetName(const G4String& pName)
    {
	fName=pName;
    }

inline
G4FieldManager* G4LogicalVolume::GetFieldManager() const
    {
	return fFieldManager;
    }

inline
G4int G4LogicalVolume::GetNoDaughters() const
    {
	return fDaughters.size();
    }

inline
G4VPhysicalVolume* G4LogicalVolume::GetDaughter(const G4int i) const
    {
	return fDaughters[i];
    }

inline
G4FastSimulationManager* G4LogicalVolume::GetFastSimulationManager () const 
    {
	return fFastSimulationManager;
    }

inline
void G4LogicalVolume::AddDaughter(G4VPhysicalVolume* pNewDaughter)
{
      fDaughters.push_back(pNewDaughter);

  // Propagates the mother's FastSimulationManager pointer. If we are in
  // the World logical volume, propagates only if pointer != 0.
  // (perhaps someone would like to parametrize all the World volume 
  // for a particle type, why not ?).

      G4VPhysicalVolume *myPhysical= pNewDaughter->GetMother();
      G4VPhysicalVolume *pMotherPhys;
      G4LogicalVolume *pDaughterLogical;

      if( myPhysical !=0 ){
         pMotherPhys= myPhysical->GetMother();
         pDaughterLogical = pNewDaughter->GetLogicalVolume();

	 if( (pMotherPhys!=0) ||
	    ( pMotherPhys==0) && (fFastSimulationManager!=0)) 
	 {
	   if(pDaughterLogical->GetFastSimulationManager() != fFastSimulationManager)
	     pDaughterLogical->SetFastSimulationManager(fFastSimulationManager,
	                                                FALSE);
	 }
	 else
         {
	   pDaughterLogical->SetFastSimulationManager(NULL,FALSE);
	 }
      }
      

  // Propagate the Field Manager, if the daughter has no field Manager.

      pDaughterLogical = pNewDaughter->GetLogicalVolume();
      G4FieldManager* pDaughterFieldManager =
                      pDaughterLogical->GetFieldManager();

      if( pDaughterFieldManager == 0 )
      {
 	 pDaughterLogical->SetFieldManager(fFieldManager, true);
      }
}

inline
G4bool G4LogicalVolume::IsDaughter(const G4VPhysicalVolume* p) const
    {
	G4PhysicalVolumeList::const_iterator i;
        for (i=fDaughters.begin(); i!=fDaughters.end(); ++i)
        {
          if (**i==*p) return true;
        }
        return false;
    }

inline
void G4LogicalVolume::RemoveDaughter(const G4VPhysicalVolume* p)
    {
	G4PhysicalVolumeList::iterator i;
	for (i=fDaughters.begin(); i!=fDaughters.end(); ++i)
	{
	   if (**i==*p)
	   {
	      fDaughters.erase(i);
	      break;
	   }
	}
    }

inline
G4VSolid* G4LogicalVolume::GetSolid() const
    {
	return fSolid;
    }

inline
void G4LogicalVolume::SetSolid(G4VSolid *pSolid)
    {
        assert(pSolid != 0);
	fSolid=pSolid;
    }

inline
G4Material* G4LogicalVolume::GetMaterial() const
    {
	return fMaterial;
    }

inline
void G4LogicalVolume::SetMaterial(G4Material *pMaterial)
    {
      //        assert(pMaterial != 0);
        fMaterial=pMaterial;
    }

inline
G4VSensitiveDetector* G4LogicalVolume::GetSensitiveDetector() const
    {
	return fSensitiveDetector;
    }

inline
void G4LogicalVolume::SetSensitiveDetector(G4VSensitiveDetector *pSDetector)
    {
	fSensitiveDetector=pSDetector;
    }

inline
G4UserLimits* G4LogicalVolume::GetUserLimits() const
    {
	return fUserLimits;
    }

inline
void G4LogicalVolume::SetUserLimits(G4UserLimits *pULimits)
    {
	fUserLimits=pULimits;
    }

inline
G4SmartVoxelHeader* G4LogicalVolume::GetVoxelHeader() const
    {
	return fVoxel;
    }

inline
void G4LogicalVolume::SetVoxelHeader(G4SmartVoxelHeader *pVoxel)
    {
	fVoxel=pVoxel;
    }

inline
G4double G4LogicalVolume::GetSmartless()
    {
        return fSmartless;
    }

inline
void G4LogicalVolume::SetSmartless(G4double s)
    {
        fSmartless=s;
    }
    
inline
G4bool G4LogicalVolume::operator == ( const G4LogicalVolume& lv) const
    {
	return (this==&lv) ? true : false;
    }

inline
const G4VisAttributes* G4LogicalVolume::GetVisAttributes () const
    {
        return fVisAttributes;
    }

inline
void G4LogicalVolume::SetVisAttributes (const G4VisAttributes* pVA)
    {
        fVisAttributes = pVA;
    }

inline
void G4LogicalVolume::SetVisAttributes (const G4VisAttributes& VA)
    {
        fVisAttributes = &VA;
    }

inline void 
G4LogicalVolume::BecomeEnvelopeForFastSimulation(G4FastSimulationManager* pPA)
    {
        SetFastSimulationManager(pPA,TRUE);
    }

inline
void G4LogicalVolume::SetBiasWeight(G4double w)
    {
        fBiasWeight = w;
    }

inline
G4double G4LogicalVolume::GetBiasWeight() const
    {
        return fBiasWeight;
    }
