		Example1 for Reverse Monte Carlo
		--------------------------------
		
		Draft! Draft! Draft!
		
		
This directory contains an example illustrating the use of the 
Reverse Monte Carlo (RMC) mode in a Geant4 application. The Reverse Monte Carlo
mode is also known as Adjoint Monte Carlo and in this document we will alternate
both Reverse and Adjoint terms.

 
Author
-----------
This code as been developed by L.Desorgher, SpaceIT GmbH under the ESA contract 21435/08/NL/AT.


Definition of Reverse/Adjoint Monte Carlo 
---------------------------------
When the sensitive part of a detector is small compared  to its entire size and to the size  of the external extended particle source, 
a lot of time is spent during a normal Monte Carlo run in the simulation of  particle showers that are not 
contributing to the detector signal.  
In such particular case the Reverse Monte Carlo (RMC) method, also known as the 
Adjoint Monte Carlo method, can be used. 
In this method  particles are generated  in or on the external surafec of the sensitive  volume 
of the instrument and then are tracked backward in the geometry till they reaches  the source surface, or exceed an energy threshold.   
During the reverse tracking reverse reactions are applied to the particles.



The Reverse Monte Carlo mode in Geant4
---------------------------------------
Different G4Adjoint classes have been implemented into the Geant4 
toolkit to run an adjoint/reverse simulation in a Geant4 application.
In this implementation an adjoint run is divided in a serie 
of alternative adjoint and forward tracking  of adjoint and normal particles.
One event in the common sense of Geant4 treating one tracking phase. 


a)Reverse tracking phase:

An adjoint particles (adjoint_e-, adjoint_gamma,...) are first generated randomly one by one on the so called adjoint source
with a random energy (1/E distribution) and direction. The adjoint source is the 
external surface of a user defined volume or of a user defined sphere. The adjoint
source should contain one or several sensitive volumes and should be small compared to the entire geometry.
The user can set the min and max energy of the adjoint source. After its
generation the adjoint primary  particle is tracked backward in the geometry till a user  defined external surface (spherical or boundary of a volume)
or is killed before if it reaches a user defined  upper energy limit that represents
the maximum energy of the external source. During the reverse tracking, reverse
processes take place where  the adjoint particle being tracked can be either scattered
or transformed in another type of adjoint particle. During the reverse tracking the
G4SimulationManager replaces the user defined Primary, Run, ... actions, by its own actions.
The reverse tracking phase corresponds to one event in the common sense of Geant4.

b) Forward phase

When an adjoint particle reaches the external surface its weight,type,  position, 
and directions are registered and a  normal primary particle with a type equivalent to the last generated primary adjoint is
generated with the same energy, position but opposite direction  and is  tracked normally in the sensitive region as in a fwd MC simulation. 
During this forward tracking phase the  
event, stacking, stepping, tracking actions defined by the user for its general fwd application are used. By this clear separation between
adjoint and fwd tracking phases , the code of the user developed for a fwd simulation should be only slightly modified to adapt it for an adjoint 
simulation. Indeed  the computation of the signal is done by the same actions or classes that the one used in the fwd simulation mode.  
The forward tracking phase corresponds to one event in the common sense of Geant4.


c) Reverse Processes implemented

During the

The Reverse processes that have been implemented till now are:
	- Reverse discrete  Ionisation for e-, proton and ions
	- Continuous gain of energy by ionisation and bremsstrahlung for e- and by ionisation for protons and ions
	- Reverse discrete e- bremsstrahlung  
	- Reverse photoelectric effect 
	- Reverse Compton scattering
	- An approximated Multiple scattering is implemented where the reverse MS is equivalent to the forward MS but applied to adjoint
		particles

It is important to note that the electromagnetic reverse processes are cut dependent as their equivalent forward processes. 		     


d)Nb of adjoint particle type considered in an adjoint simulation

The list of type of adjoint and fwd particles that are generated alternatively on the adjoint source and considered in the simulation 
is a function of the physics list declared in the physics list.
For example if only the e- and gamma electromagnetic physics is considered, adjoint_e- and adjoint_gamma will be consider as primaries.
In this case on adjoint event will be divided in four G4 event for the tracking of the adjoint e-, the tracking of its equivalent fwd e-, the tracking of 
an adjoint gamma and the tracking of its equivalent forward gamma. In this case a run of 100 adjoint event will consist in 400 G4 event.
If we add the proton electromagnetic physics adjoint and fwd protons are also considered as primary and we obtain 600 G4 events for 100 adjoint events.  


Modification to bring in a existing G4 application to use the Reverse MC method
--------------------------------------------------------------------------------
By this clear separation  of the reverse and forward  tracking  phase it was possible to implement the RMC method such that only
 few modifications are needed to an existing  Geant4 application in order to adapt it for the use of the reverse simulation mode.
The changes are needed only in the analysis phase at the end of the forward tracking where computed signals have to be multiplied by the weight 
of the last reverse tracks and then normalized to different user defined spectra and angular distribution representing the external source.
The weight of the adjoint tracks is computed by the G4Adjoint classes and the user needs
only to multiply them to primary differential, directional spectrum of its choice. The adjoint weight a the of tracks can be also registered if needed
in answer matrices.
 
In order to be able to use the Reverse MC method in his simulation, the user should modify its code as such:
  
  1) Adapt its physics list to use Reverse Processes for adjoint particles. An example of such physics list is provided in an extended 
	  example. 
  2) Create an instance of    G4AdjointSimManager somewhere in the main code.
  
  3) Modify the analysis part of the code to normalize the signal computed during the fwd phase to the weight of the last adjoint particle
	 that reaches the external surface. This is done by using the following method of G4AdjointSimManager.
			 
	    G4int GetIDOfLastAdjParticleReachingExtSource()				     
  	    G4ThreeVector GetPositionAtEndOfLastAdjointTrack(){ return last_pos;}
	    G4ThreeVector GetDirectionAtEndOfLastAdjointTrack(){ return last_direction;}
	    G4double GetEkinAtEndOfLastAdjointTrack(){ return last_ekin;} 
	    G4double GetEkinNucAtEndOfLastAdjointTrack(){ return last_ekin_nuc;}
	    G4double GetWeightAtEndOfLastAdjointTrack(){return last_weight;}
            G4double GetCosthAtEndOfLastAdjointTrack(){return last_cos_th;}
   	    G4String GetFwdParticleNameAtEndOfLastAdjointTrack(){return last_fwd_part_name;}
   	    G4int GetFwdParticlePDGEncodingAtEndOfLastAdjointTrack(){return last_fwd_part_PDGEncoding;}
            G4int GetFwdParticleIndexAtEndOfLastAdjointTrack().

     In order to have a code working for both forward and adjoint simulation mode, the extra code needed in user actions for the adjoint
     simulation mode can be separated to the code needed only for the normal forward  simulation by using the following method
	             
	   G4bool GetAdjointSimMode() that return true if   an adjoint simulation is running and false if not!



exampleRMC01
------------
The example RMC01 illustrates how to modify a G4 application in order to use both forward and reverse MC mode.
	   
	
a)Geometry 
 
A simple geometry is considered a sensitive cylinder at the center of an Aluminum spherical shielding with 10 cm Radius.
Two 0.5mm thick Tantalum plates are putted horizontally above and below the Sensitive Cylinder 
The thickness of the Aluminum shielding  and the height and radius of the sensitive cylinder can be fixed by the user 
as well as the dimensions of the cylinder.


b)Physics

The physical processes considered  are:
	- Reverse and forward discrete  Ionisation for e- and  proton	
	- Continuous gain and loss of energy by ionisation and bremsstrahlung for e- and by ionisation for protons 
	- Reverse and forward discrete e- bremsstrahlung  
	- Reverse and forward photoelectric effect 
	- Reverse and forward Compton scattering
	- Reverse and forward Multiple scattering

These processes are implemented in the class G4AdjointPhysicsList distributed with the example. The G4AdjointPhysicsMessenger allows the user
to switch on/off some processes for testing purpose. By default all processes cited above are considered except the proton ionisation that
has to be specifically switch on in the macro file by the user.



c)Analysis and output of the code

The example computes the energy deposited in the sensitive cylinder and the current of e-, protons, and gamma entering the sensitive cylinder.
The Hits are registered in the sensitive detector class RMC01SD that is a typical G4 Sensitive Detector class used in a forward simulation and is not modified at all
for the adjoint simulation mode. The analysis of the registered hits during forward events is done by the RMCO1AnalysisManager.
That is the class that illustrates how to adapt an analysis code of a fwd simulation to an adjoint simulation.
In this class during a forward simulation the  method EndOfEventForForwardSimulation is used at the end of an event 
while during an adjoint simulation at the end of fwd tracking event the method EndOfEventForAdjointSimulation is called.
By looking at the source of RMCO1AnalysisManager and more particularly to its method EndOfEventForAdjointSimulation the user will
learn how to adapt its G4 analysis code for an adjoint simulation.

The outputs of an adjoint simulation are:

	-The total energy deposited and particle current entering the sensitive cylinder normalized automatically to a user defined primary spectrum(exponential or power law) .
	 These results are stored in the files:
	 	-Adj_Edep_vs_EkinPrim.txt                            
		-Adj_ElectronCurrent.txt
		-Adj_GammaCurrent.txt
		-Adj_ProtonCurrent.txt
		-ConvergenceOfAdjointSimulationResults.txt: The total normalized edep and its relative error registered every 5000 adjoint events
		
		
	-The answer matrix of the energy deposited and particles current on the sensitive cylinder in function of primary energy of e-, gamma and
	protons. These results are stored in the files Adj********_Answer.txt
		   	
		 
	
The outputs of a forward simulation are:	 
	-The mean energy deposited and particle current entering the sensitive cylinder per event.
	 These results are stored in the files:
	 	-Fwd_Edep_vs_EkinPrim.txt                            
		-Fwd_ElectronCurrent.txt
		-Fwd_GammaCurrent.txt
		-Fwd_ProtonCurrent.txt
		-ConvergenceOfAdjointSimulationResults.txt: The total normalized edep and its relative error registered every 5000 adjoint events
		
        
Caution! It is the responsabilty of the user to normalise the results of the forward simulation to the fluence consider in the adjoint 
simulation. For the macro file given with the example this consists in multiplying  the fwd results by pi*100.






Control of the adjoint simulation and the RMC01 code by macro commands
-----------------------------------------------------------------------




Known limitation
-----------------




To be continued!
  

















  





