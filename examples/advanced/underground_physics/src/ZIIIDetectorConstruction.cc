// generated by Geant4 Geometry Editor at Mon Sep 11 13:19:31 GMT+00:00 2000

//------HeaderFile-
#include "ZIIIDetectorConstruction.hh"
#include "ZIIICalorimeterSD.hh"


#include "G4UnitsTable.hh"

#include "G4VUserDetectorConstruction.hh"

#include "globals.hh"
#include "G4Material.hh"
#include "G4MaterialTable.hh"
#include "G4Element.hh"
#include "G4ElementTable.hh"
#include "G4Box.hh"
#include "G4Tubs.hh"
#include "G4LogicalVolume.hh"
#include "G4ThreeVector.hh"
#include "G4PVPlacement.hh"
#include "G4PVReplica.hh"
#include "G4SDManager.hh"
#include "G4VisAttributes.hh"
#include "G4Colour.hh"

ZIIIDetectorConstruction::ZIIIDetectorConstruction()
{ ; }
ZIIIDetectorConstruction::~ZIIIDetectorConstruction()
{ ; }
G4VPhysicalVolume* ZIIIDetectorConstruction::Construct( )
{
// Elements
G4Element* elementO = new G4Element( "Oxygen", "O", 8. , 15.9994*g/mole );
G4Element* elementSi = new G4Element( "Silicon", "Si", 14. , 28.0855*g/mole );
G4Element* elementK = new G4Element( "Potassium", "K", 19. , 39.0983*g/mole );
// G4Element* elementTh = new G4Element( "Thorium", "Th", 90. , 232.0381*g/mole );
/// G4Element* elementU = new G4Element( "Uranium", "U", 92. , 238.0289*g/mole );
G4Element* elementC = new G4Element( "Carbon", "C", 6. , 12.011*g/mole );
G4Element* elementFe = new G4Element( "Iron", "Fe", 26. , 55.845*g/mole );
G4Element* elementCo = new G4Element( "Cobalt", "Co", 27. , 58.9332*g/mole );
G4Element* elementXe = new G4Element( "Xenon", "Xe", 54., 131.29*g/mole );

// Materials from Combination

G4Material* Glass = new G4Material("Glass",  2.2*g/cm3, 5, kStateSolid, 273.15*kelvin, 1.0*atmosphere );
Glass->AddElement( elementO, 0.66-5.0E-5 );
Glass->AddElement( elementSi, 0.34 );
Glass->AddElement( elementK, 5.0E-5 );
// Glass->AddElement( elementTh, 3.7E-7 );
// Glass->AddElement( elementU, 5.8E-7 );
G4Material* Steel = new G4Material("Steel",  7.7*g/cm3, 3, kStateSolid, 273.15*kelvin, 1.0*atmosphere );
Steel->AddElement( elementC, 0.04 );
Steel->AddElement( elementFe, 0.88 );
Steel->AddElement( elementCo, 0.08 );


// Materials from Scratch

G4Material* LXe = new G4Material("LXe", 3.02*g/cm3, 1, kStateLiquid, 173.15*kelvin, 1.5*atmosphere );
G4Material* GXe = new G4Material("GXe", 0.005887*g/cm3, 1, kStateGas, 173.15*kelvin, 1.5*atmosphere );
G4Material* Vacuum = new G4Material("Vacuum", 1, 1.00794*g/mole, 1.0E-25*g/cm3,kStateGas, 0.1*kelvin, 1.0E-19*pascal );
LXe->AddElement( elementXe, 1);
GXe->AddElement( elementXe, 1);


// Visualization attributes


  G4VisAttributes * Liquid_Xe= new G4VisAttributes( G4Colour(102/255. ,255/255. ,255/255. ));
  Liquid_Xe->SetVisibility(true);
  //Liquid_Xe->SetLineStyle(unbroken);
  Liquid_Xe->SetLineWidth(1);
  //Liquid_Xe->SetForceWireFrame(true);
  //Liquid_Xe->SetForceSolid(true);

  G4VisAttributes * yellow= new G4VisAttributes( G4Colour(255/255. ,255/255. ,51/255. ));
  yellow->SetVisibility(true);
  //yellow->SetLineStyle(unbroken);
  //yellow->SetForceWireFrame(true);
  yellow->SetForceSolid(true);

  G4VisAttributes * yellow_clear= new G4VisAttributes( G4Colour(255/255. ,255/255. ,51/255. ));
  yellow_clear->SetVisibility(true);
  //yellow->SetLineStyle(unbroken);
  //yellow->SetForceWireFrame(true);
  yellow_clear->SetForceSolid(false);

  G4VisAttributes * green= new G4VisAttributes( G4Colour(0/255. ,255/255. ,51/255. ));
  green->SetVisibility(true);
  //green->SetLineStyle(unbroken);
  //green->SetForceWireFrame(true);
  //green->SetForceSolid(true);

  G4VisAttributes * purple= new G4VisAttributes( G4Colour(255/255. ,51/255. ,255/255. ));
  purple->SetVisibility(true);
  //purple->SetForceWireFrame(true);
  //purple->SetLineStyle(unbroken);
  purple->SetForceSolid(false);

  G4VisAttributes * purple_solid= new G4VisAttributes( G4Colour(255/255. ,51/255. ,255/255. ));
  purple_solid->SetVisibility(true);
  //purple->SetForceWireFrame(true);
  //purple->SetLineStyle(unbroken);
  purple_solid->SetForceSolid(true);

  G4VisAttributes * red= new G4VisAttributes( G4Colour(255/255. ,51/255. ,51/255. ));
  red->SetVisibility(true);
  //red->SetLineStyle(unbroken);
  red->SetForceSolid(true);

  G4VisAttributes * invisible= new G4VisAttributes( G4Colour(255/255. ,255/255. ,255/255. ));
  invisible->SetVisibility(false);

  // Logical  Volumes

  G4Box *solidCavern= new G4Box("solidCavern", 3.0*m, 3.0*m, 3.0*m );
  G4LogicalVolume * logicalCavern = new G4LogicalVolume(solidCavern, 	 //its solid
							Vacuum, 		 //its material
							"logicalCavern" ,		 //its name
							0,0,0);

  logicalCavern->SetVisAttributes(invisible);

  G4Tubs *solidSS_Base_Plate= new G4Tubs("solidSS_Base_Plate", 0.0*mm, 320.0*mm, 15.0*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logicalSS_Base_Plate = new G4LogicalVolume(solidSS_Base_Plate, 	 //its solid
							       Steel, 		 //its material
							       "logicalSS_Base_Plate" ,		 //its name
							       0,0,0);

  logicalSS_Base_Plate->SetVisAttributes(yellow_clear);

  G4Tubs *solid1st_Electrode= new G4Tubs("solid1st_Electrode", 194.0*mm, 209.0*mm, 15.0*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logical1st_Electrode = new G4LogicalVolume(solid1st_Electrode, 	 //its solid
							       Steel, 		 //its material
							       "logical1st_Electrode" ,		 //its name
							       0,0,0);

  logical1st_Electrode->SetVisAttributes(yellow);

  G4Tubs *solid2nd_Electrode= new G4Tubs("solid2nd_Electrode", 194.0*mm, 209.0*mm, 9.0*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logical2nd_Electrode = new G4LogicalVolume(solid2nd_Electrode, 	 //its solid
							       Steel, 		 //its material
							       "logical2nd_Electrode" ,		 //its name
							       0,0,0);

  logical2nd_Electrode->SetVisAttributes(yellow);

  G4Tubs *solidMirror= new G4Tubs("solidMirror", 0.0*mm, 209.0*mm, 3.5*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logicalMirror = new G4LogicalVolume(solidMirror, 	 //its solid
							Steel, 		 //its material
							"logicalMirror" ,		 //its name
							0,0,0);

  logicalMirror->SetVisAttributes(yellow_clear);

  G4Tubs *solidPMT_ledge= new G4Tubs("solidPMT_ledge", 125.0*mm, 184.0*mm, 2.0*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logicalPMT_ledge = new G4LogicalVolume(solidPMT_ledge, 	 //its solid
							   Steel, 		 //its material
							   "logicalPMT_ledge" ,		 //its name
							   0,0,0);

  logicalPMT_ledge->SetVisAttributes(purple_solid);

  G4Tubs *solidXe_fid2ledge= new G4Tubs("solidXe_fid2ledge", 0.0*mm, 219.0*mm, 30.0*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logicalXe_fid2ledge = new G4LogicalVolume(solidXe_fid2ledge, 	 //its solid
							      LXe, 		 //its material
							      "logicalXe_fid2ledge" ,		 //its name
							      0,0,0);

  logicalXe_fid2ledge->SetVisAttributes(Liquid_Xe);

  G4Tubs *solidXe_leg2base= new G4Tubs("solidXe_leg2base", 0.0*mm, 165.0*mm, 77.5*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logicalXe_leg2base = new G4LogicalVolume(solidXe_leg2base, 	 //its solid
							     LXe, 		 //its material
							     "logicalXe_leg2base" ,		 //its name
							     0,0,0);

  logicalXe_leg2base->SetVisAttributes(Liquid_Xe);

  G4Tubs *solidVacuo_pmlev= new G4Tubs("solidVacuo_pmlev", 165.0*mm, 240.0*mm, 77.5*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logicalVacuo_pmlev = new G4LogicalVolume(solidVacuo_pmlev, 	 //its solid
							     Vacuum, 		 //its material
							     "logicalVacuo_pmlev" ,		 //its name
							     0,0,0);

  logicalVacuo_pmlev->SetVisAttributes(purple);

  G4Tubs *solidPMT_Glass_body= new G4Tubs("solidPMT_Glass_body", 24.0*mm, 25.0*mm, 60.0*mm, 0.0*deg, 360.0*deg );
  G4LogicalVolume * logicalPMT_Glass_body = new G4LogicalVolume(solidPMT_Glass_body, 	 //its solid
								Glass, 		 //its material
								"logicalPMT_Glass_body" ,		 //its name
								0,0,0);

  logicalPMT_Glass_body->SetVisAttributes(red);


// Physical Volumes ----  Single Positioned Placement,   Repeated Placement,   Slicing  --------------------------- 


// Single Positioned Placement 

  G4RotationMatrix rotMatrixCavern_Phys;   // unit rotation matrix
  G4double angleCavern_Phys = 0.0*deg;   // rotational angle
  rotMatrixCavern_Phys.rotateX(angleCavern_Phys);  // rot matrix

  G4VPhysicalVolume *  physicalCavern_Phys= new G4PVPlacement(G4Transform3D(rotMatrixCavern_Phys,	//rotation 
									    G4ThreeVector(0.0*m, 0.0*m, 0.0*m)),
							      "physicalCavern_Phys",   //its name  (2nd constructor)
							      logicalCavern,         //its logical volume 
							      NULL,              //its mother volume 
							      false,                 //no boolean operation 
							      0);                       //copy number 

  G4RotationMatrix rotMatrixSS_Base_Phys;   // unit rotation matrix
  G4double angleSS_Base_Phys = 0.0*deg;   // rotational angle
  rotMatrixSS_Base_Phys.rotateX(angleSS_Base_Phys);  // rot matrix

  G4VPhysicalVolume *  physicalSS_Base_Phys= new G4PVPlacement(G4Transform3D(rotMatrixSS_Base_Phys,	//rotation 
									     G4ThreeVector(0.0*m, 0.0*m, 0.0*m)),
							       "physicalSS_Base_Phys",   //its name  (2nd constructor)
							       logicalSS_Base_Plate,         //its logical volume 
							       physicalCavern_Phys,              //its mother volume 
							       false,                 //no boolean operation 
							       0);                       //copy number 

  G4RotationMatrix rotMatrixXe_fid2l_Phys;   // unit rotation matrix
  G4double angleXe_fid2l_Phys = 0.0*deg;   // rotational angle
  rotMatrixXe_fid2l_Phys.rotateX(angleXe_fid2l_Phys);  // rot matrix

  G4VPhysicalVolume *  physicalXe_fid2l_Phys= new G4PVPlacement(G4Transform3D(rotMatrixXe_fid2l_Phys,	//rotation 
									      G4ThreeVector(0.0*m, 0.0*m, 0.2*m)),
								"physicalXe_fid2l_Phys",   //its name  (2nd constructor)
								logicalXe_fid2ledge,         //its logical volume 
								physicalCavern_Phys,              //its mother volume 
								false,                 //no boolean operation 
								0);                       //copy number 

  G4RotationMatrix rotMatrix1st_Elec_Phys;   // unit rotation matrix
  G4double angle1st_Elec_Phys = 0.0*deg;   // rotational angle
  rotMatrix1st_Elec_Phys.rotateX(angle1st_Elec_Phys);  // rot matrix

  G4VPhysicalVolume *  physical1st_Elec_Phys= new G4PVPlacement(G4Transform3D(rotMatrix1st_Elec_Phys,	//rotation 
									      G4ThreeVector(0.0*m, 0.0*m, 0.0265*m)),
								"physical1st_Elec_Phys",   //its name  (2nd constructor)
								logical1st_Electrode,         //its logical volume 
								physicalXe_fid2l_Phys,              //its mother volume 
								false,                 //no boolean operation 
								0);                       //copy number 

  G4RotationMatrix rotMatrix2nd_Elec_Phys;   // unit rotation matrix
  G4double angle2nd_Elec_Phys = 0.0*deg;   // rotational angle
  rotMatrix2nd_Elec_Phys.rotateX(angle2nd_Elec_Phys);  // rot matrix

  G4VPhysicalVolume *  physical2nd_Elec_Phys= new G4PVPlacement(G4Transform3D(rotMatrix2nd_Elec_Phys,	//rotation 
									      G4ThreeVector(0.0*m, 0.0*m, 0.0135*m)),
								"physical2nd_Elec_Phys",   //its name  (2nd constructor)
								logical2nd_Electrode,         //its logical volume 
								physicalXe_fid2l_Phys,              //its mother volume 
								false,                 //no boolean operation 
								0);                       //copy number 

  G4RotationMatrix rotMatrixMirror_Phys;   // unit rotation matrix
  G4double angleMirror_Phys = 0.0*deg;   // rotational angle
  rotMatrixMirror_Phys.rotateX(angleMirror_Phys);  // rot matrix

  G4VPhysicalVolume *  physicalMirror_Phys= new G4PVPlacement(G4Transform3D(rotMatrixMirror_Phys,	//rotation 
									    G4ThreeVector(0.0*m, 0.0*m, 0.2385*m)),
							      "physicalMirror_Phys",   //its name  (2nd constructor)
							      logicalMirror,         //its logical volume 
							      physicalCavern_Phys,              //its mother volume 
							      false,                 //no boolean operation 
							      0);                       //copy number 

  G4RotationMatrix rotMatrixPMT_leg_Phys;   // unit rotation matrix
  G4double anglePMT_leg_Phys = 0.0*deg;   // rotational angle
  rotMatrixPMT_leg_Phys.rotateX(anglePMT_leg_Phys);  // rot matrix

  G4VPhysicalVolume *  physicalPMT_leg_Phys= new G4PVPlacement(G4Transform3D(rotMatrixPMT_leg_Phys,	//rotation 
									     G4ThreeVector(0.0*m, 0.0*m, 0.0135*m)),
							       "physicalPMT_leg_Phys",   //its name  (2nd constructor)
							       logicalPMT_ledge,         //its logical volume 
							       physicalXe_fid2l_Phys,              //its mother volume 
							       false,                 //no boolean operation 
							       0);                       //copy number 

  G4RotationMatrix rotMatrixXe_l2base_Phys;   // unit rotation matrix
  G4double angleXe_l2base_Phys = 0.0*deg;   // rotational angle
  rotMatrixXe_l2base_Phys.rotateX(angleXe_l2base_Phys);  // rot matrix

  G4VPhysicalVolume *  physicalXe_l2base_Phys= new G4PVPlacement(G4Transform3D(rotMatrixXe_l2base_Phys,	//rotation 
									       G4ThreeVector(0.0*m, 0.0*m, 0.0925*m)),
								 "physicalXe_l2base_Phys",   //its name  (2nd constructor)
								 logicalXe_leg2base,         //its logical volume 
								 physicalCavern_Phys,              //its mother volume 
								 false,                 //no boolean operation 
								 0);                       //copy number 

  G4RotationMatrix rotMatrixVac_pmlev_Phys;   // unit rotation matrix
  G4double angleVac_pmlev_Phys = 0.0*deg;   // rotational angle
  rotMatrixVac_pmlev_Phys.rotateX(angleVac_pmlev_Phys);  // rot matrix

  G4VPhysicalVolume *  physicalVac_pmlev_Phys= new G4PVPlacement(G4Transform3D(rotMatrixVac_pmlev_Phys,	//rotation 
									       G4ThreeVector(0.0*m, 0.0*m, 0.0925*m)),
								 "physicalVac_pmlev_Phys",   //its name  (2nd constructor)
								 logicalVacuo_pmlev,         //its logical volume 
								 physicalCavern_Phys,              //its mother volume 
								 false,                 //no boolean operation 
								 0);                       //copy number 


  // Repeated Placement Translation 

  G4int copyPMT_no_1;
  char PMTName[20];
  G4String PMTPhysName;
  copyPMT_no_1=0;
  for (G4int PMT_no_1=1; PMT_no_1<=3; PMT_no_1++){
    //for (G4int PMT_no_1=1; PMT_no_1<=; PMT_no_1++){
    sprintf( PMTName, "physicalPMT_no_1_%d", PMT_no_1 );
    PMTPhysName = PMTName;
    G4double transPMT_no_1 =0.0*m+52.0*mm*(PMT_no_1-1);
    G4VPhysicalVolume * physicalPMT_no_1 = new G4PVPlacement(0,  //no rotation 
							     G4ThreeVector(transPMT_no_1, 0.0*m, 0.0*m),
							     PMTPhysName,   //its name 
							     logicalPMT_Glass_body,         //its logical volume
							     physicalXe_l2base_Phys,            //its mother volume
							     //		 false,             //no boolean operation
							     true,             //no boolean operation
							     copyPMT_no_1++);      //copy number 
  }

  G4int copyPMT_no_1a;
  copyPMT_no_1a=0;
  for (G4int PMT_no_1a=1; PMT_no_1a<=2; PMT_no_1a++){
    //for (G4int PMT_no_1a=1; PMT_no_1a<=; PMT_no_1a++){
    sprintf( PMTName, "physicalPMT_no_1a_%d", PMT_no_1a );
    PMTPhysName = PMTName;
    G4double transPMT_no_1a =-52.0*mm-52.0*mm*(PMT_no_1a-1);
    G4VPhysicalVolume * physicalPMT_no_1a = new G4PVPlacement(0,  //no rotation 
							      G4ThreeVector(transPMT_no_1a, 0.0*m, 0.0*m),
							      PMTPhysName,   //its name 
							      logicalPMT_Glass_body,         //its logical volume
							      physicalXe_l2base_Phys,            //its mother volume
							      //		 false,             //no boolean operation
							      true,             //no boolean operation
							      copyPMT_no_1a++);      //copy number 
  }

  G4int copyPMT_no_2;
  copyPMT_no_2=0;
  for (G4int PMT_no_2=1; PMT_no_2<=6; PMT_no_2++){
    sprintf( PMTName, "physicalPMT_no_2_%d", PMT_no_2 );
    PMTPhysName = PMTName;
    G4double transPMT_no_2 =-182.0*mm+52.0*mm*(PMT_no_2);
    G4VPhysicalVolume * physicalPMT_no_2 = new G4PVPlacement(0,  //no rotation 
							     G4ThreeVector(transPMT_no_2, 45.033*mm, 0.0*m),
							     PMTPhysName,   //its name 
							     logicalPMT_Glass_body,         //its logical volume
							     physicalXe_l2base_Phys,            //its mother volume
							     //		 false,             //no boolean operation
							     true,             //no boolean operation
							     copyPMT_no_2++);      //copy number 
  }

  G4int copyPMT_no_2a;
  copyPMT_no_2a=0;
  for (G4int PMT_no_2a=1; PMT_no_2a<=6; PMT_no_2a++){
    sprintf( PMTName, "physicalPMT_no_2a_%d", PMT_no_2a );
    PMTPhysName = PMTName;
    G4double transPMT_no_2a =-182.0*mm+52.0*mm*(PMT_no_2a);
    G4VPhysicalVolume * physicalPMT_no_2a = new G4PVPlacement(0,  //no rotation 
							      G4ThreeVector(transPMT_no_2a, -45.033*mm, 0.0*m),
							      PMTPhysName,   //its name 
							      logicalPMT_Glass_body,         //its logical volume
							      physicalXe_l2base_Phys,            //its mother volume
							      //		 false,             //no boolean operation
							      true,             //no boolean operation
							      copyPMT_no_2a++);      //copy number 
  }

  G4int copyPMT_no_3;
  copyPMT_no_3=0;
  for (G4int PMT_no_3=1; PMT_no_3<=5; PMT_no_3++){
    sprintf( PMTName, "physicalPMT_no_3_%d", PMT_no_3 );
    PMTPhysName = PMTName;
    G4double transPMT_no_3 =-156.0*mm+52.0*mm*(PMT_no_3);
    G4VPhysicalVolume * physicalPMT_no_3 = new G4PVPlacement(0,  //no rotation 
							     G4ThreeVector(transPMT_no_3, 90.066*mm, 0.0*m),
							     PMTPhysName,   //its name 
							     logicalPMT_Glass_body,         //its logical volume
							     physicalXe_l2base_Phys,            //its mother volume
							     //		 false,             //no boolean operation
							     true,             //no boolean operation
							     copyPMT_no_3++);      //copy number 
  }

  G4int copyPMT_no_3a;
  copyPMT_no_3a=0;
  for (G4int PMT_no_3a=1; PMT_no_3a<=5; PMT_no_3a++){
    sprintf( PMTName, "physicalPMT_no_3a_%d", PMT_no_3a );
    PMTPhysName = PMTName;
    G4double transPMT_no_3a =-156.0*mm+52.0*mm*(PMT_no_3a);
    G4VPhysicalVolume * physicalPMT_no_3a = new G4PVPlacement(0,  //no rotation 
							      G4ThreeVector(transPMT_no_3a, -90.066*mm, 0.0*m),
							      PMTPhysName,   //its name 
							      logicalPMT_Glass_body,         //its logical volume
							      physicalXe_l2base_Phys,            //its mother volume
							      //		 false,             //no boolean operation
							      true,             //no boolean operation
							      copyPMT_no_3a++);      //copy number 
  }

  G4int copyPMT_no_4;
  copyPMT_no_4=0;
  for (G4int PMT_no_4=1; PMT_no_4<=2; PMT_no_4++){
    sprintf( PMTName, "physicalPMT_no_4_%d", PMT_no_4 );
    PMTPhysName = PMTName;
    G4double transPMT_no_4 =-78.0*mm+52.0*mm*(PMT_no_4);
    G4VPhysicalVolume * physicalPMT_no_4 = new G4PVPlacement(0,  //no rotation 
							     G4ThreeVector(transPMT_no_4, -135.099*mm, 0.0*m),
							     PMTPhysName,   //its name 
							     logicalPMT_Glass_body,   //its logical volume
							     physicalXe_l2base_Phys,  //its mother volume
							     //	 false,   //no boolean operation
							     true,             //no boolean operation
							     copyPMT_no_4++);      //copy number 
  }

  G4int copyPMT_no_4a;
  copyPMT_no_4a=0;
  for (G4int PMT_no_4a=1; PMT_no_4a<=2; PMT_no_4a++){
    sprintf( PMTName, "physicalPMT_no_4a_%d", PMT_no_4a );
    PMTPhysName = PMTName;
    G4double transPMT_no_4a =-78.0*mm+52.0*mm*(PMT_no_4a);
    G4VPhysicalVolume * physicalPMT_no_4a = new G4PVPlacement(0,  //no rotation 
							      G4ThreeVector(transPMT_no_4a, 135.099*mm, 0.0*m),
							      PMTPhysName,   //its name 
							      logicalPMT_Glass_body,     //its logical volume
							      physicalXe_l2base_Phys,    //its mother volume
							      // false,  //no boolean operation
							      true,             //no boolean operation
							      copyPMT_no_4a++);      //copy number 
  }

  //G4int copyPMT_no_4b;
  //copyPMT_no_4b=0;
  //for (G4int PMT_no_4b=1; PMT_no_4b<=2; PMT_no_4b++){
  //  G4double transPMT_no_4b =-156.0*mm+52.0*mm*(PMT_no_4b);
  //  //  G4double vertPMT_no4b = 90.066*mm ;
  //  G4double vertPMT_no_4b = 135.099*mm - 45.033*mm*(PMT_no_4b) ;
  //  G4VPhysicalVolume * physicalPMT_no_4b = new G4PVPlacement(0,  //no rotation 
  //		 G4ThreeVector(transPMT_no_4b, vertPMT_no_4b, 0.0*m),
  //		 "physicalPMT_no_4b",   //its name 
  //		 logicalPMT_Glass_body,         //its logical volume
  //		 physicalXe_l2base_Phys,            //its mother volume
  ////		 false,             //no boolean operation
  //		 true,             //no boolean operation
  //		 copyPMT_no_4b++);      //copy number 
  //}


// Repeated Placement AxialSymmetoric

// Active Rotation of Bodies
  G4int copy;
  copy=0;
  G4RotationMatrix rotationMatrix;G4double start = 0.0*deg;
  G4double inc = 0.0*deg;
  rotationMatrix.rotateZ(start);
  G4double x0 = 0.0*mm;
  G4double y0 = 0.0*mm;
  G4double z0 = 0.0*mm;
  G4double radius = 0.0*mm;

  //for (G4int =1; <=0; ++){
  //  G4double trans = start+inc*(-1);

  //  G4double x, y, z;
  //  x = x0 + radius * cos(trans);
  //  y = y0 + radius * sin(trans);
  //  z = z0;
  //  G4VPhysicalVolume * physical = new G4PVPlacement(G4Transform3D(rotationMatrix,	//rotate
  //		 G4ThreeVector(x, y, z)),
  //		 "physical",   //its name 
  //		 logical,         //its logical volume
  //		 physical,            //its mother volume
  //		 false,             //no boolean operation
  //		 copy++);      //copy number 
  //  rotationMatrix.rotateZ(inc);
  //}

  // Sensitive Detectors: Absorber and Gap
  //
  G4SDManager* SDman = G4SDManager::GetSDMpointer();

  G4String calorimeterChamberSDname = "ZIII/FiducialVolumeSD";
  ZIIICalorimeterSD* aCalorimeterSD = new ZIIICalorimeterSD( calorimeterChamberSDname );
  SDman->AddNewDetector( aCalorimeterSD );
  //  logicalXe_leg2base->SetSensitiveDetector( aCalorimeterSD );
  logicalXe_fid2ledge->SetSensitiveDetector( aCalorimeterSD );



// Slicing Translation 


// Slicing AxialSymmetric 


// return the physical World


  return physicalCavern_Phys;
}
